<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>owenzhang的博客</title>
  
  <subtitle>一个程序员的成长之路</subtitle>
  <link href="https://yunpengzhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://yunpengzhang.github.io/"/>
  <updated>2024-07-20T15:19:39.375Z</updated>
  <id>https://yunpengzhang.github.io/</id>
  
  <author>
    <name>owenzhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>向着目标冲击——读《曼巴精神：科比自传》</title>
    <link href="https://yunpengzhang.github.io/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/"/>
    <id>https://yunpengzhang.github.io/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/</id>
    <published>2024-07-10T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>初读《曼巴精神：科比自传》还是在科比刚去世时，转眼已经几年过去了，科比还没有被球迷们遗忘。写一篇读后感纪念下科比。</p><p>如果你想对科比有全面的了解，那么这本书值得一一读。</p><p>本书是科比唯一授权的自传。类似于娱乐明星的自传，文字内容很少，夹杂着很多照片，如果想快速度一个下午就差不多读完了。</p><h1 id="科比的成就"><a href="#科比的成就" class="headerlink" title="科比的成就"></a>科比的成就</h1><p>喜欢篮球的人对科比应该不会陌生，论在世界的知名度，应该是篮球界的一哥。</p><p>起码在中国，拿出科比的照片，80，90后应该都会认识。</p><p>虽然乔丹和詹姆斯也很厉害，但是科比在实名度方面应该更胜一筹。</p><p>因为科比处在的时代是NBA最繁盛的时期，那时中美关系还很好，乔丹也退役了。</p><p>国人对篮球的关注度最为高涨，因为王治郅，姚明，巴特，孙悦，易建联多位球员登陆NBA打球。</p><p>那时CCTV5还会转播常规赛，自然对于NBA的当家球星科比来说，在中国的知名度水涨船高。</p><p>当时中学生穿的篮球衣大多数是湖人队，科比也成了那一代的篮球回忆。。</p><p>在北京奥运会上，别的体育明星镜头都是一闪而过，唯有科比特写停留几秒，这才是世界超巨所有的待遇。</p><p>在科比职业生涯中，获得过5次总冠军，一次3连贯（湖人王朝）。</p><p>获得过北京奥运会冠军。</p><h1 id="科比的努力"><a href="#科比的努力" class="headerlink" title="科比的努力"></a>科比的努力</h1><p>通过读这本书，终于明白了为什么科比可以获得这么多成就。</p><p>获取这么多成就不只是天赋，更多是后天的努力。确定目标后不顾一切地冲向目标，不到最后一秒不算完。</p><h2 id="目标管理"><a href="#目标管理" class="headerlink" title="目标管理"></a>目标管理</h2><p>在加入NBA初期，科比就以成为伟大球员为目标，励志得总冠军，进名人堂。</p><p>为了得到总冠军，科比加强训练。</p><p>科比的训练哲学：如果有效，就坚持到底，哪怕他不流行（实用主义）</p><p>为了平衡工作和家庭，会选择午夜训练，确保家人和训练都不影响。因此会有一个勤奋的梗 —— 你见过凌晨4点的洛杉矶吗？</p><p>伟大并非常人所及，为了伟大要做出牺牲，要为之痴迷。他的训练达到了痴迷的程度，热身时会从篮下开始，把每个位置都投一遍。保持身体在最佳状态，可以跑一整天。</p><p>为了得到总冠军，会详尽办法向前人请教，乔丹，湖人名宿都会去问，因为他认为哪怕平时尴尬，总强过退役时没有一个总冠军出丑大。</p><p>为了实现冠军，会把和冠军相关的所有因素都准备完善，达到极致。</p><h2 id="迎难而上"><a href="#迎难而上" class="headerlink" title="迎难而上"></a>迎难而上</h2><p>为了取得职业成就，科比付出了很多肉体的伤病，但是伤病没有打倒他，反而让他更强。</p><p>每场比赛、训练后，要用冰敷来消除炎症，双脚在冰桶泡20分钟。有时还会进行冰与火之歌，4分钟冷水，4分钟热水交替循环。甚至在职业生涯后期，打完球赛，两条腿会有像小瓜一样大小的积液。</p><p>科比的肩膀有时会发生错位，在比赛前要给扶正。</p><p>如果说伤病对于每个运动员都必不可少，那么科比在伤病时对待比赛的态度更难等可贵。</p><p>在比赛时手指当时断了，马上到更衣室拍X光，队医确定打球不会恶化后，科比带着断了的手指商场比赛。最终在退役后手指也不能弯曲。</p><p>在科比即将退役前，跟腱断裂，他也感觉到了肯定很严重，甚至会导致退役。但是罚完球才下场。凭借着顽强的毅力，科比带着伤痛前行。最后跟腱手术，留下了一道很深的疤痕带着厚厚的缝合线。</p><p>每天投1000球为了让手指适应新的投篮手型。</p><p>在俱乐部，国家队都要当球队老大。面对新的当家球员，总是迎难而上，主动防守詹姆斯，擒贼擒王。</p><p>书里没有写为什么科比叫黑曼巴，但是看过科比的比赛，他在比赛中防守时，会像蛇一样缠斗住对手，不给对方任何机会。有一个经典的镜头，对方用球砸向他的眼睛，视图让他恐惧，但是他丝毫未动。</p><h2 id="冠军背后"><a href="#冠军背后" class="headerlink" title="冠军背后"></a>冠军背后</h2><p>在书中介绍了很多不为人知的事情。科比也是普通人，为了赢得总冠军，做了不少规则以外的事情。</p><p>研究裁判规则，平时和裁判搞好关系。在比赛中会利用裁判的盲区，做一些犯规动作。防守其他人时，也会针对其他人的弱点去犯规。例如对麦迪，知道他腰有伤，会故意冲撞他的痛处。</p><p>然而在竞技比赛中，这种情况也很常见。因为乔丹和罗德曼防守科比时，也会卡住他的手，控制科比的移动。</p><p>毕竟是商业联盟，一切都是为了赢。</p><p>科比也坦言到，在职业生涯末期，没有争夺总冠军的情况下，才会像篮球新秀传递一些篮球技法。</p><p>通过自传也发现，科比和奥尼尔的关系应该不好。在书中多次提到加索尔，但是提到奥尼尔的只有几处。在最后有专门描写和其他球员关系的章节中，也没有奥尼尔。</p><p>估计对于谁是湖人一哥两个人争夺的比较激烈。在三连冠期间，奥尼尔都是FMVP，科比的性格肯定接受不了。因为可能会认为科比是和奥尼尔混到的冠军。最终奥尼尔走了，在后面的两冠终于拿到了FMVP。</p><p>但是奥尼尔得了六次总冠军，而且奥尼尔的努力程度不及科比。奥尼尔有着更高的天赋，和更好的运气。奥尼尔还投资了早期谷歌。寿命也比科比长。</p><p>如果科比不努力，取得的成就更少。除了要和别人比，也要和自己比，对于天赋和运气要看开些。</p><p>为了实现总冠军，科比真是把能做的都做了。职业生涯五次冠军，也是非常好的战绩。而且在退役之战得了60分，退役巡演完美完成。</p><p>在退役后科比也没有就此享受，而是开启了公司，甚至说过几年后他最大的成就不是篮球而是其他领域。</p><p>可惜出现了意外事故，一代传奇就此结束。</p><p>致敬偶像最好的方式是让自己配得上他，虽然科比已经离世，但是曼巴精神长存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;初读《曼巴精神：科比自传》还是在科比刚去世时，转眼已经几年过去了，科比还没有被球迷们遗忘。写一篇读后感纪念下科比。&lt;/p&gt;
&lt;p&gt;如果你想对科比有全面的了解，那么这本书值得一一读。&lt;/p&gt;
&lt;p&gt;本书是科比唯一授权的自传。类似于娱乐明星的自传，文字内容很少，夹杂着很多照片，</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>认识思考的本质——《思考，快与慢》</title>
    <link href="https://yunpengzhang.github.io/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/"/>
    <id>https://yunpengzhang.github.io/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/</id>
    <published>2020-01-09T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>《思考，快与慢》这本书已经读过好几遍，最近为了分享给部门的同学们，又重新读了一遍。又有很多新发现。从前有些地方有遗漏，有些地方理解的也不准确。这次再总结下，否则过一段时间在记忆自我中，可能这本书的内容剩下的就不多了。</p><h2 id="为什么读这本书"><a href="#为什么读这本书" class="headerlink" title="为什么读这本书"></a>为什么读这本书</h2><p>最早知道这本书，是CTO推荐的，而且在各种场合推荐过很多次，是提升管理能力必读的一本书。此书的分类也是经管类，通过学习这本书，来更科学地做决策。我们平时使用的科学决策法，其中的一些原理本书也有介绍。通过对人思考的了解，在做决策时，规避自身思考的误区。</p><p>这本书的作者很有名，叫丹尼尔卡尼曼，心理学家，以色列人，在美国做研究。因为前景理论，修正了经济学中经济人的假设，在2002年获得诺贝尔经济学奖。经济人就是说人都是理性的，在进行一些决策时总会用最优法。但从心理学发现，人做决策时并不是理性的，即使是经济学家，也并不理性。</p><p>这本书也是2011年纽约时报的十大好书，在国内的一些读书榜单中，也经常出现。</p><p>全书分为五个部分，向我们介绍了人是如何思考，以及一些非理性思考的规律，还有对应的实验，是一本很严谨的书。</p><h2 id="第一部分：系统1和系统2"><a href="#第一部分：系统1和系统2" class="headerlink" title="第一部分：系统1和系统2"></a>第一部分：系统1和系统2</h2><p>了解系统1和系统2是阅读本书的基础。他们是2种思维能力的描述。在人脑中并不存在系统1和系统2两个部分。</p><p>系统1是快速的，无意识的，是人直接对事物思考的反馈。例如看到一张愤怒的脸，马上就能识别表情是愤怒。这就是系统1的作用。使用系统1不怎么费脑力，但是我们不能主动关闭他，而且系统1不善于逻辑和统计学问题。</p><p>系统2则在系统1遇到麻烦时来解决问题。例如计算17×24。系统1并不能马上给出，这时系统2来进行处理。在使用系统2的时候，人会比较专注，而且也很耗费体力，会感到劳累。这也是为什么人不是时时刻刻都用系统2的原因。</p><p>由于系统1很快，有时会忽略一些因素，这也是我们有时做决策会出现错误的原因。例如看下面的图片，在左面系统1就会认为这个是数字3，在右面，系统1就认为这是字母B。之所以一样的符号，在不同环境，会认为不同的内容，是因为系统1会直接忽略不明确的元素，根据环境来直接作出判断。但一切发生的行云流水，我们都没有感知。生活中还有众多的事情，我们都是这样忽略过去，直接作出判断。<img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240718191507391" class="" title="图片"></p><p>一个经过思维专业训练的人，在做决策时也是要抑制住系统1的判断。例如下面这张图。训练过的人知道两个线段是一样长。但是在感官上，还是看上面的要短些。因为我们的系统1不能主动关闭，在决策时要有意识主动抑制系统1的错误想法。<img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240718191521009" class="" title="图片"></p><h2 id="第二部分-启发法与偏见"><a href="#第二部分-启发法与偏见" class="headerlink" title="第二部分 启发法与偏见"></a>第二部分 启发法与偏见</h2><p>在日常生活中，我们会主动在头脑中构建一些信息，利用已有的小部分内容，思考出认为合理的方案。从而产生出错误的决策和偏见。</p><h3 id="小数定律"><a href="#小数定律" class="headerlink" title="小数定律"></a>小数定律</h3><p>一件事情人们经历过小样本，就会忽略大样本。一般会忽略掉概率的存在，有时还会人为启发，脑补全部内容，认为自己思考的很有道理。</p><p>在生活中很常见。例如问一些同学，中国的本科率有多少？有的认为达到60%以上，因为他周围的人都是这样。这就是小数定律的例子。根据自己见到的，而忽略掉了整体的数据。以前有说五环内的产品经理，也是如此。在做产品和决策的时候，要客观收集数据，重视事物的概率。</p><p>有些人买彩票，也会有一套什么样的选号能中奖的理论，这都是人为启发的结果，把偶发事件用因果解释。</p><p>有些事情是没有因果关系的，只是偶发事件，做因果解释必然会是错误的。</p><h3 id="锚定效应"><a href="#锚定效应" class="headerlink" title="锚定效应"></a>锚定效应</h3><p>给定一个参照物，后面做的一些判定就会以这个参照物来做。</p><p>例如讨价还价的时候，先定了一个价格，后面大家都会围绕着这个价格去讨论，最终的成交价就在最初价格附近。</p><p>还有的公司为了提升品牌价值，在宣传的时候，会与知名大公司对标。都是为了让大众产生锚定，把两个公司划分在一个档次中。</p><p>锚定效应在商业谈判，还有商品定价方面，应用的很广。</p><h3 id="可得性启发法"><a href="#可得性启发法" class="headerlink" title="可得性启发法"></a>可得性启发法</h3><p>有些事情大家从记忆搜寻，会把容易想到的认为发生概率大。例如飞机失事事件，在新闻中看到的频率很高，就认为飞机很不安全。但实际上飞机的事故率要远远低于其他交通工具。和小数定律类似，我们在做决策的时候，还是要注重客观数据，而不要仅依靠主观记忆。</p><p>还有个有意思的现象，人可以解答所有问题。因为人在解答一些困难问题时，会通过联想关联，把问题自动替换，然后解答。这也是系统1执行的，有时都没在意就把问题替换了。例如问最近幸福吗？可能就会把最近谈朋友的事情替换掉这个问题，思考的都是谈朋友的感受。</p><h3 id="光环效应"><a href="#光环效应" class="headerlink" title="光环效应"></a>光环效应</h3><p>例如一个演员长的帅，我们也会认为他什么都好。例如有些漂亮演员的字写的不好，观众看到都不相信。在日常面试时，要注意光环效应，防止因为应试者一项的好坏，而影响到其他方面。</p><h3 id="焦虑情绪与风险政策"><a href="#焦虑情绪与风险政策" class="headerlink" title="焦虑情绪与风险政策"></a>焦虑情绪与风险政策</h3><p>大部分人没有对心理学进行过学习，所以一些小概率事件如果被过度夸张报道，会导致普通人恐慌。书中说政府在制定风险政策时要考虑这些问题。</p><p>对于组织来说，有两方面工作要做：</p><p>1、加强组织成员的学习，对于一个小组织，还是可以做到大家知识统一，认知一致的；</p><p>2、制定组织政策时，要考虑到普通人的感受，有时越强调无风险，一些人越不安。</p><h2 id="第三部分-过度自信与决策错误"><a href="#第三部分-过度自信与决策错误" class="headerlink" title="第三部分 过度自信与决策错误"></a>第三部分 过度自信与决策错误</h2><p>一些成功学的故事，故事脉络清晰，内容简单，进展顺利。这种故事，人们更容易接受。例如描述谷歌发展，是如何打败竞争对手，在过程中公司高层是如何决策，最终选对方向，让公司最终成功。但实际上商业发展原因很多，其中很重要一点就是运气。可是人经常忽略掉运气。</p><p>人比较容易相信直觉。有些事情说不出原因，但是能够判定。并不是什么事情都能够有直觉。能够具有直觉的场景要满足一定的条件：要环境有规律；经过大量的练习。例如象棋大师经过长时间训练能够培养直觉，看到棋盘中的状态，就能作为一种输入，来产生提示，作出最好判定的输出。一般要经过一万小时的练习才行。但是像股票走势，这种环境是没规律的，影响因素太多，所以谈预测也是不准。为什么有很多人会觉得股票能预测，甚至认为预测的准呢？有时是因为后见之明。在一件事情发生后，人会忘记之前的老想法，认为最开始就是那么想的。</p><p>对于直觉的训练，和机器学习有些类似，其中应该有一些道理是相通的。</p><p>在做决策的时候要养成采纳外部意见的习惯。靠统计数据预测，而不是直觉。因为依靠眼前信息很有限，有很多漏洞。而且人会乐观。当出现问题的时候也会陷入沉默成本。一般可以参照其他类似项目是如何的结果，来进行参考。书中有一个例子，他们编写教材。开始认为2年，最后用了7年。而且之前他们也知道其他人用了很久，但是忽略掉。全世界铁路对乘客数量的预测，在60年里都是不准确的。都没有从以前的数据中挖掘。对于程序员，经常出现的就是排期乐观，最终延期。采纳外部意见可以在排期的时候试试，对比下其他已经完成的项目的工时，来合理评估。</p><h2 id="第四部分-选择与风险"><a href="#第四部分-选择与风险" class="headerlink" title="第四部分 选择与风险"></a>第四部分 选择与风险</h2><p>这部分是作者获得诺贝尔奖的核心——前景理论。</p><p>本质就是人喜欢得到，厌恶风险。对于获得100美金和损失100美金，心理价值是不同的。人在面对盈利，更倾向于稳定，面对损失，更倾向于面对风险。下图的这个S曲线就是描述的这种现象。</p><img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240720163518423" class="" title="img"><p>对于我们日常的决策，一种有效的方法是思考做这件事的本质是什么，到底是为了达到什么目标。而不要被框架所束缚。例如买卖股票的时候，不要考虑过去的成本，只卖盈利的，认为没盈利的后来还会涨。而是要看股票未来的涨势来确定买卖。还有一些沉默成本的事情，要做到及时止损，做到整体收益最大。</p><h2 id="第五部分-两个自我"><a href="#第五部分-两个自我" class="headerlink" title="第五部分 两个自我"></a>第五部分 两个自我</h2><p>经验自我和记忆自我。经验自我就是当前的自我，就是你当时的感受，记忆自我就是在记忆中的自我。</p><p>峰终定律（peak-end rule）：整体的回顾性评级可通过将最糟糕时期和最后时刻的疼痛程度的平均加权而评估出来。</p><p>过程忽视（duration neglect）：过程的持续对所有疼痛的评估没有任何影响。</p><p>一件痛苦的事情，在高峰的痛苦程度，还有离最后结束的时间对人的感受有影响。但是过程中的累计对所有疼痛却没有影响。</p><p>人会比较在意最终结果，例如影视剧的结局，一般都是好结局。对于幸福评估，也是要让记忆自我体验更好一些会更幸福。</p><p>到底是在意当时当刻的感受，还是在意未来回忆的感受，在两个自我中可以做出选择。例如旅行时，到底是要要享受旅行时的乐趣，还是更多时间拍照来留下场景照片。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这本书是一本理论的书，书中的内容比较散，加上翻译的原因。读这本书会要用频繁到系统2，会感觉有些累。但是对于人思考的方式，还有一些做决策的局限都有解释，学习了一些理论，在生活中也很有帮助。例如我们要采纳外部意见，对于一些媒体报道要仔细思考，小数定律等都让我们不要急于作出决策，要用好逻辑和统计学工具来决策。一些平时的工作内容，还是能够用书中的理论来进行优化。</p><p>而且这种书，不同于教授具体方法的书，过一段时间重新读，还会有新的理解和收获，对一些内容的感受也更深。</p><p>确实是一本有效提升决策能力的书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《思考，快与慢》这本书已经读过好几遍，最近为了分享给部门的同学们，又重新读了一遍。又有很多新发现。从前有些地方有遗漏，有些地方理解的也不准确。这次再总结下，否则过一段时间在记忆自我中，可能这本书的内容剩下的就不多了。&lt;/p&gt;
&lt;h2 id=&quot;为什么读这本书&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>多阶Hash算法</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-27T09:08:42.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，会经常用到K-V存储，一般实现的方式有红黑树或者哈希表，在Redis中还用到了跳表。都是通过一个确定的Key值，来查找Key附带的Value属性。本文会介绍一种高效的算法——多阶Hash。</p><h1 id="1原理"><a href="#1原理" class="headerlink" title="1原理"></a>1原理</h1><p>多阶Hash的实现原理很简单，每个Hash桶数组算作一阶，如果有20阶的多阶Hash，那么就是一个二维数组，第一维是Hash桶的编号，第二维是每个Hash桶的每个槽的位置。实际开发中，可以申请一块连续的内存，由一维数组构造出二维数组。内存构造如下图所示，逻辑上是一个阶梯状，实际申请内存，是一块连续的内存结构，用每次层的阶数来标识出不同阶的分界。如下图所示：</p><img src="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/640-1301099.-1301102.-1301103.-1301105." class="" title="img"><p>通常每阶的槽的个数都是质数个，每阶的槽的个数依次递减。由于互质的特性，通常情况下会上面的阶数先被填满，然后再逐步填下面的阶数。在实际使用中，内存使用率可以达到90%以上。</p><p>查找和插入的时间复杂度都是<code>$O(h)$</code>，h是阶数。</p><p><strong>查找操作</strong>：对于一个待查找的Key，查找是否在某一阶有被存储，就用Key模除该阶的槽数M，得到Key在该阶存储的下标，然后判断该下标中存储的元素的key是否和待查找的Key相同。如果该阶没有匹配，再依次查找下一阶，如果找到则返回查找成功。如果遍历所有阶都没找到，则返回未找到。</p><p><strong>插入操作</strong>：先进行查找操作，如果找到已经有存储过该Key，则修改对应位置的元素。如果没有找到该Key，则找到从第1阶到最后一阶中，第一个能存储Key但未分配的位置，把该Key值插入进去。</p><p>与教科书中的开链Hash对比，优缺点如下：</p><h1 id="2优点"><a href="#2优点" class="headerlink" title="2优点"></a>2优点</h1><h2 id="1、查找时间稳定"><a href="#1、查找时间稳定" class="headerlink" title="1、查找时间稳定"></a>1、查找时间稳定</h2><p>查找时间和阶数成正比，虽然不一定最高效，但是是可控的，最坏要多少次查找是能够控制的。如果是接链表解决冲突，冲突太多就退化成链表操作，耗时不可控。</p><h2 id="2、实现简单"><a href="#2、实现简单" class="headerlink" title="2、实现简单"></a>2、实现简单</h2><p>实现完全是数组操作，而且存储内容都是定长。与树形数据结构相比，实现简单很多。</p><h2 id="3、方便序列化"><a href="#3、方便序列化" class="headerlink" title="3、方便序列化"></a>3、方便序列化</h2><p>由于底层是连续内存，能够通过内存迭代遍历全部元素，dump到外部文件。再通过dump文件重新插入实现恢复数据。</p><h2 id="4、鲁棒性强"><a href="#4、鲁棒性强" class="headerlink" title="4、鲁棒性强"></a>4、鲁棒性强</h2><p>互联网业务大都是常驻进程，如果进程重启会导致栈或堆中的内存销毁。可以通过共享内存来达到重启后恢复内存数据。由于多阶Hash底层是数组结构，只需要知道起始位置和元素下标，就能够对内存元素进行操作。进程重启后重新挂载内存即可恢复操作，不需要重建索引。</p><h1 id="3缺点"><a href="#3缺点" class="headerlink" title="3缺点"></a>3缺点</h1><h2 id="1、容量有限"><a href="#1、容量有限" class="headerlink" title="1、容量有限"></a>1、容量有限</h2><p>由于阶数有限，如果最后一阶填满后，会导致Key值没有地方存储。不如链表的扩展性好。</p><p>在实际项目，要做好容量管理和监控。当发现使用率超过70%的时候，就要准备扩容，防止写满。</p><h2 id="2、存储定长"><a href="#2、存储定长" class="headerlink" title="2、存储定长"></a>2、存储定长</h2><p>存储的部分是二维数组的Hash桶的块，是一块定长的内存。如果存储的数据是变长的，就需要把内存块定义为最大Value的长度，会造成内存浪费。常见优化方法是在Hash块中存储一个索引，索引指向另外一块内存链表，变长数据被分别存储在多个内存链表中。一般设置每块内存链表的长度也需要计算。</p><p>多阶Hash适用于读多写少的互联网业务场景，通常是一个进程负责写操作，多个进程负责读操作。多个进程来提高整体的读的并发量，来弥补每次查找都需要<code>$O(h)$</code>的复杂度。</p><p>多阶Hash是一种在生产实践中总结的算法，从学术上看它并不完美。因为会出现元素存不下的情况，而且时间复杂度的常数系数比较大。但是在互联网读多写少的业务场景中，读速度可控，容量管理能监控，这些问题都能够被解决。同时还带来容易实现，鲁棒性强，内存使用率高的优点。</p><p>在实践中得到的这个算法，虽然不是十分优美，但是真的十分实用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在分布式系统中，会经常用到K-V存储，一般实现的方式有红黑树或者哈希表，在Redis中还用到了跳表。都是通过一个确定的Key值，来查找Key附带的Value属性。本文会介绍一种高效的算法——多阶Hash。&lt;/p&gt;
&lt;h1 id=&quot;1原理&quot;&gt;&lt;a href=&quot;#1原理&quot; cl</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>格雷码</title>
    <link href="https://yunpengzhang.github.io/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/"/>
    <id>https://yunpengzhang.github.io/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/</id>
    <published>2019-11-26T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>格雷码（循环二进制单位距离码）是任意两个相邻数的代码只有一位二进制数不同的编码，它与奇偶校验码同属可靠性编码。</p><p>格雷码（Gray code）是由贝尔实验室的Frank Gray在1940年提出，用于在PCM（脉冲编码调变）方法传送讯号时防止出错。</p><p>例如2位的格雷码，排列为00，01，11，10。这个排列中的四个数字，每相邻两个二进制序列都仅有一位不同。可以扩展到n位格雷码，而且格雷码的排列不仅有一种。例如上面2位的格雷码，还可以是00，10，11，01。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现格雷码有两种方法，递归和数学方法。</p><p>递归的方法是：</p><p>1位格雷码只有0，1;</p><p>n位格雷码的序列为k1,k2…kn;</p><p>n+1位格雷码的序列为0k1,0k2…0kn,1kn…1k2,1k1。就是先把前n位的格雷码高位补零，然后把前n位格雷码倒序，再高位补1衔接。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">grayCode</span>(n<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = tmp[i]*<span class="number">2</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tmp.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = tmp[i]*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>数学方法：</p><p>一个二进制数n对应的格雷码G(n),是n与n-1异或的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> n ^ (n &gt;&gt; <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rev_g</span><span class="params">(<span class="type">int</span> g)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; g; g &gt;&gt;= <span class="number">1</span>) n ^= g;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>格雷码由于相邻两个数字只差一位，可以用来降低转态转换出错的概率。</p><p>如果一次状态变换改变3个比特，那么3个比特变化不是原子的，在他们变换的中间态，例如只有2个比特变了的时，此时读取数据会读到错误的状态。但是使用格雷码，每次只变更1个比特。是最小差异。能够避免读错。这是格雷码最初的应用。</p><p>除了容错外，格雷码还能用来实现汉诺塔移动策略。</p><p>具体的方法是：</p><p>假设汉诺塔n个盘子，从小到大编号为1~n。</p><p>三个柱子A、B、C，盘子从A移动到C。</p><p>如果汉诺塔有n个盘子，则n位格雷码，自左至右编号为第n位，第n-1位…第2位，第1位。</p><p>每次格雷码变更的位序号数k，则是第k的盘子移动。除了第一个盘子，其他编号的盘子移动的位置是固定的。</p><p>如果盘子数是偶数，则最小的盘子先移动到B，如果盘子数是奇数，则最小的盘子移动到C。后面按照格雷码变更的位置移动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;格雷码（循环二进制单位距离码）是任意两个相邻数的代码只有一位二进制数不同的编码，它与奇偶校验码同属可靠性编码。&lt;/p&gt;
&lt;p&gt;格雷码（Gra</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>简单高效的排行榜算法——树状数组</title>
    <link href="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</id>
    <published>2019-10-09T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-问题场景"><a href="#0-问题场景" class="headerlink" title="0 问题场景"></a>0 问题场景</h2><p>在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：新的分数排行是多少名，相比之前是前进了，还是后退了，具体前进后退的数值是多少。例如充值排行榜，游戏分排行榜，活跃度排行榜等。由于互联网用户基数大，有些平台参与排行的用户可以达到上千万。但是排行榜最重要的就是时效性，能够让用户越早看到排行更新越好。</p><p>对于庞大的榜单，每次其中一个元素更新，都要重新排序，即使用快速排序，对CPU运算的消耗都是巨大的，很容易造成卡顿。很多互联网业务都采用离线定时更新榜单的方案。例如每天凌晨4点的数据切片，离线排序更新，更新后展示最新的榜单。这种方案在程序性能和用户体验间做了折衷，既保证了每天更新，又不至于实时更新导致运算量太大，算不出来。</p><p>有没有更高的解决方案，可以实时查看用户排行变化呢？一个有序的排行榜，只是一个用户的数据发生变化，就要所有数据重新排序，能只做到部分排序吗？</p><p>对于这两个问题，可以利用一种高级的数据结构「树状数组」，再结合对排行榜的算法来实现。</p><h2 id="1-排行榜实现及优化方案"><a href="#1-排行榜实现及优化方案" class="headerlink" title="1 排行榜实现及优化方案"></a>1 排行榜实现及优化方案</h2><p>我们先梳理下排行榜的通用实现方案，再查看下针对具体的步骤进行优化。<br>一个通用排行榜的实现方案步骤如下：</p><ol start="0"><li>已经有一个排好序的排行榜；</li><li>当用户分数有更新时，保存用户老的排行榜名次和老的分数；</li><li>更新用户新的分数，并更新排行榜，获取新排行名次；</li><li>展示新老名次的差异，结束。</li></ol><p>难点就在第二点，如何更新排行榜。最简单粗暴的想法是，更新排行榜中对应的分数，然后调用快速排序对数组再重新排序一次。快速排序时间复杂度是nlog(n)的，如果有1000万人参与，每次就要进行上亿次的比较。如果每秒有一千个玩家修改分数，要执行千亿次运算。对于排行榜系统的性能消耗是巨大的，做不到实时展示排行数据更新。</p><p>原先已经排好序的数组，只有一个元素的值发生了变化，其他元素的相对顺序是不用更改的。从这个角度来优化程序，能够做到快速实现排序优化。使用树状数组，能够做到修改和查询都是log(n),那么对于1000万人参与的榜单，比较次数最多只需要23次，一千个玩家每秒修改，只需要23000次比较。单进程都可以承受住。而且树状数组底层是构建在数组之上的，数据结构简单，容易持久化，能够方便地保存在共享内存中。当常驻进程重启时能够快速恢复。</p><p>说了树状数组这么多好处，这么适合排行榜业务的实现，下面我们来介绍下树状数组的原理，以及在排行榜业务中使用的方法。</p><h2 id="2-树状数组实现排行榜"><a href="#2-树状数组实现排行榜" class="headerlink" title="2 树状数组实现排行榜"></a>2 树状数组实现排行榜</h2><p>我们利用树状数组来实现排行榜功能，能够在Olog(N)的复杂度实现查询和修改功能。下面先介绍树状数组的原理，再介绍如何利用树状数组来实现排行榜。由于涉及到学习算法，还有应用。本节的两个内容需要对照查看才能理解，建议对下面两小节的内容，先概览熟悉基本概念，再逐渐研究细节。并没有严格的先后顺序之分。</p><h3 id="2-1-树状数组原理"><a href="#2-1-树状数组原理" class="headerlink" title="2.1 树状数组原理"></a>2.1 树状数组原理</h3><p>树状数组（Binary Indexed Tree），又以其发明者命名为Fenwick树。可以在O(logn)时间内得到数组任意前缀和，并能够在O(log(n))时间内支持动态单点的值的修改。空间复杂度是O(n)。</p><p>所有的正整数，都可以表示为2的幂和。 $N&#x3D;\sum_{i&#x3D;1}^m2^{ki} $ ,ki为二进制表示时，为1位的位置。</p><p>例如$34&#x3D;2^1+2^6;12 &#x3D; 2^2+2^3$;</p><img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640.png" class="" title="图片"><p>我们设一个整数数组元素个数为N，数组名为A，包含元素为$A_{j}(1&lt;&#x3D;j&lt;&#x3D;N)$</p><p>对于一个整数i，lowbit(i)表示i的二进制最后一个位置1，所代表的值。（例如lowbit（12）&#x3D; 4，lowbit（34）&#x3D;2）</p><p>构造树状数组 $BIT_{i} &#x3D; \sum_{j&#x3D;i-lowbit(i)+1}^{i}A_{j}$</p><p><code>BIT[i]=A[i-lowbit(i)+1] + A[i-lowbit(i)+2] + ... + A[i]</code></p><p>所表示的数学意义为，下标为i的树状数组元素，为原数组A[i]往前lowbit(i)个元素的和（包括A[i])。</p><p>对于树状数组元素BIT[i]，可以画一棵树表示，树中的父节点表示的区间和，覆盖子节点表示的区间和。</p><p>下图为i&#x3D;8时画出的树。</p><img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640-20240720163708514.png" class="" title="图片"><p>树状数组是在数组上建立的一种树形关系结构。</p><p>以上图为例，A数组是原始存储数据的数组，有8个元素。C数组是按照每个下标覆盖2次幂范围得到的新的子序列和的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BIT1 = A1 （1的二进制表示为1，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT2 = A1 + A2（2的二进制表示为10，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT3 = A3（3的二进制表示为11，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT4 = A1 + A2 + A3 + A4（4的二进制表示为100，有2个0，覆盖4个元素）</span><br><span class="line"></span><br><span class="line">BIT5 = A5（5的二进制表示为101，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT6 = A5 + A6（6的二进制表示为110，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT7 = A7（7的二进制表示为111，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8（8的二进制表示为1000，有3个0，覆盖8个元素）</span><br></pre></td></tr></table></figure><p>有了树状数组BIT[i]，我们就可以实现<strong>求原数组A[i]的前缀和</strong>，还有<strong>A[i]中单个元素修改时快速更新BIT[i]数组的功能</strong>。</p><p>一、求原数组A的前缀和</p><p>假设求原数组A的前i个元素的和Sum[i]，对于整数区间[1,i],可以表示为两个区间[1, i-lowbit(i)],[1-lowbit(i), i]。</p><p>如果设j&#x3D;i-lowbit(i)，那么j&lt;&#x3D;i并且Sum[0] &#x3D; 0，则Sum[i] &#x3D; Sum[j] + BIT[i]；之后再逐步求解Sum[j]，直到递推到Sum[0] &#x3D; 0，便计算出前缀和Sum[i]。</p><p>二、原数组某个元素A[i]修改，同步修改树状数组BIT</p><p>当某个元素A[i]修改时，所有包含A[i]的树状数组元素BIT[j]都要进行相应的修改。</p><p>对于A[i]，BIT[i]肯定包含A[i]的和。再根据上面的树形结构，</p><p>$BIT_{i_{k+1}} &#x3D; BIT_{i_{k}} + lowbit(i_{k}) 其中 (i_{0}&#x3D;i, i_{k+1}&lt;&#x3D;N)$   </p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>根据上一小节的分析，可以用代码实现树状数组。<br>对于求lowbit(n),可以用n&amp;(n^(n-1))得到，由于在C++中用补码表示负数，可以写为n&amp;(-n)。用函数封装为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求数组A的前i项和为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//求前i项和 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        s+=BIT[i]; </span><br><span class="line">        i-=lowbit(i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改原数组A[i]元素，增加val值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n) </span><br><span class="line">    &#123; </span><br><span class="line">        BIT[i]+=val; </span><br><span class="line">        i+=lowbit(i);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-树状数组优化排行榜"><a href="#2-3-树状数组优化排行榜" class="headerlink" title="2.3 树状数组优化排行榜"></a>2.3 树状数组优化排行榜</h3><p>如何使用树状数组来实现排行榜的需求呢？要经过一些转化。</p><p>我们把要排行的分数划定一个区间范围。假设分数都是整数，最大值MAX_SCORE为1,000,000分。</p><p>则原始数组A[i]表示具有分数为i的值的用户数量，然后求出BIT[i]数组。假设一个人的分数为j，则排名为BIT[MAX_SCORE]-BIT[j-1]。</p><p>利用上小节的代码很容易就实现了。</p><p>排行榜封装的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> BIT[MAX_SCORE + <span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始时所有分数的人数都是0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uid, newScore, oldScore;</span><br><span class="line">    GetUserInfoReq(&amp;uid, &amp;newScore, &amp;oldScore);<span class="comment">//假设收到请求，获得uid用户的最新分数为newscore,上次更新分数为oldscore;</span></span><br><span class="line">    <span class="type">int</span> oldRank = sum(MAX_SCORE)-sum(oldScore)+<span class="number">1</span>;<span class="comment">//查询旧排名</span></span><br><span class="line">    <span class="comment">//更新为新排名</span></span><br><span class="line">add(oldScore, <span class="number">-1</span>);<span class="comment">//先给旧分数的人数减一</span></span><br><span class="line">add(newScore,  <span class="number">1</span>);<span class="comment">//再给新分数的人数加一</span></span><br><span class="line"><span class="type">int</span> newRank = sum(MAX_SCORE)-sum(newScore)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回用户新排名newRank，和老排名oldRank供前端展示</span></span><br><span class="line">    SetUserInfoRsp(uid, newScore, newRank, oldScore, oldRank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把用户的分数数据存储在用户资料中，排行榜模块只存储树状数组用来排名。最开始初始化时，可以遍历所有用户资料，获取每个用户的score，然后调用add(score, 1)完成全部初始化。之后用上面的代码，在每次分数有更新的时候调用获取排名变化。</p><p>核心代码只有30几行，而且由于是存储在数组中，一块连续的内存，可以把树状数组放到共享内存中。即使进程重启，也能够马上恢复服务。</p><p>使用树状数组有前提条件：</p><p>1、就是不能存储分数为0的玩家的排名；</p><p>2、分数要都是整数；</p><p>3、要有上限，最大不能超过MAX_SCORE范围。</p><p>虽然有诸多限制，但都能通过业务逻辑处理。如果分数有小数，可以乘以相应的倍数，转换成整数。例如充值1.01元，可以把单位转换成分来存储101分。上限可以根据业务逻辑调整，即使正整数的最大表示2^32，log(n)也只需要32次处理，远远小于O(n)的处理。</p><p>如果要突破限制，需要在业务层面和实现逻辑上再做些转换，一般都可以很好解决。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>对于排行榜需求，通过树状数组，能够实现实时更新和展示实时变化。排行榜实时更新的瓶颈是单值修改，整体排序。树状数组能够做到单值修改，部分更新，优化掉了排行榜瓶颈。</p><p>在实际开发中，遇到问题，要先梳理问题的步骤，找到瓶颈。针对瓶颈进行学习研究，对于高级数据结构要有所了解，在实际开发中，合理运用，能够达到简化开发，提升项目稳定和效率好处。同时在使用的过程中注意边界条件，让一些产品设计在边界条件内，能够达到产品特性用户满意和程序实现复杂度降低的双赢局面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-问题场景&quot;&gt;&lt;a href=&quot;#0-问题场景&quot; class=&quot;headerlink&quot; title=&quot;0 问题场景&quot;&gt;&lt;/a&gt;0 问题场景&lt;/h2&gt;&lt;p&gt;在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>随机数在互联网业务中的应用</title>
    <link href="https://yunpengzhang.github.io/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://yunpengzhang.github.io/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2019-09-27T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随机数在互联网业务中的应用"><a href="#随机数在互联网业务中的应用" class="headerlink" title="随机数在互联网业务中的应用"></a>随机数在互联网业务中的应用</h1><p>在互联网业务中，随机数被用到的场景很广泛。通常大家也认为使用随机数很简单，直接调用现成的函数库即可实现功能。但是想用好随机数还是有些难度的。需要熟悉其中的原理。本文会介绍一些在互联网业务中使用随机的方法。</p><p>在信息学中，随机的定义如下：</p><blockquote><p>随机性：不存在统计学偏差，是完全杂乱的数列</p><p>不可预测性：不能从过去的数列推测出下一个出现的数</p><p>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列</p></blockquote><p>随机数可能在统计上呈现某种规律。</p><p>在工程上，用到随机也主要是用到两个特性：</p><ol><li>不可预测性</li><li>均匀获取数字。（在大量随机统计时，每个数出现次数的期望相同）</li></ol><p>在安全相关的场景，用到的是不可预测性。例如生成密钥，生成验证码等场景，让黑客不能从中找到生成的规律。</p><p>在抽奖实现、负载均衡等场景，主要用到随机数在统计时，每个随机数字出现的次数的期望都很接近，让结果是公平的。</p><h2 id="0-随机数的生成方法"><a href="#0-随机数的生成方法" class="headerlink" title="0 随机数的生成方法"></a>0 随机数的生成方法</h2><p>在计算机中，主要生成随机数有两种方法，线性同余算法，硬件设备随机数生成器。</p><h3 id="一、线性同余算法"><a href="#一、线性同余算法" class="headerlink" title="一、线性同余算法"></a>一、线性同余算法</h3><p>在C函数库中的<code>rand()</code>函数，用的就是线性同余算法，类似的实现代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myrand</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="type">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mysrand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>注：以上只是为了简单描述Glibc库实现的方法，实际代码不是这样写的。</code></p><p>利用<code>srand</code>函数设置初始随机种子，在每次需要随机数的时候调用<code>rand</code>生成随机数。</p><p>线性同余算法的特点是：只要种子相同，即使在两台不同的机器上，都能够产生相同的随机序列。利用这个特性，我们可以在应用层做很多事。</p><p>例如：</p><p>时间换空间：只要保存一个种子，就能够通过计算得到一个序列。可以利用这个序列来实现功能。</p><p>还原操作：在客户端根据随机序列构建地图，然后在服务器校验，只需要同步种子，就能实现相同场景。</p><p>线性同余算法计算速度快，实现简单，但是是<strong>伪随机</strong>，知道种子后能够预测随机序列，而且随机序列经过一段时间后会循环重复。</p><p>所以在安全使用的场景中，不会使用线性同余算法。</p><h3 id="二、Linux系统的-dev-random"><a href="#二、Linux系统的-dev-random" class="headerlink" title="二、Linux系统的&#x2F;dev&#x2F;random"></a>二、Linux系统的&#x2F;dev&#x2F;random</h3><p>&#x2F;dev&#x2F;random在类UNIX系统中是一个特殊的设备文件，可以用作随机数发生器或伪随机数发生器。Linux内核允许程序访问来自设备驱动程序或其它来源的背景噪声。</p><p>发生器有一个容纳噪声数据的熵池，在读取时，&#x2F;dev&#x2F;random设备会返回小于熵池噪声总数的随机字节。&#x2F;dev&#x2F;random可生成高随机性的公钥或一次性密码本。</p><p>若熵池空了，对&#x2F;dev&#x2F;random的读操作将会被阻塞，直到收集到了足够的环境噪声为止。这样的设计使得&#x2F;dev&#x2F;random是真正的随机数发生器，提供了最大可能的随机数据熵，建议在需要生成高强度的密钥时使用。</p><p>为了解决阻塞的问题，还提供了一个设备&#x2F;dev&#x2F;urandom，即非阻塞版本。它会重复使用熵池中的数据以产生伪随机数据，输出的熵可能小于&#x2F;dev&#x2F;random的。它可以作为生成较低强度密码的伪随机数生成器。</p><p><strong>安全使用随机数是比较专业的场景，一般都是使用特定的库或算法，直接调用即可，不要自己造算法。</strong></p><h2 id="1-误用随机的场景"><a href="#1-误用随机的场景" class="headerlink" title="1. 误用随机的场景"></a>1. 误用随机的场景</h2><p>在日常的开发场景中，遇到过几种误用随机的场景，相信很多人还会掉到这些坑里。这里提出来供大家参考。</p><h3 id="1-1-多次设置随机种子"><a href="#1-1-多次设置随机种子" class="headerlink" title="1.1 多次设置随机种子"></a>1.1 多次设置随机种子</h3><p>线性同余算法，为了让每次程序启动时生成的随机数都是不同的，可以利用<code>srand()</code>函数设置不同的随机种子。一般是设置种子为当前时间，或者进程的进程号等。然后再调用<code>rand()</code>来生成随机数。**<code>srand()</code>只需要开始调用一次，<code>rand()</code>是每次需要随机数的时候调用一次。**</p><p>但是有的错误用法，会在常驻进程中使用随机数的时候，把<code>srand</code>和<code>rand</code>配套调用。起不到随机的效果，每一秒钟的随机数都是一样的，而且只取到的线性同余生成的第一个随机数，整体的均匀性也达不到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="literal">NULL</span>));<span class="comment">//正确使用的方式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//srand(time(NULL));//错误使用的方式,同一秒生成的r值都相同。</span></span><br><span class="line">    <span class="type">int</span> r = rand();</span><br><span class="line">    <span class="comment">//使用随机数的逻辑</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用上面错误的方式，在一个常驻进程中，会让每秒钟生成的随机数都相同。假如这个随机数是用来给后端选择路由的，会造成同一秒钟的流量都访问到同一个节点，起不到负载均衡的作用。在大型互联网服务中，一秒钟的流量也是巨大的，可能会影响单一节点的服务质量。</p><h3 id="1-2-生成范围随机数直接取模"><a href="#1-2-生成范围随机数直接取模" class="headerlink" title="1.2 生成范围随机数直接取模"></a>1.2 生成范围随机数直接取模</h3><p>假设一个随机函数rand21()，每次生成的随机数范围是[0, 21)，那么现在要生成[0, 10)的随机数，如何生成。</p><p>常见的错误实现方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rand10 = rand21() % 10;</span><br></pre></td></tr></table></figure><p>虽然这种方式得到的数字结果是在[0, 10)之间的。但这种实现方式是错的，因为生成的[0,10)区间的数字不均匀。生成0这两个数字的概率要超过其他9个数字的概率。</p><p>rand21产生的[0, 10), [10, 20)取模对应[0,10)是等概率的，会多出来[20, 21)这个区间。直接取模会让结果不均匀。</p><p>正确的做法应该是截断这段数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int r = 0;</span><br><span class="line">int rand10 = 0;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    r = rand21();</span><br><span class="line">    if(r&gt;=20)</span><br><span class="line">        continue;</span><br><span class="line">    else</span><br><span class="line">        rand10 = r % 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码理论上会产生死循环，可能一直生成20这个随机数。在实际工程中可以做个上报，发现超过一定的数值次数，就主动跳出循环，返回失败或设置个默认值。但实际这种概率非常小。</p><p><strong>从一种随机数范围的发生器，映射到另一个随机数范围的发生器过程中，不要简单的取模，可能会造成结果不是随机的。</strong></p><blockquote><p>注：除了截断操作，还有拼接的方法，拼出要随机新范围的倍数，再取模。本质和截断一样。</p></blockquote><h3 id="1-3-一定要用随机吗"><a href="#1-3-一定要用随机吗" class="headerlink" title="1.3 一定要用随机吗"></a>1.3 一定要用随机吗</h3><p>有时，我们用随机的场景，不是真的为了随机，而是为了让结果更分散。这种场景用随机是一种实现方式。需要了解业务的目的，挑选出适合的实现方式，让方案更简单。</p><p>例如路由选择，只要保证节点分布是均匀的，是否可预测并不是必要条件。只要整体的统计分布是均匀即可。存储一个计数器，简单的轮询也是实现均匀分发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机实现路由</span></span><br><span class="line"><span class="comment">//getRouteNodeId返回后端要路由到的Node节点的id，id的范围是[0, nodeCount)</span></span><br><span class="line"><span class="comment">//nodeCount后端节点的总数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRouteNodeId</span><span class="params">(<span class="type">int</span> nodeCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand()%nodeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询实现</span></span><br><span class="line"><span class="comment">//getRouteNodeId返回后端要路由到的Node节点的id，id的范围是[0, nodeCount)</span></span><br><span class="line"><span class="comment">//nodeCount后端节点的总数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRouteNodeId</span><span class="params">(<span class="type">int</span> nodeCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> nextNodeId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (nextNodeId++)%nodeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些场景，用随机反而麻烦。</p><p>例如每100万号码存储在一个服务中，对前1000万个号码进行发送push消息操作。如果直接按顺序遍历这1000万个号码，会对这10个存储服务分别造成查询压力。导致修改操作冷热不均。一种方式是每次从号码区间中随机选择一个号码处理，但是要记录号码是否被选择过的状态，需要额外的存储空间。</p><p>还一种简单的方法是先按照号段轮询，再按照号码轮询，可以达到不需要存储的实现方式。</p><p>伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> group = <span class="number">0</span>; group &lt; <span class="number">10</span>; ++group)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> uid = group * <span class="number">10000</span> + i;</span><br><span class="line"><span class="comment">//下发消息逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是用到的是映射，让结果均匀，虽然随机也能达到这个目的。</p><h2 id="2-项目中用到的随机场景"><a href="#2-项目中用到的随机场景" class="headerlink" title="2. 项目中用到的随机场景"></a>2. 项目中用到的随机场景</h2><p>在项目中，用好随机可以帮我们提高用户体验，还可以帮我们用时间换空间。</p><h3 id="2-1-让用户体验更好的随机"><a href="#2-1-让用户体验更好的随机" class="headerlink" title="2.1 让用户体验更好的随机"></a>2.1 让用户体验更好的随机</h3><p>有时虽然程序员懂随机，但是和用户理解的随机不一样，这时程序员要适应用户的感观。</p><h4 id="2-1-1-歌曲随机播放"><a href="#2-1-1-歌曲随机播放" class="headerlink" title="2.1.1 歌曲随机播放"></a>2.1.1 歌曲随机播放</h4><p>在播放器中，随机播放是一种播放模式。如果简单的调用随机函数，会出现用户接受不了的情况。可能下一首播放的歌曲和当前歌曲是一样的，可能某个子序列会反复播放。</p><p>例如有ABCD四首歌。可能会出现AABB、ABABABAB这样的顺序播放。虽然在数学上是达到了随机，但是用户体验不佳。</p><p>播放器的「随机播放」实际上是一种打乱播放的意思，可以用的shuffle洗牌算法（可以使用<code>Fisher–Yates shuffle</code>算法）。把原本有序的序列，变成无需无规则的序列，就像洗扑克牌一样。</p><p>以下为<code>Fisher–Yates shuffle</code>算法的伪代码，也用到了随机函数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices <span class="number">0.</span>.n-<span class="number">1</span>):</span><br><span class="line">for i from n−<span class="number">1</span> downto <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">     j ← random <span class="keyword">integer</span> such that <span class="number">0</span> ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]-- To shuffle an array a of n elements (indices <span class="number">0.</span>.n-<span class="number">1</span>):</span><br><span class="line">for i from n−<span class="number">1</span> downto <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">     j ← random <span class="keyword">integer</span> such that <span class="number">0</span> ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure><p>有时还需要考虑专辑、歌手、曲风等因素，可以多一些区分的维度，在每个维度再加上一些随机。可能有些歌曲用户比较爱听，随机到的权重也要高一点。</p><p>总之，歌曲的随机播放要根据用户对播放器的预期，来干涉生成序列，不能简单粗暴地直接使用随机来生成。</p><h4 id="2-1-2-游戏抽奖"><a href="#2-1-2-游戏抽奖" class="headerlink" title="2.1.2 游戏抽奖"></a>2.1.2 游戏抽奖</h4><p><strong>十连抽</strong></p><p>在游戏中，为了激励玩家批量购买，会有「10连抽必中稀有物品」的玩法。用户如果一次性消耗10次中奖机会，就会至少中一次稀有物品。</p><p>由于已经承诺给用户必中，所以要干预连续10次抽中的情况，如果出现10次都没中大奖，就会给用户替换一个稀有物品。</p><p>对于10连抽的场景，要人工干预最后的奖励序列。不能一味的随机。</p><p><strong>普通抽奖</strong></p><p>在一些国家或地区，会要求软件开发者给出中奖概率。当玩家知道中奖概率后，针对玩家的抽奖就不能完全用随机函数，小于概率值就中，不小于就不中的方法。因为这种方法会让玩家体验不好，以为官方在作弊。</p><p>例如：一个装备，抽奖中奖的概率是10%。以普通玩家的想法，抽10次就会中一次，如果抽20次才中一次，玩家也勉强接受。但是如果抽100次，一次都不中，大多数玩家都接受不了的，一方面会质疑游戏的公平性，也会因为体验不好而离开。另外一边与运气不好的玩家相反，还有些运气好的玩家，可能抽10次，就中了5次，消耗了过多的奖品。</p><p>在一些大DAU的游戏中，运气好的玩家和运气不好的玩家，出现的概率还挺高的。</p><p>运气不好的玩家。每次抽中奖概率10%，抽100次都不中的概率是$(1-10%)^{100}&#x3D;2.656*10^{-5}$大概万分之二。如果一天有1万个玩家抽了100次奖，平均有2个人是100次都不中。</p><p>运气好的玩家。10%中奖，抽10次中5次的概率是$C(10, 5) * 10%^5*90%^5 &#x3D; ‭0.0014880348‬$，大概是万分之15左右，是运气不好的玩家概率的7、8倍。</p><p>为了让玩家感观上是随机并且公平，也采用洗牌算法，对每个玩家生成一个奖品等级的中奖序列。把序列打乱，按次序给玩家，每次根据奖品等级生成该等级的奖品发给玩家。</p><h4 id="2-1-3-游戏武器暴击"><a href="#2-1-3-游戏武器暴击" class="headerlink" title="2.1.3 游戏武器暴击"></a>2.1.3 游戏武器暴击</h4><p>在游戏中的武器装备也涉及到概率，例如一把屠龙刀，暴击概率提升到30%。玩家的感觉也是在10刀里，大概率会有3刀是暴击的，在100刀里要有30几刀的暴击。</p><p>暴击和抽奖遇到的问题类似，都是玩家对概率的理解和程序员理解不一致。因为按照独立事件的概率，可以连续100次都不暴击，也可以连续3-4刀每次都暴击。连续不暴击会伤害持有武器玩家的体验，连续暴击会伤害和持有武器对战玩家的体验。</p><p>暴击在游戏中的不确定性会增加游戏的乐趣性。和抽奖不同，偶尔多一两次，对于游戏来说玩家也是可以接受的，不会像抽奖如果密集中奖会影响体验。在暴击的随机，可以参考暴雪的随机公式（PRD）。</p><p>$$P(N) &#x3D; C × N$$</p><p>P(N) 表示在第N次攻击之后某个动作发生得概率，N表示第N次修正概率后得攻击次数（最小值为1），C表示暴击发生的初始概率以及每次攻击之后概率的增量，是个简单地线性关系。当N足够多的时候，P（N）总会趋向于1。</p><p>在编写程序时，先设置好C，通过C来增加下一次效果触发的几率。C会作为初始概率，比效果说明中的概率要低。当效果没有触发时，会不停地积累N，让P(N)逐渐增加接近100%。一旦效果触发了效果，计数器N就会重置。</p><p>例如一把武器有25%暴击，把初始概率C设置为8.5%。那么第一次攻击，他实际上只有大约8.5%几率触发暴击，随后每一次失败的触发会增加大约8.5%触发几率，于是到了第二次攻击，几率就变成大约17%，第三次大约25.5%，以此类推，在一次暴击触发后，下一次攻击的触发几率又会重置到大约8.5%，那么经过一段时间之后，暴击几率的平均值就会接近25%。</p><p>采用PRD随机公式保证在有限次数能够实现暴击，并且整体期望和独立事件的期望接近。</p><h3 id="2-2-时间换空间"><a href="#2-2-时间换空间" class="headerlink" title="2.2 时间换空间"></a>2.2 时间换空间</h3><h4 id="2-2-1-游戏作弊校验"><a href="#2-2-1-游戏作弊校验" class="headerlink" title="2.2.1 游戏作弊校验"></a>2.2.1 游戏作弊校验</h4><p>在一些消除类的单机游戏中，玩家游戏在客户端本机进行，结束后上传分数给服务器。服务器会根据玩家的分数进行排行，并给予一些奖励。为了让玩家能够有良好的体验，在游戏过程中，所有操作都在本地进行。为了防止作弊，在玩家上传分数后进行检测。</p><p>如何做到校验玩家游戏是否作弊呢？方法也比较简单，把游戏数据上传，在服务器重放玩家操作，根据行为判断是否作弊。但是这里有一个难点，游戏开始下发地图的时候，如果把游戏中所有的随机事件，例如机关的摆放，NPC的随机施法都生成好下发到客户端，会消耗很多流量，影响启动速度。</p><p>线性同余算法，不同机器相同种子，可以产生相同序列的特性，很好地支持了这个场景。在游戏开始时，通过加密通道，把随机种子下发给客户端，客户端按照随机种子生成地图和操作。结束游戏，客户端上传用户操作，服务器收到操作序列后，重新生成地图和地图上的机关操作，然后快速执行玩家操作。最终校验两种结果是否一致。通过种子的传递，只要算法一致，就能够重放，大大降低了带宽和同步数据的复杂度。</p><h4 id="2-2-2-节约存储成本"><a href="#2-2-2-节约存储成本" class="headerlink" title="2.2.2 节约存储成本"></a>2.2.2 节约存储成本</h4><p>在互联网早期的一些安全充值的场景中，为了验证充值卡的归属。用户充值时，需要输入充值卡背面的密保卡片中的一些数字，校验卡片归属。因为充值卡后面的密保矩阵是被覆盖的，如果刮开会影响销售，只有购买的人才能看到。一般是一个10*10的数字矩阵。</p><p>最直接设计方法是，可以给每个充值卡生成一个随机的100个数字序列，然后每次针对用户的输入进行匹配。如果矩阵每个数字用两个字节存储，1张卡要耗费200个字节。如果发行了1亿张卡，就要20G的存储空间。</p><p>但是如果每张卡只存一个种子值，当用户来校验时，根据种子生成100个数字来校验，效果是一样的。假设一个种子4个字节，1亿张卡只需要400M存储就可以了。可以都load到缓存中加快速度。</p><p>利用随机空间换时间，本质是存储元数据，利用算法的生成规律，保证能反复重放序列。可以达到减少同步信息，降低存储量的效果。虽然现在带宽和存储的成本越来越低，但是掌握了这种方法，在一些特殊场景中能够提供奇妙的解决方案。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>随机在互联网应用的十分广泛，我们根据场景采用不同的使用方式。</p><p>在安全相关的专业算法领域，用已有的算法和工具，不要去造轮子。在Linux系统中使用&#x2F;dev&#x2F;random读取随机数。</p><p>在应用层，使用伪随机函数例如线性同余算法，快速生成随机数，满足大多数生成随机数的需求。</p><p>在游戏、歌曲等更高层应用的领域，用户对随机的理解和数学上的随机不太一致。要区分用户是要整体分布更均匀，还是让结果充满随机性增加乐趣。根据场景适时调整，修改随机数的分布，而不是默认采用独立事件生成随机数，往往能够达到更好的效果。</p><p>算法是固定的，在实现业务的时候，要从实际角度出发，选择最适合的实现方式，来满足业务需求。做到活学活用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;随机数在互联网业务中的应用&quot;&gt;&lt;a href=&quot;#随机数在互联网业务中的应用&quot; class=&quot;headerlink&quot; title=&quot;随机数在互联网业务中的应用&quot;&gt;&lt;/a&gt;随机数在互联网业务中的应用&lt;/h1&gt;&lt;p&gt;在互联网业务中，随机数被用到的场景很广泛。通常大家也</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员，选择和努力哪个重要？</title>
    <link href="https://yunpengzhang.github.io/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E9%80%89%E6%8B%A9%E5%92%8C%E5%8A%AA%E5%8A%9B%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F/"/>
    <id>https://yunpengzhang.github.io/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E9%80%89%E6%8B%A9%E5%92%8C%E5%8A%AA%E5%8A%9B%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F/</id>
    <published>2019-05-25T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>从年初到现在面试了近百人。面试中发现，有的同学还应该再努力些再换工作；而有的同学已经很努力了，做的很好，但没有选择好，去了不适合自己的公司。</p><p>能力好，又选择了好公司好岗位的，还真是不多。</p><p>如何才能选到好公司好岗位呢？到底选择和努力哪个更重要呢？</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>这里说的选择，是说程序员如何选择一个好工作。</p><p>要做到的是选择好行业、公司、和岗位，三者层层递进。</p><h3 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h3><p>选行业就是要选择大环境。就像90年代的通信行业，2000年之后的互联网行业，金融行业。这些行业的发展速度快，短期内能够聚集大量的资金。所在行业的公司市值要比其他行业的高。当然这些行业的从业者待遇也会更好。</p><p>行业决定了整体发展的大势，要顺势而为。如果行业的发展已经到了天花板，或稳定期，那么同样的努力，效果也不如发展期的行业。</p><p>有些行业即使现在待遇高，但是未来如何，是否适合程序员发展，也要综合考量。</p><p>例如有些房地产公司也有专门的研发岗位，是否在这个行业一直做软件开发有发展，要综合考量下。</p><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>即使是相同的行业，其中不同的公司之间，差别也比较大。选公司也要选有前景，靠谱的公司。</p><p>大多数人容易犯的一个错误，只看薪资。可能只差几千块，就选择了工资高的公司。</p><p>不是不看薪资，而是不能只看薪资，要从多维度查看。</p><p>公司是否在扩张期，是否是一个有前景的公司。未来是否会成为行业龙头。</p><p>公司的企业文化和自己是否吻合。</p><p>公司环境怎么样，公司工作几年后，是否可以实现自己的目标。</p><p>看人，公司的人是否靠谱。和一群靠谱的人工作，结果肯定不会差。</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>两个公司差不多，待遇差不多，去哪家公司呢？</p><p>不要只看做的产品，或者部门的重要性。要看你去的位置。是否有牛人能够带你等。去了会在什么位置，是否有足够的空间供你发挥。</p><p>就像宰相蔡京家里的厨娘，什么菜都不用做，只需要剥葱。</p><p>职业生涯是不断发展的，要从长远看，不要只看眼前，要设想从未来往回看。再过些年，你的技能实力会提高吗，会变得更值钱吗？</p><p>上面说的都是选择参考的一些纬度，但本质还是要自身有明确的目标，知道你想要什么？否则你不知道什么是好，什么是不好。好这个概念是人主观的想象的，客观不存在的，别人认为好的不一定适合你。是否好，只有你自己知道。</p><p>需要独立思考，有明确目标。但对于大多数人，都是未曾有过的能力。</p><p>要做好选择固然重要，但是不能一直在选择。选的时候要仔细斟酌，但是选好后要沉下心来，专心做事，修炼自己。就像找老婆一样，谈女朋友时要慎重，可以多选选，结婚后就老老实实过日子吧。</p><h2 id="努力"><a href="#努力" class="headerlink" title="努力"></a>努力</h2><p>如何让自己更值钱？努力学习！</p><p>对于程序员来说，专业技能的提高是必须要做到的。同样的技术，要知道原理，学习的更深刻。而且行业迭代快，要不停地学习，接收新知识。</p><p>要掌握好安身立命的技能，当机会来的时候才能抓住。而不会因为自身的能力拖后腿而后悔。</p><p>普通人之间智商差不多，更多比的是努力，谁花的时间多，谁更勤奋，谁就会更强。</p><p>除了专业技能努力提高外，还需要提高「软技能」。专业技能是解决具体的问题。但是随着层次越高，问题越模糊，解决的方法也越来越多。就要对问题分析与解决、决策能力、心理学等有所训练。</p><p>不管学什么，都要投入时间，精力，经过不断地修炼，才能卓有成效。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>选择和努力要有个平衡。</p><p>重选择轻努力：频繁跳槽，到哪都「怀才不遇」；</p><p>重努力轻选择：交给「运气」，没有把控。</p><p>努力是基础，是自我能够控制的。特别在东亚这几个国家，从来不缺努力的人。</p><p>努力的过程会比较苦，要有坚强的毅力，有时要克服「人性」。长远看对自身是有好处的，需要延迟满足的准备。</p><p>选择充满了不确定性。即使科学决策，也不一定是最优决策。因为选择的时候还受到掌握信息量是否足够，还有选择后，事物的发展还受到其他因素的影响，都是不可控的。但是能力强的人机会更广，更好。选择后结果的稳定性会也更好。例如：读书成绩好的人不一定最有钱，不一定都有钱，但是读书好的人的平均收入肯定比读书差的平均收入高，受到运气的影响波动低。</p><p>努力是前提，只靠运气，概率太低。选择要掌握足够的信息，并且要科学决策，还要加一点点运气。作为人来说，做好自己能控制的，控制不了的，怨天尤人也没用。能力越强，运气也随之变好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从年初到现在面试了近百人。面试中发现，有的同学还应该再努力些再换工作；而有的同学已经很努力了，做的很好，但没有选择好，去了不适合自己的公司。&lt;/p&gt;
&lt;p&gt;能力好，又选择了好公司好岗位的，还真是不多。&lt;/p&gt;
&lt;p&gt;如何才能选到好公司好岗位呢？到底选择和努力哪个更重要呢？&lt;</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何当好面试者</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E8%80%85/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E8%80%85/</id>
    <published>2019-05-04T12:57:18.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何当好面试者"><a href="#如何当好面试者" class="headerlink" title="如何当好面试者"></a>如何当好面试者</h1><p>经过对一些面试者的观察，如果有些方面做的更好一点，会大大增加面试的效率，提升通过面试的概率。希望即将参加面试的同学，能够从以下这些点得到帮助。</p><h2 id="明确的目标"><a href="#明确的目标" class="headerlink" title="明确的目标"></a>明确的目标</h2><p>在参加面试之前，要先思考好面试的目的。为什么去面试？即将参加的这场面试，如果通过之后，是否满足你的要求。 如果确定要去参加，要对面试的公司，面试的岗位做些功课。知己知彼百战不殆。了解多一分，过的可能性就大一分。</p><h2 id="准备简历"><a href="#准备简历" class="headerlink" title="准备简历"></a>准备简历</h2><p>简历要包括以下这些内容，而且顺序也依次排列：</p><ol><li>姓名，联系方式，面试职位</li><li>学习经历和学习过程中获奖情况</li><li>工作经历和突出业绩</li><li>技术擅长点</li><li>其他</li></ol><p>宗旨是，让面试官或简历筛选者，能够在几秒钟，就能发掘你，看到你的重点信息。简历最好控制在一页纸，突出重点内容。 内容短，不代表内容少。要精心准备，对自己的长处短板有充分的了解，对过往的工作有总结。把重要的内容，简洁地写上去。 无关主题就不要贴了，如果面试程序员，是否会做饭关系不大，还浪费两行字的空间。</p><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>看书：一般面试都会有笔试，考一些专业知识。如果准备面试，要做些复习，对一些基础知识和概念要充分了解。 即使是从前做的项目，也要准备下，对细节，数据做些总结。在被问到时能够对答如流。如果吞吞吐吐，会让面试官怀疑真实性。 做好面试公司的功课，对公司的业务，规模有所了解。在互联网上，都是公开信息。</p><h2 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h2><p>面试过程中，要做好及时反馈，让面试过程顺利进行。 如果面试官出题，要先复述下对题目的理解，防止读错题意。在做题的过程中，先说思路，再写代码，或进入下一步解题。如果思路有错误，面试官会给予提示，节约面试时间，能够让面试官做到尽量全面考察。 如果题目没思路，尽早说想不起来，或者过一会再解答。不要一直卡在那里，白白浪费掉面试时间。也可以和面试官说自己擅长哪些方面，在简历里要交代清楚。有些面试者什么都写精通，但问又答不好。要让面试官不停地探测擅长哪些知识，如果探测不对，最后面试者很难通过。 面试者要能引导面试官，让面试官知道自己擅长哪些。在介绍项目的时候，也突出重点，做过的项目哪里做的最好，克服了哪些困难。 总之，要在短短的一个小时里，展示你的才能，让面试官知道你是要找的人才。 即使面试没通过，也要总结，为后面的面试打基础积累经验，也可以过半年之后，再重新回来面试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>功夫在平时，面试的结果和平时的努力分不开。在平时要多刨根问底，探究问题的根本原因。多总结，定期总结工作要点内容。对基础知识要不断学习和强化，就像手艺人一样，这是安身立命的技能，不能丢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何当好面试者&quot;&gt;&lt;a href=&quot;#如何当好面试者&quot; class=&quot;headerlink&quot; title=&quot;如何当好面试者&quot;&gt;&lt;/a&gt;如何当好面试者&lt;/h1&gt;&lt;p&gt;经过对一些面试者的观察，如果有些方面做的更好一点，会大大增加面试的效率，提升通过面试的概率。希望即将</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何当好面试官</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E5%AE%98/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E5%AE%98/</id>
    <published>2019-05-04T12:56:52.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>今年面试的人比较多，加起来快一百人了。由于面试任务比较多，也有越来越多的小伙伴加入了面试官的行列。 总结一些面试相关的方法论，希望新晋面试官有些帮助，最终能高效面试。</p><h2 id="必备思维"><a href="#必备思维" class="headerlink" title="必备思维"></a>必备思维</h2><p>面试官的目标是为组织找到合适的人，一切行为都是围绕这个主体来运作的。我们现在的面试还是类似于考试，这是一种能够在短时间内高效选择到合格面试者的方法。 <strong>存在误杀</strong>：和高考一样，面试不合格的人，也可能做好招聘岗位的工作。存在可能性，但是我们要通过面试题的设计，让这种概率尽可能小。 面试是为了选人才，不是为了难住面试者。所有的问题都结合面试岗位的要求，如果判断能胜任即可，我们的目的不是考试难倒候选人。 为什么不是一台电脑或一张卷子直接评定面试者，还要一个面试官来面？因为现阶段的技术，评价一个人是否符合岗位要求，还有些主观考察，是电脑做不到的。要求面试官不是机械的问问题，要能主动发掘面试者的特点和能力。 在整个面试过程中，<strong>面试标准评价要客观，面试信息挖掘和引导要主观</strong>。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>面试官准备面试，针对整个流程，都要有对应的模板。笔试模板，面试模板，评价模板。通过模板，能够节省时间，把面试的经验和教训积累起来。对不同的面试人，采用同一套模板体系，能够客观公证地评价面试者的成绩。让自己的状态对面试结果影响最小。</p><h3 id="笔试模板"><a href="#笔试模板" class="headerlink" title="笔试模板"></a>笔试模板</h3><p><strong>有多套笔试题</strong>，每套笔试题都有对应合格的分数。面试者分数应该是符合正态分布，能够区分出不同水平的人。 <strong>题目具有层次</strong>，一道题能够针对不同水平的人，增加更深入的问题。通过层层深入，评估出面试者的能力层级。 <strong>对漏题有对策</strong>，针对漏题有几种方式。 最简单的就是换题，增加新题目，看面试者是否能答出。 更好的是题目设计为开放性问题，没有标准答案，但是能够根据面试者的分析和解答过程，评价出面试者的能力。而且还可以延展问题，根据问题的回答，往不同方向延展，检测面试者是否真的又掌握这种知识。例如设计一个系统，设计一个类，并说明原因。这类素质不是靠背就能答出来的。需要经验的累积，这些不是短时间能突击出来的。 笔试题模板要有多种选项，每道题都有延展问题和细节扩充，能够应对不同水平的面试者。 问题要能层层递进，并且有区分度。</p><h3 id="面试模板"><a href="#面试模板" class="headerlink" title="面试模板"></a>面试模板</h3><p>笔试能够快速过滤掉能力不行的面试者。如果笔试通过，再通过面试来观察面试者是否符合进一步要求。这也是面试官的主要职责。 在面试前，针对要考察的素质（包括技术和非技术的）列好问题模板，在交流中要考察哪些点。提前查看简历，针对简历和问题进行合并，确定重点问的问题。 针对面试模板，最终输出一个表格，表格里有每项的权重，满分，时间是多少。面试时，填写面试者实际的分数，面试结束后综合打分。</p><h2 id="面试节奏"><a href="#面试节奏" class="headerlink" title="面试节奏"></a>面试节奏</h2><p>面试官要把握面世节奏，高效面试。 一票否决：事先明确哪些面试者是和公司要求有冲突的，不能加入的。例如：人品有问题，某些习惯难以适应招聘岗位。 面试过程中可以给予提示，但是提示也是分层的，根据提示的信息，最终给的分数也不同。如果发现面试者没思路，尽早换题，或询问面试者擅长的地方，有效考察能力。 推动面试的进行，模板中的问题要都问到，不要在一项素质已经评定好，特别是认定通过后，还耗费时间。防止面试时间过长，或者面试结束后，还评定不出面试者的能力。 面试过程中要针对简历和不明确的地方充分核实。例如毕业年份和上班年份有偏差，工作年限中有空白期等。 运用STAR面试法（S情况、T任务、A行动、R结果）针对面试者的项目，了解这四方面。要明确，完整，从多角度考察。通知在交流过程中也能对面试的沟通，表达等其他素质进行评定。</p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><p>面试结束后就真的结束了吗？不是的。 面试结束后和面试者保持沟通，保证顺利进行下一轮面试，防止两轮面试间隔太久，让面试者焦急等待。 详细录入面试题目和评价，供下一面面试官参考。录入内容包括：出了哪些题目，擅长、不擅长哪些，题目答的情况…… 同时总结模板中的优缺点，统计面试历史，根据实际情况对模板进行修订。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要稳定、高效地面试，以上几点是必须要做到的。 制定合适的模板，定期总结修正。保证面试评定客观公正，在面试过程中合理引导，推动面试顺利进行。让面试结果受面试官的影响降到最小，不至于因为面试官自身的情况而影响到面试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今年面试的人比较多，加起来快一百人了。由于面试任务比较多，也有越来越多的小伙伴加入了面试官的行列。 总结一些面试相关的方法论，希望新晋面试官有些帮助，最终能高效面试。&lt;/p&gt;
&lt;h2 id=&quot;必备思维&quot;&gt;&lt;a href=&quot;#必备思维&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第133场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>今天参加了leetcode的周赛，算法比赛，要求速度比较快。有思路就立马启动，不会纠结是否有更好的方法或代码可读性。只要在算法复杂度数量级内，基本上是怎么实现快速就怎么来了。</p><p>比赛时先看的第二题，一看题就有了思路，直接用的广度优先搜索，写完提交正确。再一看有人都做了3道题了，应该是职业选手了，要多像他们看齐。</p><p>之后看第一题，发现直接用贪心就能做，写了个双重循环，一次过掉。</p><p>第三题求最优连续子数组和，想到是动态规划。然后在处理代码细节上花了很长时间，中间提交还错了一次，在十一点半左右提交通过。</p><p>再看第四题，能想到是trie树和ac自动机，但是我手上没有现成代码，到比赛完也没有完成。</p><p>本次比赛题目偏简单，及时第四题如果经常做竞赛也很容易写。以后要多做些训练，把常用的代码整理下，否则比赛会比较耗时间。另外要多训练算法思维，一是在比赛时能够思路快。二是算法在工作中也比较重要，虽然很多时候都有封装好的现成函数，但是知道其中的原理，能够更高效地解决问题，对于新问题的思考也更全面更准确。</p><p>下面是今天比赛的详细解题。</p><hr><p>今天比赛的地址 Weekly Contest 133 <a href="https://leetcode-cn.com/contest/weekly-contest-133">https://leetcode-cn.com/contest/weekly-contest-133</a> </p><h2 id="1-两地调度-Two-City-Scheduling"><a href="#1-两地调度-Two-City-Scheduling" class="headerlink" title="1. 两地调度(Two City Scheduling)"></a>1. 两地调度(Two City Scheduling)</h2><p>题号：1029</p><p>题目：两地调度(Two City Scheduling)</p><p>题意：2*N个人去A、B两地，每个地方都只有N个人去，每个人去A、B两地的费用分别给出，求总计最小费用。</p><p>思路：</p><p>方法一：</p><p>有最优策略，先把2N个人随意分成A、B两个集合，每个集合N个人。A集合去A地，B集合去B地。然后对于A集合中每个人ai，到B集合中遍历每个人bj，看是否能互换位置，让整体费用更低。如果有则换位置，没有检查下一个。全部换完则是最优解。</p><p>换的条件是ai去A的费用+bj去B的费用，要大于ai去B的费用+bj去A的费用。这样bj与ai互换整体费用会最低。</p><p>时间复杂度O(n^2)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">        vector&lt;int&gt; va;</span><br><span class="line">        vector&lt;int&gt; vb;</span><br><span class="line">        for(int i=0;i&lt;costs.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%2==0)</span><br><span class="line">                va.push_back(i);</span><br><span class="line">            else</span><br><span class="line">                vb.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;va.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0; j&lt;vb.size();++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int aindex=va[i];</span><br><span class="line">                int bindex=vb[j];</span><br><span class="line">                int acost = costs[aindex][0]+costs[bindex][1];</span><br><span class="line">                int bcost = costs[aindex][1]+costs[bindex][0];</span><br><span class="line">                if(acost&gt;bcost)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(va[i],vb[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(auto i : va)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=costs[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto i : vb)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=costs[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二</p><p>把2N个人的费用排序，到B地比到A地超出差价大的人排在前面，最后让前N个人去，排在前面的人去A地更划算。整体费用最低。</p><p>时间复杂度O（nlogn）</p><p>方法三</p><p>动态规划，此题有最优子结构。用f[n][m]表示n个人，派m个人去A地，所花费的最小钱数。这时再来一个人，这个人有两种选择，一种是去A地，一种是去B地。<br>则更新</p><ol><li>如果去A地：f[n+1][m+1] &#x3D; min(f[n+1][m+1], f[n][m]+costA);</li><li>如果去B地：f[n+1][m]   &#x3D; min(f[n+1][m],   f[n][m]+costB);</li></ol><p>costA、costB表示这个人去A、B的花费。</p><h2 id="2-距离顺序排列矩阵单元格"><a href="#2-距离顺序排列矩阵单元格" class="headerlink" title="2. 距离顺序排列矩阵单元格"></a>2. 距离顺序排列矩阵单元格</h2><p>题号：1030</p><p>题目：距离顺序排列矩阵单元格(Matrix Cells in Distance Order)</p><p>题意：给出矩阵的行列值，和一个坐标点r，输出所有矩阵坐标，按照每个点到r曼哈顿距离排序输出。</p><p>两个坐标点(r1,c1)(r2,c2)的曼哈顿距离是|r1 - r2| + |c1 - c2|。</p><p>思路：<br>方法一：直接求出每个点到给出坐标的距离，再排序，然后输出即可。</p><p>方法二：用广度优先搜索，每次搜索到的点依次输出即可。比方法一代码麻烦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(R, vector&lt;int&gt;(C, 0));</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;r0,c0&#125;);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int i = p.first;</span><br><span class="line">            int j = p.second;</span><br><span class="line">            if(visited[i][j]==1)</span><br><span class="line">                continue;</span><br><span class="line">            visited[i][j] = 1;</span><br><span class="line">            res.push_back(&#123;i,j&#125;);</span><br><span class="line">            int dx[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">            int dy[]=&#123;0,0,-1,1&#125;;</span><br><span class="line">            for(int k=0;k&lt;4;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = dx[k]+i;</span><br><span class="line">                int y = dy[k]+j;</span><br><span class="line">                if(x&gt;=0&amp;&amp;x&lt;R&amp;&amp;y&gt;=0&amp;&amp;y&lt;C)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(visited[x][y]==0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.push(&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-两个非重叠子数组的最大和"><a href="#3-两个非重叠子数组的最大和" class="headerlink" title="3. 两个非重叠子数组的最大和"></a>3. 两个非重叠子数组的最大和</h2><p>题号：1031</p><p>题目：两个非重叠子数组的最大和(Maximum Sum of Two Non-Overlapping Subarrays)</p><p>题意：</p><p>给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）</p><p>从形式上看，返回最大的 V，而 V &#x3D; (A[i] + A[i+1] + … + A[i+L-1]) + (A[j] + A[j+1] + … + A[j+M-1]) 并满足下列条件之一：</p><p>0 &lt;&#x3D; i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length, 或 0 &lt;&#x3D; j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length.</p><p>思路：</p><p>按照题目的思路，把A数组从元素i开始，分割成两部分，A[0…i],A[i+1…n]。求出A[0…i]中连续子数组中长度为L、M的和的最大值maxl1，maxm1，再求出A[i+1…n]中连续子数组中长度为L和M的和最大值maxl2,maxm2，在第i个元素分割时找到的最大值是maxi&#x3D;max((maxl1+maxm2),(maxm1+maxl2))。</p><p>那如何计算长度为L或M的连续子数组的和呢?假设要求的sum区间是L[k+1,k+2,…,k+L],则这个区间的值，可以用L[0,…k+L]的和减去L[0,…,k+1]的区间和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> len, vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            sum+=A[i];</span><br><span class="line">        v[len<span class="number">-1</span>]=sum;</span><br><span class="line">        maxsum = sum;</span><br><span class="line">        <span class="keyword">for</span>(i=len;i&lt;A.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum-A[i-len]+A[i];</span><br><span class="line">            maxsum=<span class="built_in">max</span>(sum,maxsum);</span><br><span class="line">            v[i]=maxsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> L, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; B = A;</span><br><span class="line">        <span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L1</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L2</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M1</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M2</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">getMaxSum</span>(A, L, L1);</span><br><span class="line">        <span class="built_in">getMaxSum</span>(B, M, M1);</span><br><span class="line">        <span class="type">int</span> sum1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = L<span class="number">-1</span>;i&lt;n-M;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="type">int</span> y = n<span class="number">-1</span>-(i<span class="number">+1</span>);</span><br><span class="line">            sum1=<span class="built_in">max</span>(sum1,L1[i]+M1[n<span class="number">-1</span>-(i<span class="number">+1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getMaxSum</span>(A, M, L2);</span><br><span class="line">        <span class="built_in">getMaxSum</span>(B, L, M2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = M<span class="number">-1</span>;i&lt;n-L;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1=<span class="built_in">max</span>(sum1,L2[i]+M2[n<span class="number">-1</span>-(i<span class="number">+1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(sum1,sum2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4. 字符流"></a>4. 字符流</h2><p>题号：1032</p><p>题目：字符流(Stream of Characters)</p><p>题意：给定一个单词表words，然后每次输入一个字母，假设地k次输入字母为a[k]。则a[i],a[i+1]…a[k]组成的单词(i&gt;&#x3D;1且i&lt;&#x3D;k),在单词表words中出现，输出true，否则输出false。</p><p>思路：<br>题目比较好理解，主要是根据words建立字典，由于都是小写字母，而且涉及到前缀的查询，用trie树是最好的数据结构。</p><p>对于每次输入字母a[k]，首先查询a[k]是否匹配某个单词。然后把之前输入的前缀能查到的单词，和a[k]结合，再查询是否能匹配某个单词。如果完全匹配，则返回结果为true。在返回前，要把所有能匹配单词表中单词，或词表前缀的单词留下来，留着下一轮输入字母时匹配备用。</p><p>但是这里是有方法优化的，如果每次都重头匹配单词，会超时。优化的方法有三种，</p><p>一、把上次匹配到前缀的trie树节点指针存储起来，下次只匹配一次字母即可。</p><p>二、使用ac自动机进行多模式匹配。</p><p>三、trie树中存储倒序的字符串，然后把每次输入的字母都按顺序保存起来。按照倒序匹配，如果匹配到一个完整的单词，返回true；如果匹配到不存在的单词，则返回false；如果匹配的是某个前缀，继续往下匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode&#123;    </span><br><span class="line">public:</span><br><span class="line">    bool hasVal=false;</span><br><span class="line">    vector&lt;TrieNode*&gt; children;</span><br><span class="line">    TrieNode() : children(26,NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class TrieTree&#123;</span><br><span class="line">public:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">    TrieTree()</span><br><span class="line">    &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    int insert(string&amp; word)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        for(int i = 0; i &lt; word.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int n=word[i]-&#x27;a&#x27;;</span><br><span class="line">            if(p-&gt;children[n]==NULL)&#123;</span><br><span class="line">                p-&gt;children[n]=new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;children[n];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;hasVal=true;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    bool query_has_r_suffix(string&amp; word)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        for(int i=word.length()-1;i&gt;=0;--i)&#123;</span><br><span class="line">            char ch = word[i];</span><br><span class="line">            int n=ch-&#x27;a&#x27;;</span><br><span class="line">            if(p-&gt;children[n]==NULL)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;children[n];</span><br><span class="line">            if(p-&gt;hasVal) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class StreamChecker &#123;</span><br><span class="line">    TrieTree * tree =new TrieTree();</span><br><span class="line">    string suf_str;</span><br><span class="line">public:</span><br><span class="line">    StreamChecker(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">         for(string w:words)&#123;</span><br><span class="line">             reverse(w.begin(),w.end());</span><br><span class="line">             tree-&gt;insert(w);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool query(char letter) &#123;</span><br><span class="line">        suf_str.push_back(letter);</span><br><span class="line">        return tree-&gt;query_has_r_suffix(suf_str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your StreamChecker object will be instantiated and called as such:</span><br><span class="line"> * StreamChecker* obj = new StreamChecker(words);</span><br><span class="line"> * bool param_1 = obj-&gt;query(letter);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天参加了leetcode的周赛，算法比赛，要求速度比较快。有思路就立马启动，不会纠结是否有更好的方法或代码可读性。只要在算法复杂度数量级内，基本上是怎么实现快速就怎么来了。&lt;/p&gt;
&lt;p&gt;比赛时先看的第二题，一看题就有了思路，直接用的广度优先搜索，写完提交正确。再一看有人</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第134场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。</p><p>第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。</p><p>通过第四题发散想一下，还是能够发现很多有意思的结论，在题解中会详细分析。</p><p>思考到最后，甚至想到了极限，量变引起质变。烧脑，头疼，感觉数学知识好匮乏，我要去学习了。</p><p>下面是详细的题解和思考。</p><hr><p>今天比赛的地址 Weekly Contest 134</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-134">https://leetcode-cn.com/contest/weekly-contest-134</a></p><h2 id="1-动石子直到连续"><a href="#1-动石子直到连续" class="headerlink" title="1. 动石子直到连续"></a>1. 动石子直到连续</h2><p>题目：移动石子直到连续(Moving Stones Until Consecutive)</p><p>题号：</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/">https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/</a></p><p>题意：</p><blockquote><p>三枚石子放置在数轴上，所在位置必须是整数。位置分别为 a，b，c。<br>每一回合，假设三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z &gt; 且 k !&#x3D; y。<br>当这些石子的位置连续时，游戏结束。</p><p>要使游戏结束，可以执行的最小和最大移动次数分别是多少？</p></blockquote><p>思路：<br>每次只能移动最左侧，或者最右侧的石子往中间移动。所以z-x的值是逐渐收敛的。</p><p>最大次数就是一步一步往中间挪，所需的步数是z-x-2。因为z和x之间能移动的空间是z-x-1，还要去掉一个y占的位置，所以最终移动的最多步数是<code>z-x-2</code>。</p><p>最小步数呢？</p><p>最小值为0：如果x,y,z三个值本身就挨着，那么不用移动就游戏结束了。</p><p>最小值为1：如果x和y之间只有一个位置，那么z移动到这个空位，只移动1次也就结束了。</p><p>最小值为2：除了上面两种情况，每次都把x移动到y-1或把z移动到y+1，那么只要两步就结束了。</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numMovesStones(int a, int b, int c) &#123;</span><br><span class="line">        if(a&gt;b)</span><br><span class="line">            swap(a,b);</span><br><span class="line">        if(a&gt;c)</span><br><span class="line">            swap(a,c);</span><br><span class="line">        if(b&gt;c)</span><br><span class="line">            swap(b,c);</span><br><span class="line">        int mx = c-b-1+b-a-1;</span><br><span class="line">        int mi = 0;</span><br><span class="line">        if(abs(c-b)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(abs(b-a)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(b-a==2||c-b==2)</span><br><span class="line">            mi=1;</span><br><span class="line">        return vector&lt;int&gt;&#123;mi,mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-边框着色"><a href="#2-边框着色" class="headerlink" title="2. 边框着色"></a>2. 边框着色</h2><p>题目：边框着色（Coloring A Border）</p><p>题号：</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/">https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/</a></p><p>题意：给一个二维网格，网格被分成几种区域，每个区域都被涂上了不同的颜色。然后给定一个点（x,y）和一种颜色值c。要求把这个点所在的区域边缘涂上颜色c,最后返回新的网格图。</p><p>思路：</p><p>先根据点找到整个区域的点的集合，然后判断哪些点是边缘，如果是边缘，给边缘涂色。</p><p>找到区域点集合可以用深度优先搜索或广度优先搜索。判定边缘，就看和二位网格的边界是否相连，还有是否上下左右有其他颜色。</p><p>为了方便判断，减少干扰。可以再建两个网格，一个网格标识哪些点被搜索过，一个网格标识最终涂色的网格。</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    bool isEdge(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; grid, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]!=ocolor)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; visited,vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int pcolor, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isEdge(i,j,grid,ocolor))</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j]=pcolor;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j]=1;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]==ocolor&amp;&amp;!visited[x][y])</span><br><span class="line">                    dfs(grid,visited,res,x,y,pcolor,ocolor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123;</span><br><span class="line">        m=grid.size();</span><br><span class="line">        n=grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(m,vector&lt;int&gt;(n,0));</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(grid);</span><br><span class="line">        dfs(grid,visited,res,r0,c0,color,grid[r0][c0]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-不相交的线"><a href="#3-不相交的线" class="headerlink" title="3. 不相交的线"></a>3. 不相交的线</h2><p>题目：不相交的线（Uncrossed Lines）</p><p>题号：</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/">https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/</a></p><p>题意：</p><blockquote><p>在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p><p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p><p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p></blockquote><p>思路：</p><p>我们设函数f(x,y)标识A的前x个数字和B的前y个数字，能绘制出的最大连接数。假设A、B都是从下标1开始。</p><p>则f(0,y)&#x3D;0,f(x,0)&#x3D;0;</p><p>情况1：</p><p>如果<code>A[x]!=B[y]</code>，那么<code>f(x,y)=max(f(x-1,y),f(x,y-1))</code>;</p><p>情况2：</p><p>如果<code>A[x]==B[y]</code>，那么<code>f(x,y)=f(x-1,y-1)+1</code>;</p><p>可以看出，是一个标准的递推公式，利用两层循环就能得出答案，最后求<code>f(A.size(),B.size())</code>就是答案。</p><p>公式的推导如下：</p><p>如果两个长度为0的整数串连线，最大值肯定为0。</p><p>如果出现情况1，在合法的解答中，不可能出现A[x],B[y]都参与连线的情况。如果他们两个点都被别的点连线了，那么一定会出现直线相交。因为与B[y]连线的点一定小于A[x]，与A[x]连线的点的位置也一定小于B[y]。</p><p>如果出现情况2, 那么一定A[x]和B[y]连是最优解，其他没有比这个情况更大的解。否则A[x]和B[y]一定只有一个点参与连线（看情况1中的说明，否则会有相交）。</p><p>例如只有B[y]参与了连接，连了A[z]，那么A[z]一定小于A[x]，所以f(z,y)&#x3D;f(x,y)，和A[x]连B[y]的情况值一样。所以把这两个点去除得到f(x-1,y-1)再加上这两个点连上的情况，就是f(x,y)的值了。</p><p>看这个公式也有点眼熟原来是最长公共子序列（Longest Common Subsequences)。就是求两个字符串公共子序列的长度。例如<strong>A</strong>B<strong>C</strong>E<strong>D</strong>和<strong>A</strong>XY<strong>CD</strong>的最长公共子序列就是ACD，和上面的递推是一样的。因为子序列能够保证他们的连线不相交。</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">        int m=A.size();</span><br><span class="line">        int n=B.size();</span><br><span class="line">        int v[501][501]=&#123;0&#125;;</span><br><span class="line">        for(int i=1;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i-1]==B[j-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    v[i][j]=v[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v[i][j]=max(v[i-1][j],v[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-逃离大迷宫"><a href="#4-逃离大迷宫" class="headerlink" title="4. 逃离大迷宫"></a>4. 逃离大迷宫</h2><p>题号：</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/">https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/</a></p><p>题目：逃离大迷宫（Escape a Large Maze）</p><p>题意：<br>在一个10^6 乘 10^6的二维网格上，标识两个点S和T，还有最多200个障碍点。问S和T是否连通。<br>连通的定义为，从S出发，只通过上下左右移动，且障碍点是不能移动到的，最终能够移动到T。</p><p>思路：<br>如果网格很小比较简单，就和第二题一样，通过深搜或广搜，看是否能到达终点T即可。但是网格空间太大了。直接搜肯定超时。</p><p>可以从最多200个点来思考。到不了的情况就是S或T被这200个点给围住了。只要能判断是否被围住就可以了。</p><p>原题200个点是在最下面数据范围里写的，很隐藏，很难注意到。</p><p><strong>怎么判断S或T被障碍点围住呢？</strong> </p><p>找到200个点能够围住的最大范围包括的点数Total，从S广搜，如果已经搜到Total个空白点，还有路可走，那么这200个点肯定包围不了S点。</p><p>同理再判断下是否有包围住T点，两个都没被包围，则一定能走到。</p><p>当然，也可能两个点都被包围了，那么在搜的时候判断能直达，直接返回true就可以了。</p><p>200个点能够包围的最大空白部分是多少？答案是19900&#x3D;(200-1)*200&#x2F;2。</p><p>为什么是这个值呢？<br>如果要200个障碍点得到充分利用，包围最多的范围，那么一定要借助网格自身的边界。</p><p>如果是直线，相同周长，面积最大的是圆，所以围成个1&#x2F;4圆可能是答案。但是网格上的点是离散的，围成个三角形，200个点做斜边，是围成区域最大的。为什么不是圆呢，因为两个正方形，只有斜着连接，在二维表围的面积才最大。如图</p><p><img src="https://www.owenzhang.net/blog/wp-content/uploads/2019/04/a6bacec19fccfc0d0c64facc89919cd4.png"></p><p>如上图，最开始是黄色的布局障碍。此时有1、3、5三个点是在统一垂直方向，这时让1移动到2会更好，多围一个点，把3移动到4也会多一个点。同理5-&gt;6,4-&gt;7,2-&gt;8最终形成一个斜线，达到蓝色部分。就能围住的点最多了。那点有多少个呢？设斜边的长度为n个方块。则围住的总面积块数等于1+2+3+…+n-n&#x3D;n*(n-1)&#x2F;2。</p><p>有两个问题：</p><p><strong>1. 为什么连续区间周长最大的是圆，而在二位方块中最大的是三角形？</strong></p><p>因为对于每个小方块，能够贡献的长度只有自己的边长和内部的斜对角线长度，没有圆的弧线。这样斜对角线就是获取最长长度的最优解。</p><p><strong>2. 一个3×3方块围成的图形，面积是9，周长是12。但是周长上的边的方块一共有多少个？</strong></p><p>这个问题的第一反应是3×3&#x3D;9，但实际围成外围的方块数是2×4&#x3D;8。就像题目中说的200个点，如果围个正方形，那么肯定不是边长为50的，而是51。因为四个角的方块是两个边公用的，如果在连续空间中，只是一个点，但是在离散中，这个点就是个面积了。</p><p>上面说的这些有什么用呢？</p><p>生活中，家里铺地砖，不理解会算错。</p><p>工作中，做计算机图形展示程序，或者做显示器上的运算，都是离散像素点，理解好会有有助于实现。</p><p>又衍生了几个问题需要研究：</p><p>现实世界中有绝对的圆吗?世界是离散的还是连续的?微分到一定的量就出现了无理数π。这个值是怎么得出来的，他和自然有什么关系，在宇宙中是什么存在？有没有的时空，或者什么情况下又出现新的无理数替代掉π？？？</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int,unordered_map&lt;int, int&gt;&gt; position;</span><br><span class="line">    const int kBlock = 1;</span><br><span class="line">    const int kSource = 2;</span><br><span class="line">    const int kTarget = 3;</span><br><span class="line">    const int kMaxPosNum = (1+200)*200/2-200;</span><br><span class="line">    int R=1e6;</span><br><span class="line">    int C=1e6;</span><br><span class="line">    bool bfs(int sx, int sy, int sourceFlag, int targetFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;sx,sy&#125;);</span><br><span class="line">        int total = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int i = p.first;</span><br><span class="line">            int j = p.second;</span><br><span class="line">            if(position[i][j]==targetFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            total++;</span><br><span class="line">            if(total&gt;kMaxPosNum)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            int dx[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">            int dy[]=&#123;0,0,-1,1&#125;;</span><br><span class="line">            for(int k=0;k&lt;4;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = dx[k]+i;</span><br><span class="line">                int y = dy[k]+j;</span><br><span class="line">                if(x&gt;=0&amp;&amp;x&lt;R&amp;&amp;y&gt;=0&amp;&amp;y&lt;C&amp;&amp;position[x][y]!=sourceFlag&amp;&amp;position[x][y]!=kBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    position[x][y] = sourceFlag;</span><br><span class="line">                    q.push(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) &#123;</span><br><span class="line">        for(int i=0;i&lt;blocked.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            position[blocked[i][0]][blocked[i][1]]=kBlock;</span><br><span class="line">        &#125;</span><br><span class="line">        position[source[0]][source[1]]=kSource;</span><br><span class="line">        position[target[0]][target[1]]=kTarget;</span><br><span class="line">        return bfs(source[0], source[1], kSource, kTarget)</span><br><span class="line">            &amp;&amp; bfs(target[0], target[1], kTarget, kSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。&lt;/p&gt;
&lt;p&gt;第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。&lt;/p&gt;
&lt;p&gt;通过</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第135场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>这周比赛的题目很有特点。几道题都需要找到一定的技巧才能巧妙解决，和以往靠数据结构的题目不太一样。</p><p>就是如果懂原理，代码会很简单，如果暴力做，也能做出来，但是十分容易出错。</p><p>第四题还挺难想的，想了好久才想明白。这次先讲第四题，然后再讲其他的题目。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 135 </p><p><a href="https://leetcode-cn.com/contest/weekly-contest-135">https://leetcode-cn.com/contest/weekly-contest-135</a> </p><h2 id="移动石子直到连续-II"><a href="#移动石子直到连续-II" class="headerlink" title="移动石子直到连续 II"></a>移动石子直到连续 II</h2><p><strong>题目：</strong>移动石子直到连续 II(Moving Stones Until Consecutive II)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-135/problems/moving-stones-until-consecutive-ii/">https://leetcode-cn.com/contest/weekly-contest-135/problems/moving-stones-until-consecutive-ii/</a></p><p><strong>题意：</strong></p><p>在数轴上摆放了n个石子，石子位置都是整数，并且不能重叠。游戏规则是：每个回合，将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。无法移动时游戏停止。</p><p>问最小和最大移动次数分别是多少。</p><p><strong>思路：</strong></p><p>题目是上周第一题的扩展，但是有点不同。</p><p>由题意可知，每进行一轮操作，石子的左右端点的距离会缩短，一轮一轮收敛。最后会石子都紧邻游戏结束。</p><p>举个例子：</p><p>初始时有8颗石子，在数轴上的有石子的刻度为：</p><p>4，6，8，9，15，16，19，20</p><p><strong>最大值求解方法：</strong></p><p>石子可以放置的空间，等于左右两端石子之间的未占用位置。在例子中，一共有20-4+1-8个位置。</p><p>石子覆盖的线段长度是20-4个，加上一个端点的位置即20-4+1，再减去已经占用的8个位置。</p><p>用公式表示为</p><p><code>s1=stones[n-1]-stones[0]+1-n</code>。</p><p>但是第一次移动的左端点或右端点的石子后，这个移动的石子和它相邻的那颗石子之间的空间，后面就不能被放置了，因为与他相邻的那个点变为端点，他们之间的位置不可以被放置了。</p><p>例如第一步移动了4，那么5这个位置就不可能放置石子了。所以要计算不能被访问的空间</p><p><code>s2=min(stones[n-1]-stones[n-2]-1, stones[1]-stones[0] -1)</code>。</p><p>最大值为<code>s1-s2</code>。因为在后面的步骤里，我们都可以做出策略，让每一轮左右端点的差值只减1。</p><p><strong>最小值求解方法：</strong></p><p>如果最后游戏结束，那么一定有n个连续坐标摆满了石子。如果我们要移动最少，必定要找一个石子序列，使得在n大小连续的坐标内，初始时有最多的石子。</p><p>设想有个尺子，上面有n个刻度点，我们用这个尺子在石子从最左边到最右边移动，每动一次都查看下在尺子范围内有m个石子，那么要使这个区间填满，就需要移动n-m次。</p><p>只要在尺子外部有石子，就有策略填满尺子内的。</p><p>这些次数中最小的就为虽少次数。</p><p>但是有一种特例：</p><p>1，2，3，4，7</p><p>这种1-4是最好的序列，但是7不能移动到端点，只能1先移动到6，然后7移动到5解决，这种情况要用2步。就是尺子内的石子都是连续的，中间没空洞，只在边上有空，要用2次。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numMovesStonesII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(stones.<span class="built_in">begin</span>(),stones.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mx = stones[n - <span class="number">1</span>] - stones[<span class="number">0</span>] + <span class="number">1</span> - n;</span><br><span class="line">        mx -= <span class="built_in">min</span>(stones[n<span class="number">-1</span>]-stones[n<span class="number">-2</span>] - <span class="number">1</span>, stones[<span class="number">1</span>]-stones[<span class="number">0</span>] <span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> mi = mx;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j + <span class="number">1</span> &lt; n &amp;&amp; stones[j + <span class="number">1</span>] - stones[i] + <span class="number">1</span> &lt;= n)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="type">int</span> cost = n - (j - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j - i + <span class="number">1</span> == n - <span class="number">1</span> &amp;&amp; stones[j] - stones[i] + <span class="number">1</span> == n - <span class="number">1</span>)</span><br><span class="line">                cost = <span class="number">2</span>;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;mi, mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="有效的回旋镖"><a href="#有效的回旋镖" class="headerlink" title="有效的回旋镖"></a>有效的回旋镖</h2><p><strong>题目：</strong>有效的回旋镖(Valid Boomerang)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-135/problems/valid-boomerang/">https://leetcode-cn.com/contest/weekly-contest-135/problems/valid-boomerang/</a></p><p><strong>题意：</strong></p><blockquote><p>回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。<br>给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。</p></blockquote><p><strong>思路：</strong></p><p>题目说是回旋镖，其实就是三角形。只要能判断三点不共线就可以。</p><p>方法一：简单的想法可以用斜率和截距的方法，判断三点共线。</p><p>缺点：要用到除法，可能有精度问题，而且要考虑和坐标轴平行的特殊情况。</p><p>方法二：利用三角形变长的性质，两边之和大于第三边。</p><p>缺点：也存在用开方的操作，可能有精度问题。</p><p>方法三：最优的方法。利用向量叉积。因为a×b&#x3D;|a|.|b|sinθ。如果共线sinθ为0。</p><p>向量叉积后还是的向量，这个向量的长度是两个向量所组成平行四边形的面积。如果共线，这个值为0。</p><p>具体可以参考维基百科：</p><p><a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF">https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF</a></p><p><img src="https://www.owenzhang.net/blog/wp-content/uploads/2019/05/cross.png" alt="叉乘公式"></p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBoomerang</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x1=points[<span class="number">0</span>][<span class="number">0</span>],y1=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x2=points[<span class="number">1</span>][<span class="number">0</span>],y2=points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x3=points[<span class="number">2</span>][<span class="number">0</span>],y3=points[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cross = (y3-y1)*(x2-x1) - (y2-y1)*(x3-x1);</span><br><span class="line">        <span class="keyword">return</span> cross != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从二叉搜索树到更大和树"><a href="#从二叉搜索树到更大和树" class="headerlink" title="从二叉搜索树到更大和树"></a>从二叉搜索树到更大和树</h2><p><strong>题目：</strong></p><p>从二叉搜索树到更大和树(Binary Search Tree to Greater Sum Tree)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-135/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/contest/weekly-contest-135/problems/binary-search-tree-to-greater-sum-tree/</a></p><p><strong>题意：</strong></p><p>修改树的每个节点的值，为访问的所有节点的和，包括当前节点。<br>访问的次序是先访问右子树，再访问根节点，再访问左子树。</p><p><strong>思路：</strong></p><p>代码比较简单，递归实现。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">bstToGst</span>(root-&gt;right);</span><br><span class="line">        ans+=root-&gt;val;</span><br><span class="line">        root-&gt;val=ans;</span><br><span class="line">        <span class="built_in">bstToGst</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a>多边形三角剖分的最低得分</h2><p><strong>题目：</strong>多边形三角剖分的最低得分(Minimum Score Triangulation of Polygon)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-135/problems/minimum-score-triangulation-of-polygon/">https://leetcode-cn.com/contest/weekly-contest-135/problems/minimum-score-triangulation-of-polygon/</a></p><p><strong>题意：</strong></p><blockquote><p>想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p><p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p><p>返回多边形进行三角剖分后可以得到的最低分。</p></blockquote><p><strong>思路：</strong></p><p>选定凸多边形的一条边为底（A[0]A[N-1]组成的线段），和A[i]为顶点，可以把凸多边形分为三部分，左侧A[0]A[1]…A[i]组成的凸多边形，右侧A[i]A[i+1]…A[N-1]组成的凸多边形，还有A[0]A[i]A[N-1]组成的三角形。</p><p>两个凸多边形还可以再递归分解，最后比较出最优解。递归算过的形状不用重复计算，可以用记忆化搜索，记录中间结果。</p><p>如果凸多边形只有两个点，那么组成不了三角形，可以直接返回权值为0。</p><p>递推公式为：</p><p>设w(i,k,j)为i,j,k三个点组成的三角形的权值。</p><p><code>v[i][j]=0</code> (当i+1&#x3D;&#x3D;j时)</p><p><code>v[i][j]=v[i][k]+v[k][j]+w(i,k,j)</code> </p><p>（当i + 1 &lt; j时, i &lt; k &lt; j)</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">51</span>][<span class="number">51</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">w</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A[i]*A[j]*A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;<span class="type">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==j<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(memo[i][j]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        memo[i][j]=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i<span class="number">+1</span>; k &lt; j; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">dfs</span>(i, k, A) + <span class="built_in">w</span>(i, k, j, A) + <span class="built_in">dfs</span>(k, j, A);</span><br><span class="line">            memo[i][j] = <span class="built_in">min</span>(ans, memo[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>, A);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这周比赛的题目很有特点。几道题都需要找到一定的技巧才能巧妙解决，和以往靠数据结构的题目不太一样。&lt;/p&gt;
&lt;p&gt;就是如果懂原理，代码会很简单，如果暴力做，也能做出来，但是十分容易出错。&lt;/p&gt;
&lt;p&gt;第四题还挺难想的，想了好久才想明白。这次先讲第四题，然后再讲其他的题目。&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第136场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC136%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC136%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>周日的比赛的时候正在外面办事，没有参加。赛后看了下题目，几道题除了表面要考的内容，还是有些能发散扩展的地方。</p><p>做题目不是最终目的，通过做题发现知识盲区，去研究学习，才能不断提高。</p><p>理论和实际是有关系的，一些题目也都有现实意义。计算机的一些模拟操作，通过数学算法，能够大大减轻代码量和算法复杂度。</p><p>第一题是机器人在坐标系上直走和转弯，通过简单的模拟就能实现。但是仔细思考发现还能通过线性代数，坐标变换的方式做，这样在实际中计算更快。甚至还可以用复数来做。</p><p>实际扫地机器人可能就用到了类似的算法。让他能够不至于始终原地打转。</p><p>第四题是典型的后缀树、后缀数组应用，找字符串最长重复子串。在搜索引擎，或DNA检测中，都是有实际使用场景的。在70年代就已经有应用了，是一个很经典的算法。而且在90年代至今，一直有科学家提升创建后缀树和后缀数组的时间复杂度。这个算法也是在不断发展的。而且在2016年中国的<code>李志泽，李建和霍红卫</code>三位科学家提出了线性时间复杂度，常数空间的最优构造算法。是中国人对算法的贡献。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 136</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-136">https://leetcode-cn.com/contest/weekly-contest-136</a> </p><h2 id="困于环中的机器人"><a href="#困于环中的机器人" class="headerlink" title="困于环中的机器人"></a>困于环中的机器人</h2><p><strong>题目：</strong></p><p>困于环中的机器人(Robot Bounded In Circle)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/">https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/</a></p><p><strong>题意：</strong></p><p>在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：</p><p>“G”：直走 1 个单位<br>“L”：左转 90 度<br>“R”：右转 90 度</p><p>机器人按顺序执行指令 instructions，并一直重复它们。</p><p>只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。</p><p><strong>思路：</strong></p><p>假设机器人重复走N次指令后，面朝北：</p><p>此时如果坐标在原点，则N次循环后就会重复从前的路径。</p><p>如果坐标不在原点，此时把当前位置当作原点，就会每N次移动远离一段和当前原点的距离。距离最初的（0，0）位置越来越远。就不存在循环会最原始原点的问题。</p><p>其实至多经过四次，机器人就会面朝北。</p><p>经过一次指令后，机器人面朝西或东，相当于逆时针或顺时针转了90度，则再经过三次，就面朝北了。</p><p>经过一次指令后，朝南则转了180度，共移动两次指令后朝北。</p><p>数学方法：</p><p>还可以把指令集先计算一遍，得出经过一个指令集后的相对移动位置和方向转角。用矩阵计算，就不用每次都运行一大堆指令模拟，加快运算速度；</p><p>还可以用复数来运算，复数对于转90度有简单的运算方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRobotBounded</span><span class="params">(string instructions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dir[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch : instructions)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x+=dir[i][<span class="number">0</span>];</span><br><span class="line">                y+=dir[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                i%=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">                i--;</span><br><span class="line">                i%=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;<span class="keyword">while</span>(i!=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不邻接植花"><a href="#不邻接植花" class="headerlink" title="不邻接植花"></a>不邻接植花</h2><p><strong>题目：</strong></p><p>不邻接植花(Flower Planting With No Adjacent)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/">https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/</a></p><p><strong>题意：</strong></p><p>在一个无向图中，每个点的出度都不超过3。有四种颜色，给每个点着色，要求有边相连的点颜色不同。</p><p>给出着色方案。</p><p><strong>思路：</strong></p><p>由于每个点出度不超过3，四个颜色，肯定可以有解。暴力枚举即可。由于图的点很多，边少。在寻找和点相连的点时，不要按点遍历，要按边遍历，否则会超时。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; mr;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; N)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> color=<span class="number">1</span>;color&lt;=<span class="number">4</span>;++color)</span><br><span class="line">        &#123;</span><br><span class="line">            res[index<span class="number">-1</span>] = color;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp; tmp = mr[index];</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it=tmp.<span class="built_in">begin</span>();it!=tmp.<span class="built_in">end</span>();++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res[it-&gt;first<span class="number">-1</span>]==color)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">dfs</span>(index<span class="number">+1</span>, N);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="type">int</span> N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">resize</span>(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;paths.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = paths[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = paths[i][<span class="number">1</span>];</span><br><span class="line">            mr[x][y] = <span class="number">1</span>;</span><br><span class="line">            mr[y][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分隔数组以得到最大和"><a href="#分隔数组以得到最大和" class="headerlink" title="分隔数组以得到最大和"></a>分隔数组以得到最大和</h2><p><strong>题目：</strong></p><p>分隔数组以得到最大和(Partition Array for Maximum Sum)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/">https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/</a></p><p><strong>题意：</strong></p><p>给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。</p><p>返回给定数组完成分隔后的最大和。</p><p><strong>思路：</strong></p><p>该问题可以划分为子问题求解。</p><p>设数组有N个元素A[0]A[1]…A[N-1]，sum(i)表示从A[i]~A[N]求解的最大和。</p><p>则sum(i) &#x3D; max( max(A[i]-A[i+m-1])*m + sum(m) )  其中i&lt;&#x3D;m&lt;&#x3D;k;</p><p>就是每个从i开始到数组结尾的最大和，等于前m个元素单独划分，再加上剩下元素的最大和。这k中划分方案最大的，就是从i开始到数组结尾最大和最大的。</p><p>依次计算到第0个位置结束。</p><p>为了计算统一，会用到sum(n),实际没有这个元素，初始化零计算即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&lt;i+K &amp;&amp; j &lt; n ;++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    ma = <span class="built_in">max</span>(ma, A[j]);</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], ma*(j - i + <span class="number">1</span>) + dp[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最长重复子串"><a href="#最长重复子串" class="headerlink" title="最长重复子串"></a>最长重复子串</h2><p><strong>题目：</strong></p><p>最长重复子串(Longest Duplicate Substring)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/">https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/</a></p><p><strong>题意：</strong></p><p>给出一个字符串 S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。</p><p>返回任何具有最长可能长度的重复子串。（如果 S 不含重复子串，那么答案为 “”。）</p><p><strong>思路：</strong></p><p>后缀数组教科书般的例题。</p><p>后缀数组是后缀树的一种变种，能够节省空间。构造的方法有「倍增算法」，「DC3算法」。</p><p>主要思想：</p><p>设字符串为S(1-n)由n个字符组成。则字符串有n个相同后缀的子串。分别为s(1-n),s(2-n),…,s(n-n)。</p><p>然后构建一个SA数组，每个数组存储这些后缀的子串，存储后进行字典序排序。</p><p>最后构造出一个height数组，表示SA数组每个元素和前一个元素相同前缀的字符个数。</p><p>那么，最长重复子串的长度就是height数组的最大值。</p><p>因为最长重复子串一定是两个不同后缀的公共前缀，而且这两个不同后缀的字典序排列后一定是相连的。否则一定有比他更长的。</p><p>所以height的最大值能够找到那两个后缀，然后提取公共前缀就找到答案。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SA</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">da</span><span class="params">(<span class="type">int</span> str[], <span class="type">int</span> sa[], <span class="type">int</span> rank[], <span class="type">int</span> height[], <span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i, j, p, *x = t1, *y = t2;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        c[x[i] = str[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        sa[--c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - j; i &lt; n; i++)</span><br><span class="line">            y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt;= j)</span><br><span class="line">                y[p++] = sa[i] - j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        p = <span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            x[sa[i]] = <span class="built_in">cmp</span>(y, sa[i - <span class="number">1</span>], sa[i], j) ? p - <span class="number">1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            k--;</span><br><span class="line">        j = sa[rank[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (str[i + k] == str[j + k])</span><br><span class="line">            k++;</span><br><span class="line">        height[rank[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num_rank[MAXN], height[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> sa[MAXN];</span><br><span class="line">&#125; <span class="comment">// namespace SA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> SA;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = S[i]&amp;<span class="number">0x3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(num, sa, num_rank, height, n, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; len)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = sa[i];</span><br><span class="line">                len = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S.<span class="built_in">substr</span>(pos, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;周日的比赛的时候正在外面办事，没有参加。赛后看了下题目，几道题除了表面要考的内容，还是有些能发散扩展的地方。&lt;/p&gt;
&lt;p&gt;做题目不是最终目的，通过做题发现知识盲区，去研究学习，才能不断提高。&lt;/p&gt;
&lt;p&gt;理论和实际是有关系的，一些题目也都有现实意义。计算机的一些模拟操作</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第137场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC137%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC137%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>今天的比赛的题目相对来说比较「直白」，不像前几周都是一些特定的算法，如果你没学过不可能想出来。</p><p>做了这些周，对leetcode比赛的题目也发现了一些「规律」。 <strong>一般前两道题都很「简单」</strong>，只要有想法，直接敲代码就能解出来。更多考察的是结果是否正确，速度其次。</p><p><strong>后两道题有些难度</strong> ，不同场次难度不一样，也可能和不同人的水平感受不同。但是肯定比前两道要难。</p><p>一般在做后两道题的时候，只要复杂度是对的，一些细节也不用考虑太多。例如数组开的空间大小，一些线性的提前剪枝判断，写不写都可以过。<strong>最主要的是复杂度是同一个量级的。</strong></p><p>相信leetcode这么设计是为了「人性化」，让选手更关注比赛题目核心，能够在一个半小时内完成比赛题目。</p><p>总之leetcode的比赛还是很人性化，很注重主要考点，不纠结于细节。利用这些特性，可以在比赛中排除一些错误想法。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 137</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-137">https://leetcode-cn.com/contest/weekly-contest-137</a></p><h2 id="1-最后一块石头的重量"><a href="#1-最后一块石头的重量" class="headerlink" title="1. 最后一块石头的重量"></a>1. 最后一块石头的重量</h2><p><strong>题目：</strong></p><p>最后一块石头的重量(Last Stone Weight)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight/">https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight/</a></p><p><strong>题意：</strong></p><blockquote><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p></blockquote><p><strong>思路：</strong></p><p>一个数组，每次把最大的两个数拿出来相减，然后把绝对值放回原数组。一直重复到最后只剩下一个元素，输出即可。</p><p>典型的模拟题，按照题目的意思写即可。可以用堆来实现，每次拿堆顶的两个最大元素。</p><p>由于是第一题，每次都排序一遍，也能通过。不过在日常工程中，还是老老实实用堆来实现吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt; <span class="type">int</span> &gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;stone : stones)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(stone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> z = <span class="built_in">abs</span>(x-y);</span><br><span class="line">            q.<span class="built_in">push</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-删除字符串中的所有相邻重复项"><a href="#2-删除字符串中的所有相邻重复项" class="headerlink" title="2. 删除字符串中的所有相邻重复项"></a>2. 删除字符串中的所有相邻重复项</h2><p><strong>题目：</strong></p><p>删除字符串中的所有相邻重复项(Remove All Adjacent Duplicates In String)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-137/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode-cn.com/contest/weekly-contest-137/problems/remove-all-adjacent-duplicates-in-string/</a></p><p><strong>题意：</strong></p><blockquote><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><p><strong>思路：</strong></p><p>类似于游戏「爱消除」，相同的两个字母抵消掉，形成的新字符串再接着抵消，直到稳定为止。</p><p>用栈来实现，遍历字符串的每个字符。如果栈为空，则插入字符，否则比较字符和栈顶元素，相同则弹出栈顶元素，不同则压栈。</p><p>最后输出栈内的字符串即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">top</span>()==ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-最长字符串链"><a href="#3-最长字符串链" class="headerlink" title="3. 最长字符串链"></a>3. 最长字符串链</h2><p><strong>题目：</strong></p><p>最长字符串链(Longest String Chain)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-137/problems/longest-string-chain/">https://leetcode-cn.com/contest/weekly-contest-137/problems/longest-string-chain/</a></p><p><strong>题意：</strong></p><blockquote><p>给出一个单词列表，其中每个单词都由小写英文字母组成。</p><p>如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，”abc” 是 “abac” 的前身。</p><p>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。</p><p>从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。</p></blockquote><p><strong>思路：</strong></p><p>这道题本质是图算法。</p><p>分两步解：</p><p>第一步先构造出每个单词之间的关系，判断任意两个单词是为前身后继关系。构造完关系就能画出了图。</p><p>第二步就是求解这个图中最长路径。由于是单向有向图，而且没有环。</p><p>构造一个集合，每次给集合放入新的点A，都判断集合中其他的点到该点的距离，取最大值为集合内部到新点A的最大距离L。下次再加入新的点A1，如果A和A1连通，则集合到A1的距离为L+1。</p><p>由于终点有多个，最后要遍历所有点的最长距离。</p><p>其实这道题的思想和Dijkstra算法是一样的。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string&amp; s1, string&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = s<span class="number">1.l</span>ength();</span><br><span class="line">        <span class="type">int</span> len2 = s<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">if</span>(len1<span class="number">+1</span>!=len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string&amp; w1, string&amp; w2)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> w<span class="number">1.l</span>ength()&lt;w<span class="number">2.l</span>ength();</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">canChange</span>(words[i], words[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lcnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = lcnt[j]<span class="number">+1</span>;</span><br><span class="line">                    lcnt[i] = <span class="built_in">max</span>(tmp, lcnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(lcnt.<span class="built_in">begin</span>(), lcnt.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-最后一块石头的重量-II"><a href="#4-最后一块石头的重量-II" class="headerlink" title="4. 最后一块石头的重量 II"></a>4. 最后一块石头的重量 II</h2><p><strong>题目：</strong></p><p>最后一块石头的重量 II(Last Stone Weight II)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight-ii/">https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight-ii/</a></p><p><strong>题意：</strong></p><blockquote><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p></blockquote><p><strong>思路：</strong></p><p>和第一题的题意只有一句差别，就是每次拿石头是「任意」的。问最后能消掉剩余的最小值是多少。</p><p>一般最开始可能想到用贪心，但实际上没有这种算法的。</p><p>由于石头碎掉之后还能放回去，类似于把石头分成两堆来看。只要依次拿两堆的石头互相粉碎，最后剩下的就是最小整数。</p><p>最多有100个石头，每个石头最多300的重量。所以两个集合最大的差值不会超过30000。</p><p>用数组构造结果。</p><p>在加入第n个石头重量为m时，查找n-1个石头能够组成的两堆石头的差值的绝对值为diff。</p><p>该石头两个选择，放入多的堆，则差值更大，为diff+m；<br>放入小的堆，则差值为|diff-m|。这时更新n个石头能组成的所有重量。</p><p>最后输出最后一个石头能组成的最小重量即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diff[<span class="number">101</span>][<span class="number">30001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        diff[<span class="number">0</span>][stones[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum;++j)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>(diff[i<span class="number">-1</span>][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    diff[i][j+stones[i]] = <span class="number">1</span>;</span><br><span class="line">                    diff[i][<span class="built_in">abs</span>(j-stones[i])] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diff[n<span class="number">-1</span>][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的比赛的题目相对来说比较「直白」，不像前几周都是一些特定的算法，如果你没学过不可能想出来。&lt;/p&gt;
&lt;p&gt;做了这些周，对leetcode比赛的题目也发现了一些「规律」。 &lt;strong&gt;一般前两道题都很「简单」&lt;/strong&gt;，只要有想法，直接敲代码就能解出来。更多考</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第138场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC138%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC138%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>今天的比赛的题目难度没有区分开，考察的不是很全面。题目描述也有些晦涩，考察的点却很简单。</p><p>例如第1题题目描述的让人看不清，看懂后发现就是考察个排序，真不知道这种题目出来有什么用途。面试中肯定不会出这种题。</p><p>第3题的用例也是错的，为了过掉题目，还要按照「错误的解」来修改程序。</p><p>做题的时候还有个插曲，外面下雨了，出去收了会衣服。回来还有时间把所有题目都AC掉。建议后面的比赛要难易结合，考点尽量宽泛些。</p><p>不过站在leetcode的角度来说，众口难调，组织这么多次比赛，偶尔出现几次问题也正常，希望后面的比赛越办越好。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 138</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-138">https://leetcode-cn.com/contest/weekly-contest-138</a></p><h2 id="1-高度检查器"><a href="#1-高度检查器" class="headerlink" title="1. 高度检查器"></a>1. 高度检查器</h2><p><strong>题目：</strong></p><p>高度检查器(Height Checker)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-138/problems/height-checker/">https://leetcode-cn.com/contest/weekly-contest-138/problems/height-checker/</a></p><p><strong>题意：</strong></p><blockquote><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p><p>请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。<br>输入：[1,1,4,2,1,3]<br>输出：3<br>解释：<br>高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。</p></blockquote><p><strong>思路：</strong><br>本质就是求一个数组，排序后，要有多少个位置的数字不在从前的位置上。</p><p>排序后比较即可，代码很简单。</p><p>这题在做的时候以为是最少移动次数呢，例如输入[5,1,2,3,4]，可以把5直接放到最后。如果是这样的话题目难度就增加了，有兴趣可以再想想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(heights)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i]!=heights[i])</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-爱生气的书店老板"><a href="#2-爱生气的书店老板" class="headerlink" title="2. 爱生气的书店老板"></a>2. 爱生气的书店老板</h2><p><strong>题目：</strong></p><p>爱生气的书店老板(Grumpy Bookstore Owner)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-138/problems/grumpy-bookstore-owner/">https://leetcode-cn.com/contest/weekly-contest-138/problems/grumpy-bookstore-owner/</a></p><p><strong>题意：</strong></p><p>给出两个长度都为n的数组customers和grumpy，grumpy每个元素只能是0或1，最后求和sum为</p><p>sum&#x3D;customers[i]*（1-grumpy[i] ） (0 &lt;&#x3D; i &lt; n)</p><p>然后给定一个数X（1&lt;&#x3D;X&lt;&#x3D;n）,可以把grumpy数组中连续X长度的元素的值从1变为0。问在确定X值后sum的最大值是多少？</p><p><strong>思路：</strong></p><p>上面的题意是我翻译的，实际上原题用的老板和顾客，还有生气值。有点和生活脱节，不是很好理解。</p><p>如果理解了题意，题目的做法就大概知道了。</p><p>先计算出来没有X时的原始sum值。然后使用一个长度X的区间，在customers数组从前到后扫描n-X次。更新每个扫描区间增加的值，增加的最大值和sum的原始值相加，就是结果。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; customers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            sum += customers[i]*(<span class="number">1</span>-grumpy[i]);</span><br><span class="line">        <span class="type">int</span> delt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; X; ++i)</span><br><span class="line">            delt += customers[i]*grumpy[i];</span><br><span class="line">        <span class="type">int</span> dt = delt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = X; i &lt; customers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dt += customers[i]*grumpy[i] - customers[i-X]*grumpy[i-X];</span><br><span class="line">            delt = <span class="built_in">max</span>(dt, delt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + delt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-交换一次的先前排列"><a href="#3-交换一次的先前排列" class="headerlink" title="3. 交换一次的先前排列"></a>3. 交换一次的先前排列</h2><p><strong>题目：</strong></p><p>交换一次的先前排列(Previous Permutation With One Swap)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-138/problems/previous-permutation-with-one-swap/">https://leetcode-cn.com/contest/weekly-contest-138/problems/previous-permutation-with-one-swap/</a></p><p><strong>题意：</strong></p><blockquote><p>给你一个正整数的数组 <code>A</code>（其中的元素不一定完全不同），请你返回可在 <strong>一次交换</strong>（交换两数字 <code>A[i]</code> 和 <code>A[j]</code> 的位置）后得到的、按字典序排列小于 <code>A</code> 的最大可能排列。</p><p>如果无法这么操作，就请返回原数组。</p><p><strong>示例 4：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路：</strong></p><p>题目简单直白，题意也比较好理解。直交换两个数值，得到小于当前字典序的集合中，最大的那个字典序排列。</p><p>简直是把题目又复述了一遍。</p><p>处理方式为：</p><p>第一步：从当前序列的后往前找，找到第一个降序的位置（A[i]&gt;A[i+1]），则必存在能构造比当前小的序列。</p><p>第二步：把A[i]后面的数字中，小于A[i]且最接近A[i]的值的数字找出来，和A[i]交换。</p><p>为什么第一步不再往前找，因为往前找更换，会让小的值出现在高位，导致不是最大字典序。</p><p>为什么第二步要找最接近的且小的，因为大的更换就超过当前序列，只能找小的。从小的里面找个最大值更换才能字典序最大，且不会超过当前序。</p><p>题目中的示例4是有问题的，答案应该是比[3,1,1,3]小的最大字典序是[1,3,1,3]，而不是[1,1,3,3]。</p><p>但是为了把题目过了，只能把18行改为<code>if(A[i]&gt;=A[t] &amp;&amp; A[i]&lt;A[f])</code>，多加个等号。</p><p>因为可能是官方生成用例的时候也多加个等号，做题还要考虑官方的思路。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">+1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                f = i;</span><br><span class="line">                t = f<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = f<span class="number">+2</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=A[t] &amp;&amp; A[i]&lt;A[f])<span class="comment">//如果题目修改了，把&gt;=换成&gt;即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(A[f],A[t]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-距离相等的条形码"><a href="#4-距离相等的条形码" class="headerlink" title="4. 距离相等的条形码"></a>4. 距离相等的条形码</h2><p><strong>题目：</strong></p><p>距离相等的条形码(Distant Barcodes)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-138/problems/distant-barcodes/">https://leetcode-cn.com/contest/weekly-contest-138/problems/distant-barcodes/</a></p><p><strong>题意：</strong></p><blockquote><p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p><p>请你重新排列这些条形码，使其中两个相邻的条形码 <strong>不能</strong> 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p></blockquote><p><strong>思路：</strong></p><p>数组的已有元素重新排列，保证相邻元素不相同。由于题目保证存在答案，直接用贪心的方法就可以实现。</p><p>先统计出每个元素的个数，按照个数排序分配。按元素个数多少，从头到尾间隔放到数组的偶数下标位置中。然后第二轮把剩余元素放到奇数下标，构造出最后答案。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = barcodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m : barcodes)</span><br><span class="line">            cnt[m]++;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&gt;<span class="number">0</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(&#123;cnt[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( i=k ; i &lt; n; i+=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[j].first == <span class="number">0</span>)</span><br><span class="line">                    --j;</span><br><span class="line">                ans[i] = v[j].second;</span><br><span class="line">                --v[j].first;</span><br><span class="line">            &#125;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的比赛的题目难度没有区分开，考察的不是很全面。题目描述也有些晦涩，考察的点却很简单。&lt;/p&gt;
&lt;p&gt;例如第1题题目描述的让人看不清，看懂后发现就是考察个排序，真不知道这种题目出来有什么用途。面试中肯定不会出这种题。&lt;/p&gt;
&lt;p&gt;第3题的用例也是错的，为了过掉题目，还要</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第139场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC139%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC139%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>今天的比赛考固定算法的不多，只有最后一道动态规划的题目稍难一点。其他的题目花些心思，也可以想出来。在面试中如果考察一个人的脑力，前三道题目比较好。都能答出来一些，但是也有优化的空间。</p><p>第三题用了很多时间，导致第四题时间都不够了。做比赛和工程还是有差别，应该有思路就敲代码，先把题目过了再说，一些细节不用考虑太多。有些地方不优化也可以过掉。但是在工程上就要考究些，因为代码是在服务器24小时跑，能优化一点点，在海量服务中也能节省很多计算资源。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 139</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-139">https://leetcode-cn.com/contest/weekly-contest-139</a></p><h2 id="1-字符串的最大公因子"><a href="#1-字符串的最大公因子" class="headerlink" title="1. 字符串的最大公因子"></a>1. 字符串的最大公因子</h2><p><strong>题目：</strong></p><p>字符串的最大公因子(Greatest Common Divisor of Strings)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-139/problems/greatest-common-divisor-of-strings/">https://leetcode-cn.com/contest/weekly-contest-139/problems/greatest-common-divisor-of-strings/</a></p><p><strong>题意：</strong></p><blockquote><p>对于字符串 S 和 T，只有在 S &#x3D; T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p></blockquote><p><strong>思路：</strong></p><p>返回的公共字符串X就是经过n1次重复为Str1，经过n2次重复为Str2的最长字符串。</p><p>那么X一定是S和T的公共前缀字符串的子串。</p><p>先计算出S和T的公共前缀字符串str，然后从str的最长前缀到最短前缀依次判断，是否满足能「除尽」str1和str2。</p><p>要求的X的字符串长度，一定是str1和str2长度的公约数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStr</span><span class="params">(string &amp; str1, string &amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = str<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len1%len2!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> repeat = len1/len2;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span>(repeat--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp == str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> len1 = str<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1 &amp;&amp; i &lt; len2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                str.<span class="built_in">push_back</span>(str1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> b1 = <span class="built_in">isSubStr</span>(str1, str);</span><br><span class="line">            <span class="type">bool</span> b2 = <span class="built_in">isSubStr</span>(str2, str);</span><br><span class="line">            <span class="keyword">if</span>(b1 &amp;&amp; b2)</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-按列翻转得到最大值等行数"><a href="#2-按列翻转得到最大值等行数" class="headerlink" title="2. 按列翻转得到最大值等行数"></a>2. 按列翻转得到最大值等行数</h2><p><strong>题目：</strong></p><p>按列翻转得到最大值等行数(Flip Columns For Maximum Number of Equal Rows)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-139/problems/flip-columns-for-maximum-number-of-equal-rows/">https://leetcode-cn.com/contest/weekly-contest-139/problems/flip-columns-for-maximum-number-of-equal-rows/</a></p><p><strong>题意：</strong></p><blockquote><p>给定由若干 0 和 1 组成的矩阵 matrix，从中选出任意数量的列并翻转其上的 每个 单元格。翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。</p><p>返回经过一些翻转后，行上所有值都相等的最大行数。</p></blockquote><p><strong>思路：</strong></p><p>两行数字，经过对一些列的反转，最后都达到这一行的值相同。那么这两行数字的关系有两种情况：</p><ol><li>两行数字的值都相同；</li><li>两行数字的值都相反；</li></ol><p>其他任何情况，一定有一列始终都不满足相等。</p><p>所以题目的结果为看满足两种情况的行的集合最多有多少？</p><p>只要两两枚举就能算出来，曾经加入过其他集合的可以后面就不比较了。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> k;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(a[i][k]+a[j][k]!=<span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k==n)</span><br><span class="line">                        tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-负二进制数相加"><a href="#3-负二进制数相加" class="headerlink" title="3. 负二进制数相加"></a>3. 负二进制数相加</h2><p><strong>题目：</strong></p><p>负二进制数相加(Adding Two Negabinary Numbers)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-139/problems/adding-two-negabinary-numbers/">https://leetcode-cn.com/contest/weekly-contest-139/problems/adding-two-negabinary-numbers/</a></p><p><strong>题意：</strong></p><blockquote><p>给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。</p><p>数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr &#x3D; [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 &#x3D; -3。数组形式 的数字也同样不含前导零：以 arr 为例，这意味着要么 arr &#x3D;&#x3D; [0]，要么 arr[0] &#x3D;&#x3D; 1。</p><p>返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p></blockquote><p><strong>思路：</strong></p><p>-2进制的算法和2进制算法是一样的。都是先模-2得到当前位的值，然后再除-2得到高位的进位值。</p><p>但是由于题目中要求每位必须是0或者是1，所以在模-2等于-1时，要进行特殊处理。</p><p>如果取模的结果是-1表示当前位的值为-1，要变成正数才能正常表示。要把当前位变为1，要把除数加1。</p><p>如果想不明白，请思考下公式 <code>(x*-2)+(-1) = (x-1)*-2 + 1</code>。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addNegabinary</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = arr<span class="number">2.</span><span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> divid = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>||carry)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">                carry += arr1[i];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">                carry += arr2[j];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mod = carry % divid;</span><br><span class="line">            carry /= divid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(mod &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mod -= divid;</span><br><span class="line">                carry += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(mod);</span><br><span class="line">            </span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">back</span>()==<span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-元素和为目标值的子矩阵数量"><a href="#4-元素和为目标值的子矩阵数量" class="headerlink" title="4. 元素和为目标值的子矩阵数量"></a>4. 元素和为目标值的子矩阵数量</h2><p><strong>题目：</strong></p><p>元素和为目标值的子矩阵数量(Number of Submatrices That Sum to Target)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-139/problems/number-of-submatrices-that-sum-to-target/">https://leetcode-cn.com/contest/weekly-contest-139/problems/number-of-submatrices-that-sum-to-target/</a></p><p><strong>题意：</strong></p><blockquote><p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p><p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;&#x3D; x &lt;&#x3D; x2 且 y1 &lt;&#x3D; y &lt;&#x3D; y2 的所有单元 <code>matrix[x][y]</code> 的集合。</p><p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 !&#x3D; x1’），那么这两个子矩阵也不同。</p></blockquote><p><strong>思路：</strong></p><p>先对每行数据进行处理，求出每行开始到当前位置的和。<code>sum[i][j] = matrix[i][0]+matrix[i][0]+...+matrix[i][j]</code>。</p><p>这样一行中j，k两个之间的区间和可以表示为<code>sum[i][j]-sum[i][k-1]</code>，很快能求出。</p><p>之后枚举两列c1,c2，对于每一次枚举，行数从上到下扫描。</p><p>每扫描到一行r1，先计算出当前行与两列，还有第0行形成的矩阵的和S。</p><p>然后查找是否有之前的行r0的和为S-target。</p><p>如果有，则r0，r1，c1，c2形成的和为target。</p><p>最后再把S存起来，留给后面的行扫描时查找。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i][j] += matrix[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; n; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                mp.<span class="built_in">clear</span>();</span><br><span class="line">                mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                        sum += matrix[i][k] - matrix[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sum += matrix[i][k];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(mp.<span class="built_in">find</span>(sum-target)!=mp.<span class="built_in">end</span>())</span><br><span class="line">                        ans += mp[sum-target];</span><br><span class="line">                    </span><br><span class="line">                    mp[sum]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的比赛考固定算法的不多，只有最后一道动态规划的题目稍难一点。其他的题目花些心思，也可以想出来。在面试中如果考察一个人的脑力，前三道题目比较好。都能答出来一些，但是也有优化的空间。&lt;/p&gt;
&lt;p&gt;第三题用了很多时间，导致第四题时间都不够了。做比赛和工程还是有差别，应该有思</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第140场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC140%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC140%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<p>今天的题目难度适中。第二道题计算排列数，实际上是有优化方法的，但是题目的测试数据比较宽松，暴力就可以过掉。</p><p>今天比赛的主题可以归纳为「暴力」，都用最直白，最直接的方法，都可以过掉题目。</p><p>在实际编程工作中，大多数是把一个模型实现为程序，用所谓「直白」的方法。</p><p>有一种方法论，叫做先实现，再优化。先想办法实现，保证正确性，然后再逐渐优化，让性能越来越好。性能优化到什么样才停止呢？满足当前要求就可以停止。因为性能优化也是要付出代价和成本的，「够用」最好。当然要有技术储备，当需要进一步优化的时候能够立刻去做。</p><p>做比赛也是一样，能够在有限的时间内，在题目的要求下，过掉题目是最好的。至于最优算法，可以比赛结束后慢慢研究。</p><p>上面的方法论第一步有时也叫做原型。做原型类似于做个demo，用现有工具快速实现。在语言侧python有很大优势，库很全。既有类似shell的语法简洁功能强大，又有类似C的语法约束，不至于看不懂。缺点当然是性能了。但是能够让人专注于实现逻辑，本身已经很强大了。</p><p>例如许多字符串操作，像把文本按空格分成单词，在python中只要一句话，这些在C++中就只能干捉急了，没个三五行，再加上些检查和约束，根本写不出来。</p><p>语言都是工具，没有高低贵贱之分，要看应用场景。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 140</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-140">https://leetcode-cn.com/contest/weekly-contest-140</a></p><h2 id="1-Bigram-分词"><a href="#1-Bigram-分词" class="headerlink" title="1. Bigram 分词"></a>1. Bigram 分词</h2><p><strong>题目：</strong></p><p>Bigram 分词(Occurrences After Bigram)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-140/problems/occurrences-after-bigram/">https://leetcode-cn.com/contest/weekly-contest-140/problems/occurrences-after-bigram/</a></p><p><strong>题意：</strong></p><blockquote><p>给出第一个词 <code>first</code> 和第二个词 <code>second</code>，考虑在某些文本 <code>text</code> 中可能以 “<code>first second third</code>“ 形式出现的情况，其中 <code>second</code> 紧随 <code>first</code> 出现，<code>third</code> 紧随 <code>second</code> 出现。</p><p>对于每种这样的情况，将第三个词 “<code>third</code>“ 添加到答案中，并返回答案。</p></blockquote><p><strong>思路：</strong></p><p>题目比较直白，就是给出两个单词，和一段文本，让返回所有的出现在这两个单词组成的短语后挨着的第三个单词。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">输出：[&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure><p>把两个单词先拼成一个短语，然后在文本中查找该短语。找到后，输出短语后的下一个单词。然后从上次查找到的短语的尾部继续上面的操作，直至找到文本结尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findOcurrences</span><span class="params">(string text, string first, string second)</span> </span>&#123;</span><br><span class="line">        string str = first + <span class="string">&quot; &quot;</span> + second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string::size_type start = <span class="number">0</span>;</span><br><span class="line">        string::size_type pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((pos = text.<span class="built_in">find</span>(str, start))!=text.npos)</span><br><span class="line">        &#123;</span><br><span class="line">            string::size_type spacepos = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pos + str.<span class="built_in">length</span>());</span><br><span class="line">            string tmp = text.<span class="built_in">substr</span>(pos + str.<span class="built_in">length</span>(), spacepos - (pos + str.<span class="built_in">length</span>()));</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            start = pos + str.<span class="built_in">length</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-活字印刷"><a href="#2-活字印刷" class="headerlink" title="2. 活字印刷"></a>2. 活字印刷</h2><p><strong>题目：</strong></p><p>活字印刷(Letter Tile Possibilities)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-140/problems/letter-tile-possibilities/">https://leetcode-cn.com/contest/weekly-contest-140/problems/letter-tile-possibilities/</a></p><p><strong>题意：</strong></p><blockquote><p>你有一套活字字模 <code>tiles</code>，其中每个字模上都刻有一个字母 <code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;AAB&quot;</span><br><span class="line">输出：8</span><br><span class="line">解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路：</strong></p><p>给定一个字母集合，然后求用这些字母，可以组成的字母排列的个数。</p><p>这是一道数学题，如果用手算，最好的方法是计算出全排列的数量，然后再除以每个重复的排列个数。例如”AAABBC”组成的6个字母的排列数为A（6，6）&#x2F;[A(3,3)*A(2,2)]。</p><p>但是做这个题目用这个方法有点难写，最简单的方法，就是枚举所有的排列，然后汇总结果。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt; width)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = mp.<span class="built_in">begin</span>(); iter!=mp.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> key = iter-&gt;first;</span><br><span class="line">            <span class="type">int</span> value = iter-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            iter-&gt;second--;</span><br><span class="line">            sum += <span class="built_in">dfs</span>(width, pos<span class="number">+1</span>);</span><br><span class="line">            iter-&gt;second++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTilePossibilities</span><span class="params">(string tiles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : tiles)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tiles.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">            res += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-根到叶路径上的不足节点"><a href="#3-根到叶路径上的不足节点" class="headerlink" title="3. 根到叶路径上的不足节点"></a>3. 根到叶路径上的不足节点</h2><p><strong>题目：</strong></p><p>根到叶路径上的不足节点(Insufficient Nodes in Root to Leaf Paths)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-140/problems/insufficient-nodes-in-root-to-leaf-paths/">https://leetcode-cn.com/contest/weekly-contest-140/problems/insufficient-nodes-in-root-to-leaf-paths/</a></p><p><strong>题意：</strong></p><blockquote><p>给定二叉树的根 <code>root</code>，考虑所有<strong>从根到叶的路径</strong>：从根到任何叶的路径。 （叶节点是没有子节点的节点。）</p><p>如果交于节点 <code>node</code> 的<strong>每个</strong>根到叶路径的总和严格小于限制 <code>limit</code>，则该节点为不足节点。</p><p>同时删除所有不足节点，并返回生成的二叉树的根。</p></blockquote><p><strong>思路：</strong></p><p>题目的意思是，从根节点到每个叶子节点所经过的路径的节点和，如果大于等于limit，则这条路径上所有的节点都留下来。最终没留下来的节点删掉。</p><p>如果这样理解题意，做起来会简单些。</p><p>方法一：</p><p>最简单的方法，进行深度优先搜索，例如先序遍历。到达叶节点，统计从根到叶子所经过的路径和。如果大于limit则把路径经过的节点都染色「保留」，否则染色「删除」。</p><p>最后保存所有「保留」的节点，就是答案。</p><p>方法一最好想，也容易实现，但是要辅助存储和经过两次遍历。对于这道题是可以过掉的。</p><p>在方法一的基础上可以优化下，达到一次遍历就能够得到最终结果。</p><p>对于一个节点，最终是否要删掉，满足的条件是：所有经过该节点的路径和都是小于limit的。</p><p>虽然有多个子节点，有多条路径，但是我们只要考虑和最大的哪条路径是否小于limit就可以了。因为只要有一条路径大于等于limit的值，就可以保留该节点。</p><p>方法二：</p><p>采用后序遍历，父节点到该节点的路径和，获取左右两个儿子节点路径和的最大值。求出经过该节点的路径和的最大值，如果最大值小于limit，则让父节点删掉当前节点，否则让父节点保留当前节点。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;TreeNode* , <span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> limit, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        pair&lt;TreeNode* , <span class="type">int</span>&gt; l, r;</span><br><span class="line">        l = <span class="built_in">dfs</span>(root-&gt;left, limit, sum+root-&gt;val);</span><br><span class="line">        r = <span class="built_in">dfs</span>(root-&gt;right,limit, sum+root-&gt;val);</span><br><span class="line">        root-&gt;left = l.first;</span><br><span class="line">        root-&gt;right = r.first;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxsum = <span class="built_in">max</span>(l.second, r.second);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxsum + sum + root-&gt;val &lt; limit)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, maxsum + root-&gt;val&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;root, maxsum + root-&gt;val&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        pair&lt;TreeNode* , <span class="type">int</span>&gt; ans;</span><br><span class="line">        ans = <span class="built_in">dfs</span>(root, limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-不同字符的最小子序列"><a href="#4-不同字符的最小子序列" class="headerlink" title="4. 不同字符的最小子序列"></a>4. 不同字符的最小子序列</h2><p><strong>题目：</strong></p><p>不同字符的最小子序列(Smallest Subsequence of Distinct Characters)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-140/problems/smallest-subsequence-of-distinct-characters/">https://leetcode-cn.com/contest/weekly-contest-140/problems/smallest-subsequence-of-distinct-characters/</a></p><p><strong>题意：</strong></p><blockquote><p>返回字符串 <code>text</code> 中按字典序排列最小的子序列，该子序列包含 <code>text</code> 中所有不同字符一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;cdadabcc&quot;</span><br><span class="line">输出：&quot;adbc&quot;</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路：</strong></p><p>用贪心的方法。</p><p>对于每个text中的字符，如果该字符已经出现在最终的结果中，则不必再处理。</p><p>对于还没出现在最终结果中的字符<code>text[i]</code>。如果该字符只剩下一个，那么该字符要马上加入到结果中。如果该字符还有多个，那么查看在该字符右侧出现的字符中，是否有小于该字符的字符<code>text [ j ] (j &gt; i)</code> 出现。如果选择text[j]作为本轮输出的字符，还要满足在i到j-1中所有未出现在结果的字符的数量，都要是大于1的。否则不能满足相对顺序和text中的一致。因为如果小于等于1，在j的右侧，就不会再有该字符出现了，那么最终结果也不会包含该字符了。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(string text, <span class="type">int</span> startpos, <span class="type">int</span> n, string cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch=<span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = startpos; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[text[i]] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(text[i]&lt;ch)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = text[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[text[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(mp[text[i]]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = pos + <span class="number">1</span>; j &lt;=i; ++j)</span><br><span class="line">                    <span class="keyword">if</span>(mp[text[j]]!=<span class="number">-1</span>)</span><br><span class="line">                        mp[text[j]]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        mp[ch] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(text, pos<span class="number">+1</span>, n, cur+ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : text)</span><br><span class="line">            mp[ch]++;</span><br><span class="line">        string res;</span><br><span class="line">        res = <span class="built_in">dfs</span>(text, <span class="number">0</span>, text.<span class="built_in">size</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的题目难度适中。第二道题计算排列数，实际上是有优化方法的，但是题目的测试数据比较宽松，暴力就可以过掉。&lt;/p&gt;
&lt;p&gt;今天比赛的主题可以归纳为「暴力」，都用最直白，最直接的方法，都可以过掉题目。&lt;/p&gt;
&lt;p&gt;在实际编程工作中，大多数是把一个模型实现为程序，用所谓「直白</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第157场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC157%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC157%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写解题报告了，今天做了一下比赛，这场比赛的题目比较简单。一二题代码很短，题意明白会很快写完，第三题看着很难，但是测试数据简单，直接暴力就可以过。</p><p>第四题也是一道简单的动态规划题，只是模拟规则比较复杂。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 157</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-157">https://leetcode-cn.com/contest/weekly-contest-157</a></p><h2 id="1-玩筹码"><a href="#1-玩筹码" class="headerlink" title="1. 玩筹码"></a>1. 玩筹码</h2><p><strong>题目：</strong></p><p>玩筹码(Play with Chips)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-157/problems/play-with-chips/">https://leetcode-cn.com/contest/weekly-contest-157/problems/play-with-chips/</a></p><p><strong>题意：</strong></p><blockquote><p>数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。</p><p>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：</p><p>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。<br>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。<br>最开始的时候，同一位置上也可能放着两个或者更多的筹码。</p><p>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。<br>示例 1：</p><p>输入：chips &#x3D; [1,2,3]<br>输出：1<br>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</p></blockquote><p><strong>思路：</strong></p><p>所有奇数位的筹码，经过多次移动两格都能移动到坐标1位置，所有偶数位筹码都能移动到坐标0位置。<br>最后合成一堆的时候，最小代价就是坐标0或1筹码的总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; chips)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : chips)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                a++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-最长定差子序列"><a href="#2-最长定差子序列" class="headerlink" title="2. 最长定差子序列"></a>2. 最长定差子序列</h2><p><strong>题目：</strong></p><p>最长定差子序列(Longest Arithmetic Subsequence of Given Difference)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-157/problems/longest-arithmetic-subsequence-of-given-difference/">https://leetcode-cn.com/contest/weekly-contest-157/problems/longest-arithmetic-subsequence-of-given-difference/</a></p><p><strong>题意：</strong></p><blockquote><p>给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。</p><p>示例 1：</p><p>输入：arr &#x3D; [1,2,3,4], difference &#x3D; 1<br>输出：4<br>解释：最长的等差子序列是 [1,2,3,4]。</p></blockquote><p><strong>思路：</strong><br>只需要三个元素：等差差值，数列长度，等差数列最后一个数的大小，就可以表示一个等差数列。</p><p>对于整数数组arr遍历，对于每个arr[i]，设arr[i]-diff表示的等差数列长度为m，则arr[i]表示的等差数列大小为m+1。<br><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> diff)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[n]=mp[n-diff]<span class="number">+1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mp[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-黄金矿工"><a href="#3-黄金矿工" class="headerlink" title="3. 黄金矿工"></a>3. 黄金矿工</h2><p><strong>题目：</strong></p><p>黄金矿工(Path with Maximum Gold)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-157/problems/path-with-maximum-gold/">https://leetcode-cn.com/contest/weekly-contest-157/problems/path-with-maximum-gold/</a></p><p><strong>题意：</strong></p><blockquote><p>在一个m*n的地图中，每个格子都用个整数表示，为0的格子不能走，只能走正整数的格子，只能上下左右相邻格子移动，移动过的格子不能再回头经过。<br>要求移动路径和最大的值是多少。</p><p>1 &lt;&#x3D; grid.length, grid[i].length &lt;&#x3D; 15<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100<br>最多 25 个单元格是正整数。</p></blockquote><p><strong>思路：</strong></p><p>由于题目的测试数据很简单，直接暴力深搜就能过。还可以做下记忆化搜索，搜过的位置和状态下次直接返回。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dirx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> diry[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; pos2num;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calHash</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        hash = pos2num[&#123;r, c&#125;];</span><br><span class="line">        hash &lt;&lt;= N;</span><br><span class="line">        hash |= status;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash = <span class="built_in">calHash</span>(r, c, status);</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(hash)!=memo.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> memo[hash];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> value = grid[r][c];</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = dirx[i]+r;</span><br><span class="line">            <span class="type">int</span> y = diry[i]+c;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;grid.<span class="built_in">size</span>()&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;grid[x].<span class="built_in">size</span>()&amp;&amp;grid[x][y]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[r][c] = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="built_in">dfs</span>(x, y, grid, status | (<span class="number">1</span>&lt;&lt;pos2num[&#123;x, y&#125;]));</span><br><span class="line">                ret = <span class="built_in">max</span>(tmp, ret);</span><br><span class="line">                grid[r][c] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[hash] = ret + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaximumGold</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &amp;&amp; pos2num.<span class="built_in">find</span>(&#123;i, j&#125;) == pos2num.<span class="built_in">end</span>())</span><br><span class="line">                    pos2num[&#123;i, j&#125;] = N++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> status = <span class="number">1</span> &lt;&lt; pos2num[&#123;i, j&#125;];</span><br><span class="line">                    <span class="type">int</span> get = <span class="built_in">dfs</span>(i, j, grid, status);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, get);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-统计元音字母序列的数目"><a href="#4-统计元音字母序列的数目" class="headerlink" title="4. 统计元音字母序列的数目"></a>4. 统计元音字母序列的数目</h2><p><strong>题目：</strong></p><p>统计元音字母序列的数目(Count Vowels Permutation)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-157/problems/count-vowels-permutation/">https://leetcode-cn.com/contest/weekly-contest-157/problems/count-vowels-permutation/</a></p><p><strong>题意：</strong></p><blockquote><p>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：</p><p>字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）<br>每个元音 ‘a’ 后面都只能跟着 ‘e’<br>每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’<br>每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’<br>每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’<br>每个元音 ‘u’ 后面只能跟着 ‘a’<br>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。</p></blockquote><p><strong>思路：</strong></p><p>典型的动态规划，长度为n的字符串的个数可以从n-1长度字符串的个数中计算出来。</p><p>例如：长度为n-1的以a结尾的字符串，可以转换成长度为n的以’e’结尾的字符串。</p><p>通过搜索枚举出所有符合要求的字符串，每个加一，最后记忆搜索即可。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, vector&lt;<span class="type">char</span>&gt;&gt; relation;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; letter = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    map&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;, <span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(&#123;i, ch&#125;)!=memo.<span class="built_in">end</span>())</span><br><span class="line">           <span class="keyword">return</span> memo[&#123;i, ch&#125;];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : relation[ch])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(i<span class="number">+1</span>, n, c);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[&#123;i, ch&#125;] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        relation[<span class="string">&#x27;a&#x27;</span>] = &#123;<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;e&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;i&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;o&#x27;</span>] = &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;u&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : letter)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(<span class="number">1</span>, n, ch);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有写解题报告了，今天做了一下比赛，这场比赛的题目比较简单。一二题代码很短，题意明白会很快写完，第三题看着很难，但是测试数据简单，直接暴力就可以过。&lt;/p&gt;
&lt;p&gt;第四题也是一道简单的动态规划题，只是模拟规则比较复杂。&lt;/p&gt;
&lt;p&gt;下面是详细的题解和思考。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第158场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC158%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC158%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<p>这场比赛不需要太多特定的算法，只要能把问题分析清楚，认真思考，就能够解决掉。几个题目都非常适合当面试题。</p><p>下面是详细的题解和思考。</p><hr><p>比赛的地址 Weekly Contest 158</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-158">https://leetcode-cn.com/contest/weekly-contest-158</a></p><h2 id="1-分割平衡字符串"><a href="#1-分割平衡字符串" class="headerlink" title="1. 分割平衡字符串"></a>1. 分割平衡字符串</h2><p><strong>题目：</strong></p><p>分割平衡字符串(Split a String in Balanced Strings)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-158/problems/split-a-string-in-balanced-strings/">https://leetcode-cn.com/contest/weekly-contest-158/problems/split-a-string-in-balanced-strings/</a></p><p><strong>题意：</strong></p><blockquote><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p><p>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p><p>返回可以通过分割得到的平衡字符串的最大数量。</p><p>示例 1：</p><p>输入：s &#x3D; “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p></blockquote><p><strong>思路：</strong></p><p>只要保证R和L的数目相同，就是一个平衡字符串。所以从头遍历，符合平衡就计数，最终遍历完就贪心出答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">balancedStringSplit</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-可以攻击国王的皇后"><a href="#2-可以攻击国王的皇后" class="headerlink" title="2. 可以攻击国王的皇后"></a>2. 可以攻击国王的皇后</h2><p><strong>题目：</strong></p><p>可以攻击国王的皇后(Queens That Can Attack the King)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-158/problems/queens-that-can-attack-the-king/">https://leetcode-cn.com/contest/weekly-contest-158/problems/queens-that-can-attack-the-king/</a></p><p><strong>题意：</strong></p><blockquote><p>在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p><p>「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。</p><p>「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。</p><p>请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。</p></blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-2.jpg" alt="可以攻击国王的皇后的例子"></p><p><strong>思路：</strong></p><p>上图红色的就是符合答案的「黑皇后」。</p><p>题目可以利用逆向思维，「白国王」所在的位置，遍历横竖斜八个方向，第一次碰到的「黑皇后」就是答案。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> q : queens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = q[<span class="number">1</span>];</span><br><span class="line">            v[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = king[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y = king[<span class="number">1</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = x;</span><br><span class="line">            <span class="type">int</span> c = y;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r+=dir[i][<span class="number">0</span>];</span><br><span class="line">                c+=dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r&lt;<span class="number">8</span>&amp;&amp;r&gt;=<span class="number">0</span>&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;<span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(v[r][c]==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;r, c&#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-掷骰子模拟"><a href="#3-掷骰子模拟" class="headerlink" title="3. 掷骰子模拟"></a>3. 掷骰子模拟</h2><p><strong>题目：</strong></p><p>掷骰子模拟(Dice Roll Simulation)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-158/problems/dice-roll-simulation/">https://leetcode-cn.com/contest/weekly-contest-158/problems/dice-roll-simulation/</a></p><p><strong>题意：</strong></p><blockquote><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。</p><p>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。</p><p>输入：n &#x3D; 2, rollMax &#x3D; [1,1,2,2,2,3]</p><p>输出：34</p><p>解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 &#x3D; 36 种可能的组合。</p><p>但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。</p><p>因此，最终答案是 36-2 &#x3D; 34。</p></blockquote><p><strong>思路：</strong></p><p>可以换种方式理解，要形成一个n长度的数字字符串，包括1-6这几个数字。每种数字要求连续不能超过rollMax的数量。</p><p>可以利用递归构造出符合要求的数字，构造出一次就加一。从第一位开始构造，一直构造到第n位后结束。</p><p>构造当前位时，需要知道前一位数字是什么，以及这个数字累积连续了几次。</p><p>所以递归函数需要三个参数，当前要构造的位序号，上一位数字，上一位数字连续出现的次数。</p><p>最后用记忆化搜索优化。</p><p>ps：一种通用的解法叫数位dp，本题比较简单，还可以构造更复杂的题目。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">5001</span>][<span class="number">7</span>][<span class="number">16</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> pre, <span class="type">int</span> state, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; rollMax)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == n<span class="number">+1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[index][pre][state]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[index][pre][state];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==pre<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rollMax[i]==state)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="built_in">dfs</span>(index<span class="number">+1</span>, i<span class="number">+1</span>, state<span class="number">+1</span>, n, rollMax), ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += <span class="built_in">dfs</span>(index<span class="number">+1</span>, i<span class="number">+1</span>, <span class="number">1</span>, n, rollMax) % MOD, ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[index][pre][state]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dieSimulator</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; rollMax)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="built_in">sizeof</span>(memo));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, n, rollMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-最大相等频率"><a href="#4-最大相等频率" class="headerlink" title="4. 最大相等频率"></a>4. 最大相等频率</h2><p><strong>题目：</strong></p><p>最大相等频率(Maximum Equal Frequency)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-158/problems/maximum-equal-frequency/">https://leetcode-cn.com/contest/weekly-contest-158/problems/maximum-equal-frequency/</a></p><p><strong>题意：</strong></p><blockquote><p>给出一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回其长度：</p><p>从前缀中 删除一个 元素后，使得所剩下的每个数字的出现次数相同。</p><p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p><p>输入：nums &#x3D; [2,2,1,1,5,3,3,5]</p><p>输出：7</p><p>解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4]&#x3D;5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。</p></blockquote><p><strong>思路：</strong></p><p>不使用高级的数据结构，只要做好统计，分析出能够产生的条件，就可以解决。</p><p>用两个数组统计每个数字的出现次数<code>number_size</code>，和每种出现次数相同的有多少种数字<code>size_count</code>。</p><p>例如：[2,2,1,1,5,3,3,5]</p><p>如果全部统计，那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">number_size[1]=2, </span><br><span class="line">number_size[2]=2,</span><br><span class="line">number_size[3]=2,</span><br><span class="line">number_size[5]=2,</span><br><span class="line">每种数字都出现了2次</span><br><span class="line"></span><br><span class="line">size_count[2]=4</span><br><span class="line">出现2次的数字，有4种</span><br></pre></td></tr></table></figure><p>利用上面两个数组的统计，满足以下四种情况，就是符合条件的答案：</p><ol><li>前缀中只包含一种数字（number_size.size()&#x3D;&#x3D;1）;</li><li>前缀中包含多种数字，每种数字都只包含一个（只有size_count[1]有元素，其他下标都没有），删掉任何一个数字，剩下数字出现次数都为1;</li><li>前缀中，数字出现的次数只有两种，除了一个元素出现次数是1次，其他元素的出现次数都相同。删掉出现1次的那个元素；</li><li>前缀中，出现次数只有两种a和b，满足a&#x3D;b+1，并且a次数只有一种数字，剩下的数字都出现b次。删掉出现a次数字一个，所有数字出现b次。</li></ol><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEqualFreq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; number_size; <span class="comment">//每个数字有多少次出现</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; size_count;  <span class="comment">//出现次数的计数</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">if</span>(number_size.<span class="built_in">find</span>(num)==number_size.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                number_size[num] = <span class="number">1</span>;</span><br><span class="line">                size_count[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> old_size = number_size[num];</span><br><span class="line">                number_size[num]++;</span><br><span class="line">                size_count[old_size]--;</span><br><span class="line">                size_count[old_size<span class="number">+1</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(size_count[old_size]==<span class="number">0</span>)</span><br><span class="line">                    size_count.<span class="built_in">erase</span>(old_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number_size.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">                    ans = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(size_count.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> iter = size_count.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;first == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(size_count.<span class="built_in">size</span>()==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> iter = size_count.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">auto</span> riter = size_count.<span class="built_in">rbegin</span>();</span><br><span class="line">                <span class="keyword">if</span>((riter-&gt;first-iter-&gt;first)==<span class="number">1</span> &amp;&amp; (<span class="number">1</span> == riter-&gt;second))</span><br><span class="line">                    ans = i;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;first==<span class="number">1</span>&amp;&amp;iter-&gt;second==<span class="number">1</span>)</span><br><span class="line">                    ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这场比赛不需要太多特定的算法，只要能把问题分析清楚，认真思考，就能够解决掉。几个题目都非常适合当面试题。&lt;/p&gt;
&lt;p&gt;下面是详细的题解和思考。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;比赛的地址 Weekly Contest 158&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 第159场周赛解题报告</title>
    <link href="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC159%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC159%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</id>
    <published>2019-04-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<p>本周做完比赛收获比较大，对二分查找还有滑动窗口有了更新的认识。也深深感到要想达到一定的高度，刻意练习是一定要做的。有些题目别人两分钟写完代码，但是不会的即使一天也没思路。看看排名前面的，十几分钟搞定四道题，一定是经过了不少练习，再加上先天智商达到的。</p><p>第三题可以用二分查找在Nlog(N)解答，还可以用滑动窗口在O(N)情况下解答。赛后看别人代码，理解好半天才看明白滑动窗口解答，想到的证明感觉也不太严谨。通过这个题目拓宽了思路，以后遇到类似问题，应该能解答的好一些。</p><p>第一题是判定三点共线，之前比赛有遇到。所以很快就搞定了。也算是练习有点成果。</p><p>现在做题还是靠灵感，做多了，思考多了才能靠经验。靠灵感发挥是不稳定的，靠经验稳定性要比靠灵感强。高手和普通人之间的差别，就是在稳定性上。</p><hr><p>比赛的地址 Weekly Contest 159</p><p><a href="https://leetcode-cn.com/contest/weekly-contest-159">https://leetcode-cn.com/contest/weekly-contest-159</a></p><h2 id="1-缀点成线"><a href="#1-缀点成线" class="headerlink" title="1. 缀点成线"></a>1. 缀点成线</h2><p><strong>题目：</strong></p><p>缀点成线(Check If It Is a Straight Line)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-159/problems/check-if-it-is-a-straight-line/">https://leetcode-cn.com/contest/weekly-contest-159/problems/check-if-it-is-a-straight-line/</a></p><p><strong>题意：</strong></p><p>直角坐标系上有一堆点，判断这些点是否在同一条直线上。</p><p><strong>思路：</strong></p><p>两点确定一条直线，任意找两个点A、B。然后遍历判断其他点，是否和A、B共线即可。<br>判断方法利用向量叉乘，参考之前写的135场文章解法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">checkStraightLine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x1 = c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y1 = c[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x2 = c[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y2 = c[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; c.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x3 = c[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y3 = c[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> cross = (y2-y1)*(x3-x1)-(y3-y1)*(x2-x1);</span><br><span class="line">            <span class="keyword">if</span>(cross != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-删除子文件夹"><a href="#2-删除子文件夹" class="headerlink" title="2. 删除子文件夹"></a>2. 删除子文件夹</h2><p><strong>题目：</strong></p><p>删除子文件夹(Remove Sub-Folders from the Filesystem)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-159/problems/remove-sub-folders-from-the-filesystem/">https://leetcode-cn.com/contest/weekly-contest-159/problems/remove-sub-folders-from-the-filesystem/</a></p><p><strong>题意：</strong></p><p>输入是一个文件名绝对路径的字符串数组，要求输出所有父目录。</p><pre><code>输入：folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]输出：[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]解释：&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。</code></pre><p><strong>思路：</strong></p><p>对字符串数组排序，父目录和其子目录一定是相邻的，并且父目录在最前面。</p><p>从前往后遍历，判断目录是否是已有的最后一个父目录的子目录，如果不是子目录，则为新的父目录。</p><p>也可以用trie树，先全部插入到树中。然后深度优先遍历，遍历到某个节点有结尾符，就不再遍历它为<code>/</code>的子节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSubDir</span><span class="params">(<span class="built_in">string</span>&amp; sub, <span class="built_in">string</span> &amp; str)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub.push_back(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> len = sub.size();</span><br><span class="line">        <span class="type">bool</span> isSub = str.substr(<span class="number">0</span>, len) == sub;</span><br><span class="line">        sub.pop_back();</span><br><span class="line">        <span class="keyword">return</span> isSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">removeSubfolders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; folder)</span> &#123;</span><br><span class="line">        sort(folder.begin(), folder.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        ans.push_back(folder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; folder.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSubDir(ans.back(), folder[i]) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(folder[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-替换子串得到平衡字符串"><a href="#3-替换子串得到平衡字符串" class="headerlink" title="3. 替换子串得到平衡字符串"></a>3. 替换子串得到平衡字符串</h2><p><strong>题目：</strong></p><p>替换子串得到平衡字符串(Replace the Substring for Balanced String)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-159/problems/replace-the-substring-for-balanced-string/">https://leetcode-cn.com/contest/weekly-contest-159/problems/replace-the-substring-for-balanced-string/</a></p><p><strong>题意：</strong></p><blockquote><p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n&#x2F;4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p></blockquote><p><strong>思路：</strong></p><p>如何判断一段字串替换后是否已能平衡？</p><p>由于子串内的字符可以任意变换。整个字符串的长度n又是4的倍数。</p><p>所以，子串外的四个字符，每个的个数都不大于n&#x2F;4就能变换成功。</p><p>如何找到哪段子串能替换是难点。</p><p>有两种方法：</p><p>方法一：二分枚举替换字符串长度，然后验证每个长度的替换子串，是否能满足提议。</p><p>如果满足，则减少最大值。</p><p>如果不满足，则增大最小值。</p><p>最后左右区间会落在满足的最小值上。</p><p>方法二：滑动窗口，在滑动的过程中找到最小值。</p><p>以0为最左侧窗口边缘，然后枚举最右侧边缘。如果满足条件，则不断缩小左侧。</p><p>假设<code>i1&lt;j1, i2&lt;j2, j1&lt;j2, i2&lt;j1</code>,[i1,j1],[i2,j2]两条线段有交集有，他们两个是最接近的满足条件的区间。</p><p>如果[i2, j2]是最优解，那么一定i1 &lt; i2。因为[i1,j1]一定比[i2,j2]短。</p><p>当在[i1, j1]的时候成立时，移动i1的时候，一定会移动到i1+1的位置让条件不成立。这时再扩大右侧时，</p><p>在(j1, j2)过程中，不会有满足条件的，到右侧达到j2的时候，会满足条件，而且会逐步缩小到i2。</p><p>就是在枚举右侧边际的时候，左侧边缘不会再减小，只会逐渐增大。</p><p>方法一代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">string</span> letter = <span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            count[ch]++;</span><br><span class="line">        <span class="type">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">auto</span> isBalance = [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : letter)</span><br><span class="line">                <span class="keyword">if</span>(count[ch] &gt; n / <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; bak = count;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> isOk = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">char</span> ch = s[i];</span><br><span class="line">                count[ch]--;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= mid)</span><br><span class="line">                    count[s[i - mid]]++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= mid - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isBalance()) &#123;</span><br><span class="line">                        isOk = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isOk) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            count = bak;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">string</span> letter = <span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            count[ch]++;</span><br><span class="line">        <span class="type">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">auto</span> isBalance = [&amp;]()-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : letter)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count[ch] &gt; n / <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            count[s[r]]--;</span><br><span class="line">            <span class="keyword">while</span>(isBalance() &amp;&amp; l &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                count[s[l]]++;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-规划兼职工作"><a href="#4-规划兼职工作" class="headerlink" title="4. 规划兼职工作"></a>4. 规划兼职工作</h2><p><strong>题目：</strong></p><p>规划兼职工作(Maximum Profit in Job Scheduling)</p><p><strong>地址：</strong></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-159/problems/maximum-profit-in-job-scheduling/">https://leetcode-cn.com/contest/weekly-contest-159/problems/maximum-profit-in-job-scheduling/</a></p><p><strong>题意：</strong></p><blockquote><p>有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。</p><p>给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。</p></blockquote><blockquote><p>输入：startTime &#x3D; [1,2,3,3], endTime &#x3D; [3,4,5,6], profit &#x3D; [50,10,40,70]<br>输出：120<br>解释：<br>我们选出第 1 份和第 4 份工作，<br>时间范围是 [1-3]+[3-6]，共获得报酬 120 &#x3D; 50 + 70。</p></blockquote><p><strong>思路：</strong></p><p>先给工作按结束时间排序。每项工作，要么做，要么不做。</p><p>动态规划公式dp[n]表示前n项工作的最优解。v[n]表示第n份工作的价值。</p><p>再算dp[n+1]时，分两种情况。</p><ol><li>不选择第n+1份工作，则dp[n+1]&#x3D;dp[n];</li><li>选择第n+1份工作，则dp[n+1]&#x3D;v[n]+dp[j];(做完第j份工作，就做第n份工作。所以j的选取从小于等于第n+1份工作开始时间中，最大的工作序号)</li></ol><p>两种情况的最大值，就为dp[n+1]的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Job</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">int</span> cost;</span><br><span class="line">        <span class="type">bool</span> operator &lt; (Job &amp;other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> end &lt; other.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; endTime, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; profit)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Job&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; startTime.size(); ++i)</span><br><span class="line">            v.push_back(&#123;startTime[i], endTime[i], profit[i]&#125;);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        <span class="type">int</span> n = v.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dp</span><span class="params">(n, <span class="number">0</span>)</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = v[<span class="number">0</span>].cost;</span><br><span class="line">        Job job&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> not_with = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> with = v[i].cost;</span><br><span class="line">            job.end = v[i].start;</span><br><span class="line">            <span class="type">int</span> j = upper_bound(v.begin(), v.begin() + i, job) - v.begin() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">                with += dp[j];</span><br><span class="line">            dp[i] = max(with, not_with);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>第三题</p><pre><code>class Solution&#123;public:    int balancedString(string str)    &#123;        int n = str.size();        unordered_map&lt;char, int&gt; cnt, slide;        for(auto &amp;ch : &quot;QWER&quot;)            cnt[ch] = 0;        for(auto &amp;ch : str)            cnt[ch]++;        for(auto &amp;ch : &quot;QWER&quot;)            cnt[ch] -= n / 4;                    int s = 0;        int t = 0;        int ret = n;        auto isOk = [&amp;]()        &#123;            for(auto ch : &quot;QWER&quot;)            &#123;                if(slide[ch] &lt; cnt[ch])                    return false;            &#125;            return true;        &#125;;        //if(isOk())            //return 0;                //s,t是左闭右开区间[s, t)，所以for循环要判断s不能超过n，但是循环里要判断isOk是否不满足        //不能判断t==n退出循环        for( ; s &lt; n; ) &#123;            //cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt;  endl;            while(t &lt; n &amp;&amp; !isOk()) &#123;                slide[str[t++]]++;            &#125;            //bool ok = isOk();            //cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ok &lt;&lt; endl;            if(!isOk())                break;            ret = min(t - s, ret);            slide[str[s++]]--;        &#125;        return ret;    &#125;&#125;;/*&quot;QWER&quot;&quot;QQWE&quot;&quot;QQQW&quot;&quot;QQQQ&quot;&quot;WQWRQQQW&quot;*/</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周做完比赛收获比较大，对二分查找还有滑动窗口有了更新的认识。也深深感到要想达到一定的高度，刻意练习是一定要做的。有些题目别人两分钟写完代码，但是不会的即使一天也没思路。看看排名前面的，十几分钟搞定四道题，一定是经过了不少练习，再加上先天智商达到的。&lt;/p&gt;
&lt;p&gt;第三题可</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一些微信功能的观察与想法</title>
    <link href="https://yunpengzhang.github.io/2019/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2019/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95/</id>
    <published>2019-04-16T08:24:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<p>微信这个国民级APP，有些产品特性还是很有特点的。把之前的发现记录一些，可以参考下背后的哲学和道理。</p><h2 id="PC版去掉帮忙删空格功能"><a href="#PC版去掉帮忙删空格功能" class="headerlink" title="PC版去掉帮忙删空格功能"></a>PC版去掉帮忙删空格功能</h2><p>在之前的某个微信PC版本，热心地帮用户把消息前后的空格给删除掉。但是在后来的版本迭代中，又给去掉了。<img src="/2019/一些微信功能的观察与想法/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95"  alt="pc" style="zoom: 50%;" />用户有时真的就要在消息前面发空格，帮用户删掉很热心，但用户可能也不买账。</p><h2 id="发现tab中可以删掉所有功能"><a href="#发现tab中可以删掉所有功能" class="headerlink" title="发现tab中可以删掉所有功能"></a>发现tab中可以删掉所有功能</h2><p>记得从前「朋友圈」和「玩一玩」是删不掉的，现在的版本是都能删掉的。给用户更多的选择，不需要的用户自然就不需要，不要限制他强用某个功能。 这个设置，只能设置开关，不能设置位置上调和下降。如果能上下调位置，当然对某些人是刚需，而且以微信的研发实力做这个功能也不难，但为什么没做呢？<img src="/2019/一些微信功能的观察与想法/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95"  alt="discovery" style="zoom: 33%;" /></p><h2 id="看一看只保留七天内容"><a href="#看一看只保留七天内容" class="headerlink" title="看一看只保留七天内容"></a>看一看只保留七天内容</h2><p>控制只看七天内容，能让数据都存在内存，超过七天的删掉。少了做数据落地，切换读取数据源等的操作。如果要做多少天都能看，实现难度就相当于一个小微博。而且也会花费更多的存储资源。<img src="/2019/一些微信功能的观察与想法/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95"  alt="7day" style="zoom:33%;" />实际要看七天前看一看的用户应该非常少，只要设置好上限，系统复杂度会大大降低，也不会影响用户体验。数据有时效性，不用为永久存储，永久备份做太多事情。</p><h2 id="看一看内部的搜索中隐藏着其他入口"><a href="#看一看内部的搜索中隐藏着其他入口" class="headerlink" title="看一看内部的搜索中隐藏着其他入口"></a>看一看内部的搜索中隐藏着其他入口</h2><p>在看一看的搜索里，可以看到「个人中心」，还有其他「特色专栏」。 <img src="/2019/一些微信功能的观察与想法/%E4%B8%80%E4%BA%9B%E5%BE%AE%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A7%82%E5%AF%9F%E4%B8%8E%E6%83%B3%E6%B3%95"  alt="search" style="zoom:33%;" />这里应该是还没想好怎么和用户推广，一些还在孵化的功能，入口很深，有兴趣的用户进来观看，不感兴趣的或不知道的用户，也不会被打扰到。</p><h2 id="微信加群方式与众不同"><a href="#微信加群方式与众不同" class="headerlink" title="微信加群方式与众不同"></a>微信加群方式与众不同</h2><p>加群只有两种方法：1、被群里的人拉进去。2、扫描一个有时效性的二维码。 这么做的好处是让进群的人要么是群里认识的人，要么是在短期推广时加入的人。可以让新进群的人和群里的人有更多话题，能够引起互动。不至于让群很快死掉。 微信的群更像一个临时讨论组。不提供主动的保存通信录功能。有生命力的群就能留下，没有生命力的自然就消失掉，落到最近联系人最下端了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>微信不强制用户使用某个功能； 微信提供有边界的服务； 微信的新功能让用户自己去发现。 尽量让一个功能复杂的APP在表现侧简单，让开发在表现层功能逻辑尽量简单，去打磨内功。</p><h2 id="附：脑动大开"><a href="#附：脑动大开" class="headerlink" title="附：脑动大开"></a>附：脑动大开</h2><p>如果初级的产品经理去做微信，肯定会发现好多块新大陆。有好多功能都能做，而且理由十足，都能满足用户的需求。做完了数据也会不错。几个例子。 1、给小程序做个商店，再加上各种榜单，推荐。简直就是个小型App store。 2、微信消息支持超级链接，支持修改字体颜色，支持富文本。 3、群支持搜索群号，永久二维码，推荐群。 4、公众号编辑器更强大，手机公众号APP也对齐PC端。 5、发现tab里，可以调节「朋友圈」的上下位置。 6、微信头像更新后，好友马上能看到最新头像。 7、阅读公众号切换到聊天窗口可以悬浮多个文章列表。 ………… 上面这些肯定有很多人给微信提过，张小龙不是说全国有几亿人教他怎么做产品吗？但微信为什么没做呢？微信在功能上做了很多坚持和取舍。 那微信的产品经理和开发都在做什么呢，是不是没事可做？ 做一个功能不难，更难的是考虑要不要做，以及未来的发展方向和趋势。好多产品都是做了轰轰烈烈，到后面想下又下不掉，带了很多包袱。微信的功能表面看没有什么，但是有很多内功。例如语音识别，就是微信自己做的，在表面没有入口变化，用户也没什么感知，但是实实在在地大家都在用。 这里需要产品经理有长远的打算，和对产品愿景的制定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微信这个国民级APP，有些产品特性还是很有特点的。把之前的发现记录一些，可以参考下背后的哲学和道理。&lt;/p&gt;
&lt;h2 id=&quot;PC版去掉帮忙删空格功能&quot;&gt;&lt;a href=&quot;#PC版去掉帮忙删空格功能&quot; class=&quot;headerlink&quot; title=&quot;PC版去掉帮忙删空格</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>人人都要effective</title>
    <link href="https://yunpengzhang.github.io/2019/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%A6%81effective/"/>
    <id>https://yunpengzhang.github.io/2019/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%A6%81effective/</id>
    <published>2019-04-11T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人人都要effective"><a href="#人人都要effective" class="headerlink" title="人人都要effective"></a>人人都要effective</h1><p>最近发现，几本不同领域的书，看中文翻译后的书名也都没什么联系，但是英文书名都有一个词——effective。公司也在倡导高效会议、提高工作效率。<br>原来我们一直在学习的内容，和追求的目标，用一个单词符号就可以概括——effective。</p><h2 id="《高效能人士的七个习惯-The-7-Habits-of-Highly-Effective-People》"><a href="#《高效能人士的七个习惯-The-7-Habits-of-Highly-Effective-People》" class="headerlink" title="《高效能人士的七个习惯-The 7 Habits of Highly Effective People》"></a>《高效能人士的七个习惯-The 7 Habits of Highly Effective People》</h2><p>曾经有一位老大哥说过，不用掌握七个习惯，看这本书只要把一个习惯做好，就能够超过大多数人。该书是美国的畅销书，在全球总共发行超过一亿册。甚至还有漫画版和缩略版供人学习。也有专业机构讲授的课程，一节课几万块。</p><p>七个习惯分别是：<strong>积极主动、以终为始、要事第一、双赢思维、知彼知己、统合综效、不断更新</strong>。这里effective的意思是高效，意思是做事情有效率，效率高，也预示着结果是好的，有好的结果。</p><h2 id="《卓有成效的管理者-The-Effective-Executive》"><a href="#《卓有成效的管理者-The-Effective-Executive》" class="headerlink" title="《卓有成效的管理者-The Effective Executive》"></a>《卓有成效的管理者-The Effective Executive》</h2><img src="/2019/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%A6%81effective/theeffectiveexecutive.jpg" class="" title="theeffectiveexecutive"><p>这本书在管理学的地位很高，是德鲁克在上世纪六十年代写的，直到今天还经久不衰。在脑力劳动逐渐替换体力劳动的时代，构建了现代管理学的思想，教知识工作者如何做好管理。不一定是有职位的人才是管理者，任何一个知识工作者，靠脑力劳动产出的人，都是管理者。书中也有介绍时间管理，如何发挥人的长处，决策的要素和如何有效决策。是现代知识工作者必读书目之一。</p><p>从中文的翻译卓有成效，意思侧重于做事的效果是有效的，能够达到预期目标的。但看了英文的翻译The Effective Executive，非常简单。除了表示结果有效以外，也和《高效能人士的七个习惯一样》，有效率高的意思。</p><h2 id="《Effective-C-》"><a href="#《Effective-C-》" class="headerlink" title="《Effective C++》"></a>《Effective C++》</h2><img src="/2019/%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%A6%81effective/51oYgW943EL._SX396_BO1,204,203,200_.jpg" class="" title="51oYgW943EL._SX396_BO1,204,203,200_"><p>没有翻译成中文的书名，直接用的英文。一般技术书籍都很少翻译成中文单词，是为了保持原汁原味吧。这本书是任何一个C++程序员都应该读的书。介绍了一些写C++的原则。C++是一门复杂的语言，很多编写C++有十几年经验的程序员，写的越多，越不敢说精通C++。因为C++既兼顾了底层性能兼容C，支持模板，又有抽象能力加入类，多重继承。如果能把这些用好，简直如虎添翼，如果用不好，那就是灾难。有时为了项目可控，防止程序员对C++理解不一致，而不得不控制一些C++代码的特性使用。</p><p>还有一方面也能看出C++复杂。要学习C语言，一本《C程序设计语言》就够了，中译本258页。入门C++，无论是《C++ Primer》还是《C++程序设计语言》，两本教材都在一千页左右。学完再看《Effective C++》才能说你都知道了，至于工程实现不出问题，还要经过许久的练习。</p><p>书名中的Effective是高效率，写程序又快又好，还有代码执行效率高的意思，和前面介绍的两本书要表达的意思也是有相通之处。</p><p>PS：如果读完《Effective C++》还想提高，还有《more Effective C++》。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的发现有几点启示：</p><p><strong>尽量阅读英文原版书。</strong></p><p>翻译之后反推不出最初的意思，不同语言间语义并非完全等价。还有译者侧重不同，看到的意思不一定全面。</p><p><strong>高效是互联网行业必备素质。</strong></p><p>在互联网行业，技术发展非常快。要快速跟上节奏，无非两条路。一、增加资源：雇佣更多的人，增加更多的上班时长……；二、提高效率：人员更熟练，工具更完善，流程更合理。在项目初期，用第一种方法见效最快，当项目稳定时，用第二种方法更有效。无论管理方法、技术方法和生活习惯，原来我们要追求的高效、卓有成效、有效等等，都是一个单词符号——Effective。只要记住一个词根，或一个基本概念，就能了解目标是什么。</p><p><strong>要善于发现事务之间的联系，看清本质。</strong></p><p>很多不同的事物、学科虽然表面不同，但是底层的道理都是相通的。有些人能够在多个领域都取得成就，也是因为一通百通，快速弄明白多个跨界的知识，弄清楚了事务最根本的原则。通过英文找相同单词是一种简单的方法。更厉害的人会通过融会贯通，独立思考，自己总结出来不同事物的基本道理。最终做到一通百通，举一反三，高效学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人人都要effective&quot;&gt;&lt;a href=&quot;#人人都要effective&quot; class=&quot;headerlink&quot; title=&quot;人人都要effective&quot;&gt;&lt;/a&gt;人人都要effective&lt;/h1&gt;&lt;p&gt;最近发现，几本不同领域的书，看中文翻译后的书名也都没</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>关于企业的思考</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%85%B3%E4%BA%8E%E4%BC%81%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%85%B3%E4%BA%8E%E4%BC%81%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2019-03-24T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>企业是组织众多个人开展经济活动的一种方式。企业在现代汉语中的基本用法，主要指独立的盈利性组织，并可进一步分为公司和非公司企业，后者如合伙企业、个人独资企业、个体工商户等。在20世纪后期中国大陆改革开放与现代化建设，以及信息技术领域新概念大量涌入的背景下，“企业”一词的用法有所变化，并不限于商业性或盈利组织。</p></blockquote><p>维基百科关于企业的定义，是开展经济活动的一种方式。定义比较抽象，下面会通过一些通俗的解释，对企业有更深刻的了解。能够让我们在企业中，工作得更明确。</p><h2 id="企业是科技发展的产物"><a href="#企业是科技发展的产物" class="headerlink" title="企业是科技发展的产物"></a>企业是科技发展的产物</h2><p>企业是近代才有的，古代是没有的。古代即使有，和现代也有很多不同。</p><p>在中国古代，社会排序是「士农工商」。和企业沾边的商是排在最后面的，当时的社会资源在商业上投入的是最少的，人才也都以出仕当官为目标。因为在古代人类摆脱不了自然灾害和饥饿，整个社会要投入到农业生产，克服自然灾害的问题上，才能保证国家的发展和社会稳定。所以商业发展缓慢，没有类似于现代的企业。即使是以经商为目的的组织，也大都是在从事倒买倒卖。商业大多数都是奢侈品或者是满足基本生活，产品种类和形态变化有限，技术革新慢。</p><p>最近一二百年，随着科技革命，生产力水平提高，人们的基本生活水平得到充分保障。整个社会生产力提高，能够生产出更多的物品。科技创造出来的生产力，不再仅由政府来负责分配。由企业来按照市场调节，把生产力制作成各种物品。本质是生产力过多，如果仅为了满足人基本生存，是完全绰绰有余的。既然剩余这么多，就要在更高层次有所投入，产生出更新颖的产品，满足用户的需求。</p><p>生产的东西有几个特点：</p><p>1、如果满足用户需求，会很受人喜欢，如果不满足，白送都没人要。</p><p>例如最早的移动电话，即使笨重，价格不菲，也有很多人购买。现在智能机普及，即使白送从前的智能机，好多人都没人要。可能实体物品还好些，还能回收原料。但是像游戏，影视剧这种虚拟物品，一部烂片，白送票都没有人去看。</p><p>2、无形的，虚拟物品或者服务等占比越来越多。</p><p>现在的公司、企业越来越多，制作实体物品的公司无论从市值还是数量，都没有虚拟物品的公司多。本质是科技水平提高，人要从更高的层次发掘需求，不只是满足人的物质需求。就像前面说的「烂片」，可能耗费上亿元拍摄，如果生产食物，能够满足很多人。但是社会已经能够满足食物需求了，更多的生产力要投入到其他方面。</p><h2 id="企业的作用"><a href="#企业的作用" class="headerlink" title="企业的作用"></a>企业的作用</h2><p>企业把社会的生产力，转化成生产的物品（不一定是实体物品）。再用赚取的利润，投入到研究中，继续提高科技和生产力，促进全社会发展。企业是社会的器官，企业的行动对于社会产生决定性的影响。企业是为社会创造财富的器官。</p><p>企业要不断满足用户的需求，开拓新的市场。这样企业才能生存，才能对社会有用，才能获得资金。</p><p>企业要创造顾客，只有顾客才能创造就业机会。</p><p>营销和创新是企业的主要功能手段。因为生产力是过剩的，生产出的物品也不是人所必须的。生产出世界已有的物品，别家也能生产，为什么能卖出去呢？靠营销。要能发现市场，并进行宣传，才能吸引顾客购买。最近比较火的口红就是典型的案例。把口红卖成了快消品，和时尚挂了钩，让顾客能够持续不断购买，满足了用户新的需求，也能卖更大的价钱。另一种是生产新物品，要依托新的科学技术才能产出。例如5G，人们有需求，但是没这方面的技术，能够创新出来填补市场空白。创新是推动社会生产力发展的必要前提。</p><h2 id="企业与人"><a href="#企业与人" class="headerlink" title="企业与人"></a>企业与人</h2><p>企业要赚钱，但不只是为了赚钱。就像人要生存（吃饭），但不只为了生存（吃饭）。</p><p>在古代物资贫瘠的年代，例如古代饥荒、战争，人的基本生存得不到满足，就只能为了生存而生存。但现在吃饭已经不成问题，人的追求也随之增多，要满足社交、娱乐、自我实现等更深层次的需求。企业也是一样，要获取必须的利润用于生存，但是不只是为了利润，当企业生存得以满足的时候，要把剩余的利润投入生产和研究，为了愿景继续投入生产。企业要有明确的目标，要有社会责任，要能够为社会有积极的正向作用。这对企业本身也是有好处的，如果企业停滞，不向前发展，必然被快节奏的社会发展所淹没。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>企业和人一样，满足了温饱后要有更高的追求。本质都是社会生产力不断提升的缘故。生产力不断提升，技术更新换代加快，企业也要和人一样，不断生产新的东西，满足顾客和社会的需要。作为创业者，或企业管理者，要制定并了解企业的目标，注重企业增长，创造顾客，满足顾客需求，才能让企业得以发展，推动整体社会进步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;企业是组织众多个人开展经济活动的一种方式。企业在现代汉语中的基本用法，主要指独立的盈利性组织，并可进一步分为公司和非公司企业，后者如合伙企业、个人独资企业、个体工商户等。在20世纪后期中国大陆改革开放与现代化建设，以及信息技术领域新概念大量涌入的背</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效工作——团队篇</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E5%9B%A2%E9%98%9F%E7%AF%87/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E5%9B%A2%E9%98%9F%E7%AF%87/</id>
    <published>2019-03-01T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章讲了个人篇如何高效工作。通过学习硬件篇和软件篇的方法，可以达到个人高效。但软件开发是一个团队合作的工作。涉及到产品经理，开发，运维等多种角色合作。需要整个团队整体配合，执行一致，才能达到高效工作。就像一个足球队，只有一名队员技术强，甚至每个球员技术强，都是不够的，还需要各个角色配合好才能取得成绩。</p><p>要团队整体高效，个人高效是前提，之后制定好团队合作的标准，让每个人都按照标准来执行。同时作为团队中的一员，要具有同理心，能换位思考，做事靠谱，不要给别人添麻烦。能做到这些，不管这个团队从事什么工作，都是能做到高效的。</p><h2 id="制定标准"><a href="#制定标准" class="headerlink" title="制定标准"></a>制定标准</h2><p>国际上制定好USB接口标准，确定尺寸，电压，连接线路应该满足什么条件。全世界各种厂商，都可以生产自己的USB线或者支持USB的设备。即使两个工厂在地球的两端，只要都满足标准，生产的设备也能够正常通信。</p><p>在团队中，要制定高效的统一标准。团队中各种角色都学会与其他人合作的标准和制度，都按照标准来做事情，做到整体统一。无论是新加入的新人，还是与外部合作，就像USB接口通用标准一样，大家只要了解了标准，就可以正常合作处理工作。</p><p>有几种常见的标准。</p><h3 id="高效会议"><a href="#高效会议" class="headerlink" title="高效会议"></a>高效会议</h3><p>会议在研发过程中是必不可少的。如果会议高效，能够节约很多时间。一般高效的会议会考虑这些方面：</p><ul><li>为什么要开会，可以不开吗？！！！</li><li>要这么多人开吗</li><li>要都讨论吗</li><li>提前约定时间</li><li>定会议室的时间、地点、时长</li><li>明确必须参加和选择参加</li><li>提前准备会场</li><li>会议讨论内容</li><li>和大家有关的才需要会议讨论</li><li>提前通知背景</li><li>会前想好方案，会上讨论</li><li>主持人掌控好进度</li><li>已经完成会议的人，通知可以离开</li><li>会议结束有结论</li><li>会后事情有回音，有着落</li></ul><h3 id="项目管理流程"><a href="#项目管理流程" class="headerlink" title="项目管理流程"></a>项目管理流程</h3><p>既然软件开发涉及到这么多角色，那么在开发软件的时候，要把软件当成一个项目来做。在项目执行的过程中，要有个管理流程标准，让每次软件项目的开发都是有章可循容易控制。保证项目的成功不靠某些人的能力影响结果，而是靠规章流程保证只要按照执行，项目就会成功。</p><p>项目管理流程要把软件的需求、研发、测试、部署、维护等几个环节如何执行，有什么注意事项，都要制定清晰。</p><h3 id="项目上线模板"><a href="#项目上线模板" class="headerlink" title="项目上线模板"></a>项目上线模板</h3><p>上线模板是项目管理流程中的一个小环节。通常上线过程在短时间内，涉及到多个角色检查将要上线的项目。就开发角色本身，也要涉及很多检查项。</p><p>要产品经理在预发布体验是否满足需求；</p><p>设计体验是否和设计稿一致；</p><p>测试进行最后一轮回归测试；</p><p>客服进行培训，准备好应对用户的询问；</p><p>开发检查线上环境是否满足容量，是否申请了足够的权限，是否有把依赖外部的配置准备好……</p><p>要完成一个完善的上线模板很不容易，需要对制作的软件有足够的了解，而且要经过一段时间的磨合，才能更适合整个团队使用。</p><h2 id="同理心"><a href="#同理心" class="headerlink" title="同理心"></a>同理心</h2><p>由于是团队合作，要达到整体最优才是最好的算法，而不能以个人的局部最优。要能够换位思考，站在别人的角度思考问题，站在整体的角度思考问题才可以。</p><h2 id="靠谱"><a href="#靠谱" class="headerlink" title="靠谱"></a>靠谱</h2><p>什么是靠谱——<strong>凡事有交代，件件有着落，事事有回音。</strong>总结的很好，在团队中工作的时候，要做一个靠谱的人，才能让团队整体工作高效。团队高效了，个人的工作才会有成效。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如何高效工作？</p><p>要先自身高效，对于工作需要的技能和操作要熟练，要有有效的方法指导自己高效工作。</p><p>达到自身高效后，要做到团队高效。团队高效要有章可循，先制定标准。制定标准是为了能按照规则执行，更重要的是思想，要有能应对各种状况的思想。也是最主要的同理心、靠谱。</p><p>以上都做到了，工作才能达到卓有成效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面两篇文章讲了个人篇如何高效工作。通过学习硬件篇和软件篇的方法，可以达到个人高效。但软件开发是一个团队合作的工作。涉及到产品经理，开发，运维等多种角色合作。需要整个团队整体配合，执行一致，才能达到高效工作。就像一个足球队，只有一名队员技术强，甚至每个球员技术强，都是不够的</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效工作——个人硬件篇</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%A1%AC%E4%BB%B6%E7%AF%87/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E7%A1%AC%E4%BB%B6%E7%AF%87/</id>
    <published>2019-02-13T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如何高效工作？对于每个想在工作中取得成就的人来说，都会问自己这个问题。之前公司也讨论过这个话题，觉得还是很重要的。这里介绍一些方法，希望能够对大家的高效工作有些帮助。</p><p>主要分为两部分，个人和团队。涉及到三篇文章。个人——硬件篇、个人——软件篇、团队篇。</p><p>要高效，我们要先从个人做起，把自身的效率提高，达到局部效率最大化。但是现在的工作都是团队，一个人强不行，还要整体强，都像一个目标出发才行。所以在团队层面要有好的规章制度，保证整体的效率最大化。就像现在的全球化，一件物品要全世界成千上万家工厂生产，最终才能合成一件衣服或者一支铅笔。每个环节都有严格的标准和流程，才能保证整体正常。在我们的公司团队中也是如此。</p><h2 id="个人提高效率"><a href="#个人提高效率" class="headerlink" title="个人提高效率"></a>个人提高效率</h2><p>把人想象成为一台工作的电脑，如果要做个排序算法，怎样才能高效？</p><p>学过计算机的都知道，一方面要有强劲的CPU、内存等计算资源，这些就是所谓的硬件。</p><p>还有就是合适的数据结构和算法，这些是软件层面。我们首先来看硬件篇。</p><h3 id="硬件篇"><a href="#硬件篇" class="headerlink" title="硬件篇"></a>硬件篇</h3><p>硬件层面提高效率，更多是例行或者执行速度的优化。就像电脑硬件一样，你不断地堆叠cpu和内存，虽然执行的语句内容和顺序都没变，但是也会让程序跑的快一些，体验也好很多。</p><p>我们可以使用合适的办公工具、训练娴熟的工作方法、良好的习惯，都能够帮助我们提升自身硬件层面的效率。</p><h4 id="办公工具"><a href="#办公工具" class="headerlink" title="办公工具"></a>办公工具</h4><h5 id="快速的电脑、软件，使用顺手的鼠标键盘等"><a href="#快速的电脑、软件，使用顺手的鼠标键盘等" class="headerlink" title="快速的电脑、软件，使用顺手的鼠标键盘等"></a>快速的电脑、软件，使用顺手的鼠标键盘等</h5><p>程序员每天都要接触电脑，电脑是生产资料，就像木匠需要顺手的斧子一样。如果电脑开启一个编译器要等一分钟，编译一段代码要一小时，都是浪费时间的举动。遇到这种情况，升级电脑硬件刻不容缓。及时自己花钱也值。钱能解决的问题都不是问题，这些投入是投资小见效快的。软件也是，有些软件收费，但是好用，那就花钱买下来，让开发体验好一些，投资的办公设备提升效率，赚到的钱要比投入多很多。鼠标键盘也一样，有人喜欢机械键盘或好的鼠标，虽然我用并没有太大的感觉，但是如果你用上能够心情舒适，提高效率，也是可以的。有些广告经常说「取悦自己」，人的心情好提升生产力也是有科学依据的。</p><h5 id="有利于健康的办公设备"><a href="#有利于健康的办公设备" class="headerlink" title="有利于健康的办公设备"></a>有利于健康的办公设备</h5><p>对于人来说，身体是陪伴我们一生的。再大的生产力，都是靠我们的肉体来实现。健康对人来说是至关重要的。虽然很多年轻人不注意，但是等真出现问题再注意就晚了。还有研究表明，病痛会影响人的心情，心情不好，能工作效率高吗？</p><p>人体工学的键盘鼠标、站立办公桌、办公椅，都是很好的健康投资。很多大型互联网公司也都会给程序员配备。即使公司没给大家配置，自己也要花钱配置，这也是提升工作效率的一种方法。而且通过花钱能解决的问题，是最直接效率最高的方式。</p><p>为祖国健康工作50年！</p><h4 id="丰田工作法"><a href="#丰田工作法" class="headerlink" title="丰田工作法"></a>丰田工作法</h4><p>在丰田的工厂中，为了让工人组装机械快速，发明了一种工作方法，能够提高效率。</p><blockquote><p>区分要与不要的物品，现场只保留必需的物品。<br>必需品依规定定位、定方法摆放整齐有序，明确标示。<br>清除现场内的脏污、清除作业区域的物料垃圾。</p></blockquote><p>在程序员日常开发中，也是可以借鉴的。桌子上的东西是否整齐，如果想找一本资料，是否能够马上找到。电脑桌面上是否乱糟糟的，文件夹分类是否合理， 能否快速地找到文件？</p><h4 id="常用软件功能和快捷键"><a href="#常用软件功能和快捷键" class="headerlink" title="常用软件功能和快捷键"></a>常用软件功能和快捷键</h4><p>对于常用的软件，是否常用功能都能够知晓。有时知道一些功能，能够达到事半功倍。例如微软的office套件，应该花时间学一学，在日常办公中很多功能都非常有用。例如excel的筛选、运算；word的排版……</p><p>还有快捷键，虽然用鼠标点点也能操作，但是你用快捷键，真的会很快捷，让操作行如流水。对于程序员来说，熟悉的编辑器或IDE的快捷键，能够让你快速找到函数定义，快速调试……</p><p>特别是linux下的程序员，掌握shell的快捷键，至少会一门脚本语言，在日常进行文字处理或者数据处理时，会非常快速。网上不是有个图片吗，会正则表达式解决一个问题，就像人猿泰山飞跃峡谷一样心情顺畅。</p><h4 id="良好的习惯"><a href="#良好的习惯" class="headerlink" title="良好的习惯"></a>良好的习惯</h4><p>如果没有些良好的习惯，会让你有很多惊喜。记得要调整软件自动保存，或者自己定时保存，多按按ctrl+s。</p><p>重要的文件记得多备份，万一机器死机哭都来不及。</p><p>文件分门别类放好，建立好索引，能够快速查找。</p><h4 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h4><p><strong>office套件</strong></p><p>大多数公司都绕不过这个软件，虽然很多程序员对这个软件不感冒，认为linux下总有能替代它的。但是真的是非常好用的软件，特别是公司的同伴都用这个套件，你没办法用别的。即使苹果的办公软件，在工作效率方面也没有office强大。</p><p><strong>有道云笔记，印象笔记，onenote</strong></p><p>笔记类软件，这三个各有特点，不管用那个。有记笔记收集知识的习惯，是最好的。这些笔记都有网络同步功能，多终端同步，能够很方便记录和查看。</p><p><strong>everything</strong></p><p>能够快速找到需要的文件，在windows系统下，查找效率也很高，对于文件分类不好的同学，真是一大利器。</p><p><strong>markdown编辑器</strong></p><p>markdown语法专注写作，可以用普通的符号生成文字格式。我觉得专注倒是其次，最好的是能够保持文本格式，这样在代码中或文档中，能够在命令行搜索到内容。如果像word那样，搜索会比较麻烦，而且文件会比较大。</p><p><strong>chrome浏览器和丰富的插件</strong></p><p>chrome已经不是一个简单的浏览器了，更像是一个操作系统。虽然他访问网页速度也很快。加上各种插件，提高效率的效果杠杠的。可以上网搜索好用的插件，绝对爱不释手。</p><p><strong>any.do，wunderlist，todolist……</strong></p><p>时间管理类软件，能够提醒你什么时候去做什么事情。</p><p><strong>腾讯文档、Google文档、石墨文档</strong></p><p>总有些时候是需要和其他人写作，这时用这几种在线文档，协作效率会增加，也是非常好的工具。</p><p>上面介绍了很多工具，有些功能还是重复的。这里想说，没有那个是绝对好的。特别是争论哪个比哪个好，是最费时间和最没用的事情，适合的才是最好的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>硬件篇主要是介绍一些工具和机械的方法。工作的习惯不变，操作步骤不变，只是让过程变得快速，通过这种方式来提高效率就是在个人层面的硬件提高，就像电脑更换更快的硬件一样。</p><p>后面还会再介绍如何在「软件」层面提升个人效率，软件层面是把做事情的方式都变了，会发生质的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如何高效工作？对于每个想在工作中取得成就的人来说，都会问自己这个问题。之前公司也讨论过这个话题，觉得还是很重要的。这里介绍一些方法，希望能够</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何高效工作——个人软件篇</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E8%BD%AF%E4%BB%B6%E7%AF%87/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E8%BD%AF%E4%BB%B6%E7%AF%87/</id>
    <published>2019-02-13T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://www.owenzhang.net/blog/226.html">《如何高效工作——个人硬件篇》</a>介绍了硬件层面提高的方法。即通过加快操作熟练性，升级办公用具的方法，提高工作执行速度。本质工作的流程和步骤不变，但是执行时间缩短。今天说的软件篇，里面介绍的方法，是优化工作执行的方式，让事情的解决效率，有指数级的提升。就像你用快速排序和用冒泡排序相比，优化了算法复杂度，排序速度有量级的提升。</p><p>具体到各行各业的工作，有很多和工作内容相关联的方法。在此提一些通用的方法，如果做到了，能够一通百通，轻松应对各种工作，对生活的效率也有提高。</p><p>软件篇的方法，就像软件之于计算机一样。会改变你的认知和对做事的想法，从根本上提升效率。</p><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>时间对每个人都是公平的，不管穷人富人，一天都有24个小时。如何高效利用时间，是能让自己更多产出，寿命增长的一种好方式。主要介绍如何时间管理和克服拖延。</p><h4 id="GTD"><a href="#GTD" class="headerlink" title="GTD"></a>GTD</h4><p>GTD（Getting Things Done）有五条核心原则：收集、处理、管理、执行、回顾。</p><p>收集：把需要跟踪的事情都记下来。尽可能全，防止忘了。</p><p>处理：如果能两分钟搞定的事情，马上做。剩余的按四象限法分类。</p><p>管理：把事情安排，确定下一步做什么，整理到日程当中。保证进度和节点。</p><p>执行：按计划的做，说到做到，专注完成。可以用番茄钟工作法。</p><p>回顾：定期回顾列表中的事情，把精力、时间和资源投入到最重要的事情。</p><h4 id="时间管理四象限"><a href="#时间管理四象限" class="headerlink" title="时间管理四象限"></a>时间管理四象限</h4><p>在GTD的处理步骤，有用到时间管理四象限方法。<img src="/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E8%BD%AF%E4%BB%B6%E7%AF%87/640.jpeg" class="" title="图片"></p><p>具体的做法如图所示。</p><p>在程序员的日常工作，就有很多例子。</p><p>第一象限：线上出现了问题，需要马上修复。重要紧急。</p><p>第二象限：系统没有加监控和详细的日志。不紧急，因为没有这些也能继续跑。但是很重要，加监控不及时，可能会在出现事故的时候发现不出来。</p><p>主要精力要放到第二象限的事情，否则随着时间的推动，第二象限的事情会变成第一象限。人会被时间表推着做事。</p><h4 id="番茄钟工作法"><a href="#番茄钟工作法" class="headerlink" title="番茄钟工作法"></a>番茄钟工作法</h4><p>在做事的时候，最担心被打断，而且现在电子办公，有时也会被社交媒体，或者即时通信的消息打扰到。</p><p>番茄钟工作法是一个比较不错的方法。当你做事情的时候，按25分钟为一个单元，在这25分钟内，尽量做到专注，关掉即时通信提醒，不看邮件，只专心做你要做的事。当25分钟到了以后，休息5分钟。用来处理下邮件和漏掉的消息。</p><p>主要是让人有个大块的时间专心做一件事情。如果总分神，虽然时间跨度多，单都被打成了碎片时间，效率会大大降低。如果能集中精神做25分钟，产出还是不少的。而且任务可以用番茄数来衡量，时间久了，会对排期准确性大大提升。</p><blockquote><p>番茄钟是厨房里定时的钟，扭动会计时，一般最大能计时60分钟。网上有卖的，类似于鸡蛋的形状。<img src="/2019/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E2%80%94%E2%80%94%E4%B8%AA%E4%BA%BA%E8%BD%AF%E4%BB%B6%E7%AF%87/640-20240718191302653" class="" title="图片"></p></blockquote><p>通过番茄钟工作法，让你的工作更加专注，并且能够记录工作花费的实际时长。</p><h3 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h3><p>几乎每个人都有拖延症，人的动物属性是趋利避害的，遇到比较难的事情，人体都倾向于不去做，不去思考。还有一般制定的计划，也都是延迟满足类的。例如要运动，读书，结果很好，但是刚开始会有点痛苦。和看电视，刷手机相比，还是玩更能即时快乐。</p><p>如果能克服拖延，能够节省很多浪费掉的时间，效率也会提升。</p><p>关于如何克服拖延症的书有很多，这两种方法比较有效。</p><h4 id="结构化拖延"><a href="#结构化拖延" class="headerlink" title="结构化拖延"></a>结构化拖延</h4><p>这种方法是斯坦福的一个哲学教授发明的。理解起来很简单，就是拖延也有优先级的。</p><p>当你列了一串要做的事情的清单后，当不想做优先级最高的那个时，就去找清单中简单一点的去做，用来逃避最难的事情。但是这也很好，时间没有浪费，把次优先级的事情给做了。</p><p>就像有的小孩在看电视，父母让他去做作业，他不去。过一会父母说，反正你也没事，把地扫一扫清洁下吧。小孩说我还是去做作业吧。</p><h4 id="意志力"><a href="#意志力" class="headerlink" title="意志力"></a>意志力</h4><p>人要想把事情做成，还是要有点意志力才行。没有什么事情是容易的，想要取得成就，要有些意志力，能够克服人的动物属性，才能有大的提升。</p><p>吃美食当然开心，马上大脑就能得到反馈，但是如果觉得健康和身材更重要，哪有什么捷径，当然是要锻炼了。要想到为了长远的健康方面的快乐，是否能够放弃当前短期的即时快乐，而去延迟满足。<br>一旦有意志力，能够接收延迟满足，寻找到要做的事情的乐趣之后，发现也没那么难，运动的过程也是很快乐的。</p><p>同理，读书工作都一样，要勇敢地跳出舒适区，依靠意志力客服拖延才是最根本的。古往今来的有成就的人无不如此。</p><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p>如果对上面介绍的方法感兴趣，可以详细阅读下面这几本书。为什么会有《断舍离》？减少让你分心的东西，让大脑装的东西密度更好，也会提升效率。</p><p>《暗时间》</p><p>《把时间当成朋友》</p><p>《高效能人士的七个习惯》</p><p>《番茄工作法图解》</p><p>《断舍离》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇&lt;a href=&quot;https://www.owenzhang.net/blog/226.html&quot;&gt;《如何高效工作——个人硬件篇》&lt;/a&gt;介绍了硬件层面提高的方法。即通过加快操作熟练性，升级办公用具的方法，提高工作执行速度。本质工作的流程和步骤不变，但是执行时间缩短</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员如何科学地记日志</title>
    <link href="https://yunpengzhang.github.io/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E8%AE%B0%E6%97%A5%E5%BF%97/"/>
    <id>https://yunpengzhang.github.io/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E8%AE%B0%E6%97%A5%E5%BF%97/</id>
    <published>2019-01-30T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>无论是哪种程序员，日常开发中都离不开记日志。但是通过最近的review会，发现很多程序员在记日志的时候，还是会有些问题。那么如何科学地记录日志呢？</p><h2 id="为什么要记日志"><a href="#为什么要记日志" class="headerlink" title="为什么要记日志"></a>为什么要记日志</h2><p>在寻求方法前，我们先看看我们记日志的目标。</p><p>日志是程序运行时的x光，能够追踪到程序运行的状态，通过日志，程序员能够加速调试速度，还原异常情况出现的场景。</p><p>也有通过日志记录处理数据，方便后面统计和审计。</p><p>还有通过日志进行备份，当数据有问题时，通过日志恢复数据。</p><p>总之，我们记日志，是为了给人看，来了解程序运行的状态。今天我们只讲日常调试和发现异常的场景。</p><h2 id="日志记录什么内容"><a href="#日志记录什么内容" class="headerlink" title="日志记录什么内容"></a>日志记录什么内容</h2><p>既然日志是给人看的，就要让人能读懂，给出足够的信息。要带有上下文，4w都要清晰。把日志记录时刻的时间when、地点where（发生的函数，代码行）、什么数据或请求导致（who）。通过这些我们推出why，和how。知道为什么会记录成这样，有什么影响。</p><h2 id="日志的级别"><a href="#日志的级别" class="headerlink" title="日志的级别"></a>日志的级别</h2><p>在程序中，日志也是分级别的，不同的级别表示日志的不同场景和用途。</p><p>通常有如下级别：</p><p>TRACE：打印最详尽，在开发过程中使用此级别。类似于单步调试，在发不到运营环境后应该屏蔽掉这个级别。</p><p>DEBUG：指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。</p><p>INFO：消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。</p><p>WARN： 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。</p><p>ERROR： 发生了错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，需要记录后处理。</p><p>FATAL： 指出每个严重的错误事件将会导致应用程序的退出。严重错误，直接停止程序。</p><p>每一条日志都是以上级别中的一种，程序中通过配置默认打印的级别，控制哪些语句打印，哪些不打印。</p><p>一般开发阶段使用DEBUG级别，线上运营阶段使用INFO或WARN级别。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="控制好日志的量"><a href="#控制好日志的量" class="headerlink" title="控制好日志的量"></a>控制好日志的量</h3><p>记录日志是旁路逻辑，和给用户使用的逻辑是互不影响的。但是日志会消耗程序性能，抢占给用户的计算机资源。所以在记录日志时，要控制好日志的量，不要因为记录日志而导致性能下降。</p><p>有些同学会觉得，我的业务现在量也不大，多记些日志也没什么。勿以善小而不为。要养成好的习惯，如果没有这种意识，是没有机会做大业务量的程序的。即使有，也会出问题。</p><p>即使量少，用户少，但是不保证程序运行的次数少。如果有个循环频繁调用，触发记录日志，也会导致出问题的。我就见过日志记录太多，把cpu给占满，机器连ssh都连不上。</p><h3 id="日志中出现太多的特殊字符"><a href="#日志中出现太多的特殊字符" class="headerlink" title="日志中出现太多的特殊字符"></a>日志中出现太多的特殊字符</h3><p>看到有的同学在日志里，会写些特殊的字符串，例如「XXXXXXXXXX」。原因是为了好搜索。如果是为了解决号搜索的问题，使用有规则的格式，和有意义的名字是不是更好，把代码行号打进去是不是更容易搜索？而且大家还知道是什么意思。</p><h3 id="注意日志级别"><a href="#注意日志级别" class="headerlink" title="注意日志级别"></a>注意日志级别</h3><p>一种是把DEBUG级别设置到生产环境。还有一种是在代码中没有日志级别的概念，都用一种级别，DEBUG或者ERROR。要么所有的日志在生产环境都打不出来，要么一下子全打出来了。</p><h3 id="注意日志安全"><a href="#注意日志安全" class="headerlink" title="注意日志安全"></a>注意日志安全</h3><p>既然日志记录了这么多信息，要注意日志中的内容，不能什么都打。和用户隐私相关的要避免打印到日志中去。因为这些信息如果不影响查找bug，记录后容易泄露用户隐私。例如：用户的聊天记录、用户的密钥、用户的电话号码邮箱等。</p><h3 id="日志可读性"><a href="#日志可读性" class="headerlink" title="日志可读性"></a>日志可读性</h3><p>尽量用英文，尽量少用中文，防止机器或网页有字符问题，造成不必要的查找麻烦。</p><h2 id="几种有效的日志形式"><a href="#几种有效的日志形式" class="headerlink" title="几种有效的日志形式"></a>几种有效的日志形式</h2><p>以下这几种记录日志的形式都各有所长，值得大家学习。但是切记，都有好用的日志库，千万别自己实现，里面的水很深。</p><h3 id="内存日志"><a href="#内存日志" class="headerlink" title="内存日志"></a>内存日志</h3><p>既然日志打印很耗费性能，一般是磁盘IO是瓶颈。但是在程序遇到问题时，还想把从程序开始，到出问题这段时间的日志都记录下来，怎么办呢？就用内存日志。</p><p>申请一个共享内存变量，在程序的各个运行节点，都把要记录的日志信息存储在这个变量中。当程序出错，或者要crash后。用工具把这段内存dump下来，相当于一些栈信息打印出来。如果程序运行正常，当新的请求再开始执行时，重新清空变量，再继续记录。</p><p>既记录了很多信息，有没有造成IO的花销，在寻找C++后台程序core的原因时是非常有用的一种方式。</p><h3 id="远程日志"><a href="#远程日志" class="headerlink" title="远程日志"></a>远程日志</h3><p>既然打本机日志耗费IO性能，导致cpu使用率飙升。那么通过网络包，把信息发送给远端，尽量减轻本地记录日志负担。这也是一种好方法。远端有专门处理日志的程序，负责给日志入库，进行分析和索引。</p><h3 id="染色日志"><a href="#染色日志" class="headerlink" title="染色日志"></a>染色日志</h3><p>当有用户反馈遇到问题时，但发现只是个例，其他用户并没有此问题时。可以给反馈问题的用户「染色」。日志程序在写日志时，只对染色的用户进行记录，其他的不记。</p><h3 id="流水日志"><a href="#流水日志" class="headerlink" title="流水日志"></a>流水日志</h3><p>一般用于写接口，把每次写的原始参数给记下来。通过这些流水日志，能够恢复出记录的数据，用于备份或对账最终数据，或者提供给其他系统重写数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>日志是给人看的，要注意可读性。</p><p>写日志时要注意不要影响程序性能，按需而记。</p><p>日志在软件维护期间使用的最多，不要日志用时方恨少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;无论是哪种程序员，日常开发中都离不开记日志。但是通过最近的review会，发现很多程序员在记日志的时候，还是会有些问题。那么如何科学地记录日志呢？&lt;/p&gt;
&lt;h2 id=&quot;为什么要记日志&quot;&gt;&lt;a href=&quot;#为什么要记日志&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>找到bug的根源，问五次为什么</title>
    <link href="https://yunpengzhang.github.io/2019/%E6%89%BE%E5%88%B0bug%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%8C%E9%97%AE%E4%BA%94%E6%AC%A1%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>https://yunpengzhang.github.io/2019/%E6%89%BE%E5%88%B0bug%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%8C%E9%97%AE%E4%BA%94%E6%AC%A1%E4%B8%BA%E4%BB%80%E4%B9%88/</id>
    <published>2019-01-25T14:04:08.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。 最近在复盘bug的时候，也使用了这种方法，屡试不爽。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>前端发布后，页面按钮点击失效，用户反馈问题，前端回滚代码后恢复。 问题一、为什么按钮点击会失效？ 因为前端代码写出了一个bug，没有对空对象进行判空，导致页面js抛出异常，按钮失效。 一般到这里就结束了，把代码加上对象判空，继续发布就完成了。 但是大家集思广益，问五次为什么，看看是否有新的发现。 之后又问了几个为什么，果真有收获。 问题二、为什么是用户反馈，而不是告警发现？ 因为当时发现了告警，但是看日志没有查出什么异常，就忽略了。 问题三、为什么没有查出日志，是没写日志，还是写了没查到？ 有写日志，但是当时查日志系统特别慢，平时要十多分钟才能查出来，那天一个小时都没出来。 问题四、为什么系统会查不出日志？ 不知道。后来找维护系统的人查了下，发现硬盘有问题，紧急更换了磁盘。 问题五、为什么平时要十多分钟才能查出来日志，这么慢？ 因为查询日志没有用主key查询，日志量太多，导致查询慢。改进：记录日志时把key值写好，精简不需要的日志。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过问五个为什么，把一个看似简单的线上bug，挖出了更多可以修改的点。为以后及时发现问题，少出事故，做了很大的贡献。 如果只问一个为什么，那么修改的只有表象问题，把代码判断空加上就结束了。 问了五个为什么之后，做了这几件事： 1. 修复代码判空的bug。 2. 发现了日志系统的磁盘问题。 3. 发现了系统的冗余日志，要精简掉。 4. 发现记录日志的方式不对，修改。 特别是2，如果不找出来，其他系统也会掉到这个坑里，也算是举一反三。发现一个问题，把关联问题，和根本问题都解决了 很多时候，我们遇到的问题都有更深层次的原因。一个问题出现，也都是多个问题同时发生的结果。在大问题发生之前，一定有很多次小问题出现。问5个为什么，就像进行了5次深度和广度的搜索，把问题又向四周和更深的地方挖掘。 每次出问题时都能多问几次为什么？才是从根本上消除问题的一个好方法！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。 最近在复盘bug的时候，也使用了这种方法，屡试不爽。&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>90%的程序员都犯过的代码错误</title>
    <link href="https://yunpengzhang.github.io/2019/90%%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E7%8A%AF%E8%BF%87%E7%9A%84%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF/"/>
    <id>https://yunpengzhang.github.io/2019/90%%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E7%8A%AF%E8%BF%87%E7%9A%84%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF/</id>
    <published>2019-01-23T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>最近参加了多次的代码review会，在review的过程中，发现有些问题几乎每次都出现。挑了几个比较典型的问题讲解下。这几个问题都是初级问题，解决方法都很容易。只要掌握了方法，有意识避免，能让短时间内迅速提高代码质量。真所谓投入小，见效快。</p><h2 id="变量命名不清晰，一词多义"><a href="#变量命名不清晰，一词多义" class="headerlink" title="变量命名不清晰，一词多义"></a>变量命名不清晰，一词多义</h2><p>为变量命名时最重要的考虑事项是，该名字要<strong>完全、准确地描述出该变量所代表的事务</strong>。容易阅读，不会与其他事务混淆。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(staff_id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;系统归档，不是员工归档&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，staff_id是员工号的意思，用staff_id为0表示是系统归档。一词多义，本来应该把系统和人分开，但是混用到了一个变量。如果调用方出现个bug忘记把初始化的变量赋值，还会走到意外的逻辑。</p><p><strong>解决方法是变量名称首先要符合变量的实际意义，没有歧义；对于一个变量名，不用特定值表示特殊逻辑</strong>。</p><p>有些代码会把变量取不到的值赋予其他的意义，感觉是省事了，实际后患无穷。例如用户名不可能为空，就用空值表示这个用户数据已经被删除了。而且判定数据是否删除的代码看着也让人莫名其妙。</p><p>总之，变量命名要保证没有「潜规则」，防止给自己挖坑。</p><h2 id="使用魔数"><a href="#使用魔数" class="headerlink" title="使用魔数"></a>使用魔数</h2><p>命名不清晰更严重的是，没有命名，直接用魔数。如果连注释都没有，就只能靠猜。</p><p>使用魔数有两个不好的地方：</p><p>1、不方便修改。</p><p>使用常量替换魔数是一种将程序「参数化」的方法，需要修改改动一处就可以了，而不必代码中到处修改。<br>例如在代码中默认绑定的端口是80，如果不用一个常量代替，哪天软件升级默认端口变成443了。要整个代码搜索80这个数字，既耗时，又容易改错。</p><p>2、代码不方便阅读。</p><p>只有一个数字，很难了解到具体的意思。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，只看13，谁能猜出来是什么意思呢，为什么用13这个数值？可能只有写代码的人和上帝知道，如果天长日久，写代码的人忘记了，就只有上帝知道了。</p><p>也有同学会问，有的数字只用到一个地方，也起个常量的名字会不会太麻烦了？</p><p>答案是：不麻烦。给魔数起个好名字是应该的，这是对的事，不要因为麻烦就不做。有时为了起个准确的名字，甚至要查下词典。</p><p>有一个常用的判定方式：</p><p>一、如果引用魔数的地方不超过3个，直接用数字影响也不大。如果超过了3个，都是表示同一个数值意义，还是乖乖地用有意义的变量名代替。</p><p>二、如果魔数本身就是表示一个纯粹的数字定义，例如是几米、几千克这种，作为参数传递。在函数的定义明确表示了形参数所代表的意义。大家看用到的地方和函数定义，就知道数字是表示多少个单位的意思，可以用魔数。但是如果用数字表示种类，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ieBrowser=<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> chromeBrowser=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>表示浏览器的种类，如果直接只是看到1或2，是不明白什么意思的。即使在函数声明的地方已经说过是浏览器种类了，也不要用魔数。</p><p>魔数解决的办法很简单：<strong>用枚举、常量等方式，代替魔数</strong>。</p><h2 id="if-else-或switch等逻辑判断语句太长"><a href="#if-else-或switch等逻辑判断语句太长" class="headerlink" title="if else 或switch等逻辑判断语句太长"></a>if else 或switch等逻辑判断语句太长</h2><p>例如下面的伪代码代码，条件分支很多，用很长的if else语句或者switch语句才能表达完整的逻辑，要思考下是否能用「表驱动」方式来优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CN=<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> US=<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> UK=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">string language;</span><br><span class="line"><span class="keyword">if</span>(country==CN)</span><br><span class="line">&#123;</span><br><span class="line">    language=<span class="string">&quot;中文&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(country==US)</span><br><span class="line">&#123;</span><br><span class="line">    language=<span class="string">&quot;english&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(country==UK)</span><br><span class="line">&#123;</span><br><span class="line">    language=<span class="string">&quot;english&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">language=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件分支太多太长有几点不好：</p><p>1、代码太长，不易阅读。</p><p>如果超过了一个屏幕能表示的长度，要翻页才能看完代码，会大大降低看代码的效率。因为代码的信息密度太低了。</p><p>2、不易扩展，修改代码。</p><p>就像上面的例子，如果又增加了新的条件判断，那么要增加新的if else语句，由于修改了逻辑，要重新测试，也要防止改错。</p><p>可以<strong>用「表驱动」的方式替代太长的逻辑分支</strong>。</p><p>把每个条件要用到的数据放到一个「表」里。用条件分支的判断条件来索引到表中的数据。<br>上面的代码可以修改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CN=<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> US=<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> UK=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">string languageTable[]=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;中文&quot;</span>,<span class="string">&quot;English&quot;</span>,<span class="string">&quot;English&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//先判断country变量是否在定义的CN、US、UK范围内，如果在继续</span></span><br><span class="line">language = languageTable[country];</span><br></pre></td></tr></table></figure><p>经过修改，代码变得很短，一眼就能看出代码所表示的逻辑。而且以后更新的只有数据，逻辑部分不用修改。</p><p>使用「表驱动」后，逻辑和数据分离。使得新增数据修改简单，而且一目了然。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面只是简单的说明了几种常见的代码书写错误。稍加注意，就能够在短时间内迅速提升代码质量。具体的方法可以参考一些代码规范，或者重构的书籍，例如「表驱动」会有更详尽的介绍。</p><p>最本质的还是要从意识上有足够的认识。<strong>代码是写给人看的</strong>，写代码时要有同理心，想到以后让阅读代码的人尽量能够不费力读懂。换位思考，如果你就是review人，或后面接手这个代码的人，你会喜欢这段代码吗？</p><p>毕竟<strong>代码阅读的次数远远超过编写的次数。确保代码阅读方便，而不仅是编写方便</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近参加了多次的代码review会，在review的过程中，发现有些问题几乎每次都出现。挑了几个比较典型的问题讲解下。这几个问题都是初级问题，解决方法都很容易。只要掌握了方法，有意识避免，能让短时间内迅速提高代码质量。真所谓投入小，见效快。&lt;/p&gt;
&lt;h2 id=&quot;变量命名</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>决策的要素</title>
    <link href="https://yunpengzhang.github.io/2019/%E5%86%B3%E7%AD%96%E7%9A%84%E8%A6%81%E7%B4%A0/"/>
    <id>https://yunpengzhang.github.io/2019/%E5%86%B3%E7%AD%96%E7%9A%84%E8%A6%81%E7%B4%A0/</id>
    <published>2019-01-08T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.375Z</updated>
    
    <content type="html"><![CDATA[<p>管理者工作中，很大一部分就是决策。如何作出有效的决策？<br>先要了解有效决策的几个要素：</p><h2 id="一、了解问题的性质"><a href="#一、了解问题的性质" class="headerlink" title="一、了解问题的性质"></a>一、了解问题的性质</h2><p>做决策前先对当前问题进行思考，是经常性问题，还是偶然性问题。如果是偶然性问题，把它恢复原状就完成了。如果是经常性问题，要制定一套规则来解决。</p><p>经常会混的是本质是经常性问题，但是被误以为偶然性问题，要仔细分析。例如运营环境总出现发错消息的事故，每一次看着原因都不同，都很偶然，不是配置错了，就是代码bug。如果当作偶然性问题，头痛医头脚痛医脚，每次都打补丁，看似解决，实则危机四伏。本质是对发消息机制的检查不够，包括权限流程检查，代码审查，运营异常监控。这三方面哪方面做了，都能拦住最后的事故，但是都没做，只要有一个地方突破了，就会马上触发事故。因此针对检查机制制定策略，是最有效的决策。</p><h2 id="二、找出解决问题的边界条件"><a href="#二、找出解决问题的边界条件" class="headerlink" title="二、找出解决问题的边界条件"></a>二、找出解决问题的边界条件</h2><p>决策应遵循的规范。决策的目标是什么？换言之，最低限度应该达成什么目的？应该满足什么条件？用科学的术语来说，这就是所谓“边界条件”。<br>工作年限越多，遇到的问题越模糊，越难有明晰的解决方法。确定问题已经很难，再确定问题的边界条件，就更难了。<br>要找到边界条件，然后制定符合边界条件的决策，避免错误的边界条件的决策。</p><h2 id="三、找出解决问题的正确方案"><a href="#三、找出解决问题的正确方案" class="headerlink" title="三、找出解决问题的正确方案"></a>三、找出解决问题的正确方案</h2><p>明确了问题的边界条件，之后确定解决问题的方案。解决方案要有多种，从不同方向考虑。一定不要只有一种解决方案。从多种解决方案中，根据衡量的维度，科学判断，得出得分，选出最优的一个解决方案。</p><h2 id="四、化决策为行动"><a href="#四、化决策为行动" class="headerlink" title="四、化决策为行动"></a>四、化决策为行动</h2><p>方案制定的再好，没有行动，也都是纸上谈兵。行动是耗时最久的一项。要找对的人来执行，确保执行的人能够按照既定的要求去做。</p><h2 id="五、重视执行过程的反馈"><a href="#五、重视执行过程的反馈" class="headerlink" title="五、重视执行过程的反馈"></a>五、重视执行过程的反馈</h2><p>对于管理者，很多时候看不到项目的执行过程。要有方法能够衡量执行的效果，是否符合预期，对预期结果做印证。可以从目标出发，从数据得到印证，结果导向。</p><p>再好的决策，也有符合情况的条件。随着时间的变化，从前的决策并不一定适合当前的状况，所以要重视反馈，及时修改需要改变的已有决策。</p><p>如何作出有效决策，是管理者的一项重要技能，要做到科学系统地决策，先从掌握决策要素开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管理者工作中，很大一部分就是决策。如何作出有效的决策？&lt;br&gt;先要了解有效决策的几个要素：&lt;/p&gt;
&lt;h2 id=&quot;一、了解问题的性质&quot;&gt;&lt;a href=&quot;#一、了解问题的性质&quot; class=&quot;headerlink&quot; title=&quot;一、了解问题的性质&quot;&gt;&lt;/a&gt;一、了解问题</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何做到要事优先</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%A6%81%E4%BA%8B%E4%BC%98%E5%85%88/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E8%A6%81%E4%BA%8B%E4%BC%98%E5%85%88/</id>
    <published>2018-12-23T12:05:05.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>人的精力、时间是有限的，在有限的资源下，如何能作出巨大的贡献，甚至是无限的贡献呢？就是要做重要的事，优先做重要的事。 如何做到要事优先，尽可能产出更大的成果呢？</p><h2 id="一、摆脱过去"><a href="#一、摆脱过去" class="headerlink" title="一、摆脱过去"></a>一、摆脱过去</h2><p><strong>1. 不要躺在过去的功劳簿上</strong> 成功要依靠天时地利人和，还需要一点点运气。但是成功的人，大部分都认为是自己的努力，不愿意承认和运气有关。很多成功过的人，都会把过去的实践当成真理。因为我用这招成功过啊。但是有没有想过，时机不一样了，当初的很多条件变化了。 在2014年做移动游戏，是很赚钱的，能够绕过大公司的壁垒，很多小公司都赚得盆满钵满。放到今天，时代变了，大公司已经把移动互联网都布局完了，用户的口味和审美也越来越高了，再用昨天的打法就不行了。看看app store排行榜，都是巨头垄断。不要躺在过去的功劳簿上，要用发展的眼光看问题，遇到老问题，也要新思考。 <strong>2. 及时止损</strong> 已经投入了很多，不舍得止损，认为项目已经开始了，就一直做下去吧。也是不对的，如果方向错了，会越走越起反作用，原地不动要强过走反方向。过时的项目，不合时宜的产品线，该停就停，关键时刻要有壮士断腕的勇气。只有吐故，才能纳新。</p><h2 id="二、优先级评估"><a href="#二、优先级评估" class="headerlink" title="二、优先级评估"></a>二、优先级评估</h2><p>事情按重要、紧急两个纬度，可以分为四种。优先处理重要不紧急的，尽量少做不重要不紧急的。重要紧急的事会打乱你的节奏，往往也都是由重要不紧急拖延而来的，如果天天救火，就要好好思考下了。 面对一件事，如果是压力大要做，要分辨是否真的重要，不做是不是也可以，压力从何而来，现在是在救火，还是在消除根本问题。 面对一项不急的事情，要评估下当下是否是最好时机，是否天时地利人和都具备。如果都有，那么就开始做吧。有时说「缓一缓，以后再做」，过了时机，就永远都不做了。</p><h2 id="三、心法"><a href="#三、心法" class="headerlink" title="三、心法"></a>三、心法</h2><p>看问题要看本质，什么是问题的本质，要从本质上解决根本问题。 做事情要看时机，天时地利人和都具备，就立马去做。 真正做事情的时候，都是执行阶段。应该在执行之前就先思考完全，有详尽的计划，这样才能有章法，考虑全。按部就班，步步为营，一次只做一件事，最终把事情做好。 知道要事优先是高效做事的第一步，也是最重要的一步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人的精力、时间是有限的，在有限的资源下，如何能作出巨大的贡献，甚至是无限的贡献呢？就是要做重要的事，优先做重要的事。 如何做到要事优先，尽可能产出更大的成果呢？&lt;/p&gt;
&lt;h2 id=&quot;一、摆脱过去&quot;&gt;&lt;a href=&quot;#一、摆脱过去&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员如何描述清楚线上bug</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E6%B8%85%E6%A5%9A%E7%BA%BF%E4%B8%8Abug/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E6%B8%85%E6%A5%9A%E7%BA%BF%E4%B8%8Abug/</id>
    <published>2018-12-16T11:54:36.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>一个管理后台的bug，把操作记录中的操作员姓名，写成了该操作员的id。原因是修改了一个返回操作人姓名的函数，返回了操作人的id。但是还有其他地方也用这个函数，导致其他地方把姓名字段填写成了操作员的id。<br>该bug污染了一条修改记录，操作员手动删除就好了。回滚代码后恢复。<br>本质是修改了函数的返回值，却没有查看所有调用的地方。这个函数的名字叫getinfo，但是在代码的其他模块中也有同名函数，返回的都是id，让修改的人以为都是一个函数，引起了混淆。所以函数名也要修改，做到通过名字能够清晰看出函数功能。</p><p>本来很简单的一个线上bug，按照上面的描述几句话就说清楚了，但是一个组员说了一个小时，才勉强让组内的其他同学听明白。<br>他在描述的时候，先说代码，还有更改代码的背景，而且描述的只言片语，让大家不停提问，花了很多时间。</p><p>怎样能够描述清楚线上bug，也是有方法论的，大家可以看看。</p><h3 id="描述的顺序"><a href="#描述的顺序" class="headerlink" title="描述的顺序"></a>描述的顺序</h3><p><strong>1. 对齐背景</strong><br>对于线上bug，先描述影响，从用户角度把bug描述清晰。可以把自己想为测试，测试给我们报bug的时候，从来都不会说你代码哪里错了，只是把现象给出，再加上复现的步骤。</p><p>同时也说清楚影响范围，多久恢复，让大家放心，知道影响面。</p><p><strong>2. 交代错误原因</strong><br>用直白的语言，说明出错的原理。为什么出错？注意是直白的语言，不是交代代码层面那个函数出错。例如上面的例子，应该说是函数返回值修改导致，而不应该直接说getinfo是一个什么函数，为什么要修改这个函数。</p><p><strong>3. 说明引入错误的始末</strong><br>一般线上bug都是由于变更引起的。究竟是什么变更，为什么会有变更需求，也需要交代清楚。</p><p><strong>4. 如何预防</strong><br>发生bug不可怕，可怕的是重复发生。 吃一堑长一智，不让错误发生第二次，要反思预防的方法，防止再次发生。把预防的方案想好，说出来。</p><p>按照上面的顺序会比较清晰、快速地描述清楚线上bug。让听众能够快速了解到影响，和处理方式。</p><p>描述清楚线上bug是每个程序员都要必备的能力之一，也是日常经常遇到的场景。<strong>掌握先交代背景和影响，再说明错误原因和如何预防，是一种行之有效的描述方法。</strong></p><hr><p><strong>延伸阅读</strong></p><p>通用的方法论可以学习《金字塔原理》《问题的分析与解决》中的SCQA、MECE等方法，这些才是根本，要努力学习和刻意练习才能够掌握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h3&gt;&lt;p&gt;一个管理后台的bug，把操作记录中的操作员姓名，写成了该操作员的id。原因是修改了一个返回操作人姓名的函数，返回了操作人的id。但是还有其他</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何做系统迁移下线类的需求</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E4%B8%8B%E7%BA%BF%E7%B1%BB%E7%9A%84%E9%9C%80%E6%B1%82/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E4%B8%8B%E7%BA%BF%E7%B1%BB%E7%9A%84%E9%9C%80%E6%B1%82/</id>
    <published>2018-12-16T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何做系统迁移下线类的需求"><a href="#如何做系统迁移下线类的需求" class="headerlink" title="如何做系统迁移下线类的需求"></a>如何做系统迁移下线类的需求</h1><p>系统迁移类需求，要考虑：</p><ol><li><p>要考虑可以回滚</p></li><li><p>要有前后效果的对比</p></li><li><p>对老系统要有监控，是否真的流量没了，而不是依赖于具体业务迁移方说迁完了，要相信自己的眼睛。</p></li><li><p>有一个冷却时间，过了冷却时间再下掉机器。</p></li></ol><p>例子：要去掉一个老的图片系统，让业务方反馈都谁有调用过，然后让大家去改，改好了上报。</p><p>实际上要让大家反馈，还要根据流量或日志，验证是否反馈的正确，是否有遗漏。按照规模分别拉群组织，给出迁移的基本通用方案，让大家能够做到快速迁移，快速检测迁移效果。当有人反馈迁移成功后，能够验证是否迁移正确、完全。定期推动迁移节奏，防止业务忘记迁移，导致迁移时间过长。尽量控制时间越短越好，否则很消耗大家的精力。</p><p>下线全部完成时，要有个通知，全体通知，让大家都知道从前老的已经结束，并给出新的使用方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何做系统迁移下线类的需求&quot;&gt;&lt;a href=&quot;#如何做系统迁移下线类的需求&quot; class=&quot;headerlink&quot; title=&quot;如何做系统迁移下线类的需求&quot;&gt;&lt;/a&gt;如何做系统迁移下线类的需求&lt;/h1&gt;&lt;p&gt;系统迁移类需求，要考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何做组件升级类的需求</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E7%BB%84%E4%BB%B6%E5%8D%87%E7%BA%A7%E7%B1%BB%E7%9A%84%E9%9C%80%E6%B1%82/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%81%9A%E7%BB%84%E4%BB%B6%E5%8D%87%E7%BA%A7%E7%B1%BB%E7%9A%84%E9%9C%80%E6%B1%82/</id>
    <published>2018-12-16T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>组件升级，大多数程序员都觉得很简单，直接给个新的包，或新组件的地址，让大家都去下载不就可以了。但是实际这里面还是有很多学问，和需要考虑的地方的。</p><p>要考虑业务推广的难度，以业务方来看，不要没事改这改那，对业务没有什么帮助，相反到有所风险，而且还增加了工作量。</p><p>如何做组件升级需求，都是围绕着如何减轻业务顾虑来做的。</p><p>听说Facebook的最简单粗暴，谁升级组件，谁就负责把别人的代码改好。</p><h3 id="要保证api尽量向前兼容"><a href="#要保证api尽量向前兼容" class="headerlink" title="要保证api尽量向前兼容"></a>要保证api尽量向前兼容</h3><p>如果api有同样的功能，但是新版本变了，会让业务很难接受，因为本来已经写好的东西，又要重新修改。或者是为了使用一个新功能，但是让业务要重新改动和此不相干的大部分代码，这些都是不可取的。</p><h3 id="代码要经过充分的测试"><a href="#代码要经过充分的测试" class="headerlink" title="代码要经过充分的测试"></a>代码要经过充分的测试</h3><p>这是最基本的，特别是组件类的需求，是最底层的东西，要质量有保证。否则帮助推广升级方，还导致业务不稳定，以后再让人家升级就难了。</p><ol><li>最好是做成服务，或者是分离式组件，能够无感知，业务代码一点不动就升级。</li><li>业务只需要重新编译，就能够提高性能，有新功能。</li><li>新功能调用新函数，或者加几个参数就能行。</li><li>新旧两个版本可以在一套代码中使用。</li><li>干掉就代码，只能一下子切割掉旧的用新的，没有前后对比。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组件升级要考虑到业务方的更换成本， 业务最关心的是稳定性和工作量，要让他们消除这些顾虑，所以要做很多工作，而不只是把组件完成，升级的事情推给业务方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组件升级，大多数程序员都觉得很简单，直接给个新的包，或新组件的地址，让大家都去下载不就可以了。但是实际这里面还是有很多学问，和需要考虑的地方的。&lt;/p&gt;
&lt;p&gt;要考虑业务推广的难度，以业务方来看，不要没事改这改那，对业务没有什么帮助，相反到有所风险，而且还增加了工作量。&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>无边无界</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%97%A0%E8%BE%B9%E6%97%A0%E7%95%8C/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%97%A0%E8%BE%B9%E6%97%A0%E7%95%8C/</id>
    <published>2018-12-16T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>人类总是在不断的扩大边界，没有终点，边界不断变大</p><p>多少钱够花，多少时间够用，多快的计算机够速度。永远不够。</p><p>人类总是能制造新的边界，原以为达不到的，到了就够用，当新边界到了时候，又会去更远的地方，就像地平线，看得到，但永远达不到。</p><p>对于人来说，要适应变化，不断进化自己，才能适应时代发展规律，永远在线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人类总是在不断的扩大边界，没有终点，边界不断变大&lt;/p&gt;
&lt;p&gt;多少钱够花，多少时间够用，多快的计算机够速度。永远不够。&lt;/p&gt;
&lt;p&gt;人类总是能制造新的边界，原以为达不到的，到了就够用，当新边界到了时候，又会去更远的地方，就像地平线，看得到，但永远达不到。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员如何讲清楚技术方案</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</id>
    <published>2018-12-05T14:11:49.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员如何讲清楚技术方案"><a href="#程序员如何讲清楚技术方案" class="headerlink" title="程序员如何讲清楚技术方案"></a>程序员如何讲清楚技术方案</h1><p>最近在评审技术方案，和代码review的时候，遇到刚入行的同学们，很多都讲不清楚技术方案。</p><p>具体表现是：</p><ul><li>上来不说需求，直接说算法实现。台下一头雾水，根本不知道设计方案是否合理。</li><li>描述完需求后，又直接看代码，看表结构，没有交代流程。</li><li>比较简单的算法，描述的特别绕，让人听不懂。被别人指出后，觉得这东西这么简单，你们为什么听不懂，还很委屈。</li><li>直接说术语，不给解释。还有自己造术语不给解释的，更混乱的是「复用」已有的术语，让大家理解都不同。</li></ul><p>那么程序员如何把技术方案讲清楚呢？下面从实用的角度教大家一些小技巧，在短时间内具备讲清楚的能力。在文末给出通用的方法论学习书籍，供长线学习，达到把所有事情都能交代清楚。</p><p><strong>一、要先交代需求背景。</strong></p><p>为什么要做这个需求，对于实现的要求是什么，产品经理提了哪些边界条件。没有银弹，一个技术方案的好坏与实现要求息息相关，是不能脱钩的。例如，一个接口访问质量统计系统，可以接受一天跑一次脚本生成数据。但是为用户提供服务的消费明细，肯定要能实时展示，并且不能出错。</p><p>在评审中，消耗时间比较多的，就是台下的听众问被评审人需求背景。还有台下的人给出了某个建议，然后被被评审人否定，说有个产品的要求我刚才没说。这时对提出建议的人来说，是很伤的。</p><p>交代好背景并对齐，是评审技术方案和代码review的基础，否则别人不知道你后面的是否合理，甚至不知道你到底在做什么。技术方案评审就无从谈起了。</p><p><strong>二、介绍技术方案整体架构</strong></p><p>背景知识说完后，说你的做法。要先总后分，先从整体介绍架构设计。有哪些模块，各自负责什么职责，如何衔接……让大家有个整体认识，看到哪部分是主要矛盾，大家把80%的精力花费在20%的重要模块上评审，好钢用在刀刃上。</p><p>例如一个发奖活动，最重要的模块是发奖抽奖模块，但是上来不讲整体，而是先讲展示活动规则的模块，而且用掉了大半的时间，是很浪费人力的。</p><p>整体架构的描述用架构图、流程图，加上简练的语言，交代明白即可。一般都有架构模板，直接按照模板的要求，参考已有的优秀例子，都不会有大问题。最重要的是这块要先讲，先交代清楚。</p><p><strong>三、介绍协议、库表设计</strong></p><p>整体方案介绍完之后，介绍协议和数据库表设计，开始逐步深入细节。因为这块设计的是否合理，对程序的效率影响比较大。</p><p>分清哪些协议、表是重要的，着重讲，其他不太重要的快速讲。</p><p>协议的执行流程，要交代清晰，整个协议是怎么在各个模块中流转的，到具体数据修改时，是如何和已有表结构串联起来的。这也是程序执行的流程，如果讲不清楚，会深度怀疑你是否能实现清楚。</p><p>这部分要注意，尽量少说术语。因为大家的背景知识不同，一些专门术语大家是不知道的，你要用直白的话语让大家听明白。</p><p>例如：有人在描述协议流程时说「我调用server提供的123号命令，返回成功后，把数据库的state字段改为2，就完成发奖了」。但是你说的123是干什么的，state是什么意思，2是什么状态？</p><p>大家的疑问太多了，好的说法应该是，「我调用server提供的123号发奖的协议，返回成功后，把数据库中该用户的发奖状态，更新为已发奖」。</p><p><strong>四、描述分支和异常逻辑，讲解代码</strong></p><p>经过前面几部的讲解，方案基本上讲完了。剩下的就是讲分支逻辑，和异常逻辑。一份代码写的好不好，程序员是否有经验，主要是看对于异常处理是否到位。</p><p>这部分从架构上主要讲容灾、鲁棒性，例如某个server死掉了，或者某个模块频繁请求，你的系统是否有预警，能够兼容。说白了就是要讲解系统的边界条件和服务能力。</p><p>最后上代码，如果是代码review，在这个时候才开始说你的代码。虽然看的时间比较晚，但是大家都知道你的代码是什么功能了，看的速度也会加快。</p><p><strong>五、复盘</strong></p><p>每次评审后，要自己复盘，总结。别人都问题哪些问题，为什么要问？哪些问题是我应该交代没交代的，让人家问了？哪些是我方案的问题，别人提出的挑战？</p><p>对于自己没交代的，思考为什么会漏，如果能提前讲清楚，是否能节约很多时间。</p><p>根本的心法就是要有同理心。从对方的角度思考，这个问题他会了解吗，我不说他明白吗？<strong>方案评审重要的不是你说完，而是别人听懂。</strong>关注台下人的反应，你的任务不是讲，而是让大家听明白。不是一个劲的说，而是要让大家都理解你的意思，这样别人才能帮你。否则别人会一直问问题，挑战你，最后否定你的方案。</p><p>千万不要觉得听众好笨，这么简单都不明白，如果台下的人都不明白，那么一定是你错了。能力强的人是能够把难题讲解的很简单的。美国有专门负责科普的作家，把复杂的科学知识做到「老妪能解」。台下评审的人都是身经百战的，如果他们都反映听不懂，那么会是谁的问题呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>技术方案讲解要先交代背景，再讲整体架构，再细化流程。先主线，再分支，先正确路径，再异常逻辑。要在听众的角度去讲，尽量直白简单，能够让不懂技术的人听懂才是最好的。</p><hr><p><strong>延伸阅读</strong><br>通用的方法论可以学习《金字塔原理》《问题的分析与解决》中的SCQA、MECE等方法，这些才是根本，要努力学习和刻意练习才能够掌握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序员如何讲清楚技术方案&quot;&gt;&lt;a href=&quot;#程序员如何讲清楚技术方案&quot; class=&quot;headerlink&quot; title=&quot;程序员如何讲清楚技术方案&quot;&gt;&lt;/a&gt;程序员如何讲清楚技术方案&lt;/h1&gt;&lt;p&gt;最近在评审技术方案，和代码review的时候，遇到刚入行的同</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何出面试笔试题</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%87%BA%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E5%87%BA%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/</id>
    <published>2018-12-05T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>出笔试题的目的：为了筛选人，筛掉不满足需求的人。所以题目要有区分度，能够区分出哪些是可以的，哪些是肯定不行的。然后把满足需求的人也能够按照层级区分开来。</p><p>题目尽量不要出死记硬背的题目，不要出偏题怪题。我们的目的不是为了考倒应试者，而是为了找到合适的人。对于知道不知道的知识，尽量少考。多考思考类的知识，因为我们能够培养不知道的人知道，但是很难让思考不明白的人明白。</p><p>要有必须要会的题目，这种题目必须要面试者打出来，如果答不出来，直接就不过。</p><p>还有分层次体，一个题目要有及格答案，优秀答案的分别，能够区分出面试者的能力。</p><p>题目有部分网上找的经典题，即使有人准备，也证明准备了。还有自己出的经典的题，用来区分不同水平的人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;出笔试题的目的：为了筛选人，筛掉不满足需求的人。所以题目要有区分度，能够区分出哪些是可以的，哪些是肯定不行的。然后把满足需求的人也能够按照层级区分开来。&lt;/p&gt;
&lt;p&gt;题目尽量不要出死记硬背的题目，不要出偏题怪题。我们的目的不是为了考倒应试者，而是为了找到合适的人。对于知道</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员如何交代清楚事情</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BB%A3%E6%B8%85%E6%A5%9A%E4%BA%8B%E6%83%85%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BB%A3%E6%B8%85%E6%A5%9A%E4%BA%8B%E6%83%85%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/</id>
    <published>2018-12-05T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>有个项目要推动别人修改，或者有个会议要邀请别人审批。结果程序员在群里说了很多，最后没有人回答，整个群里都是一个人的语言，很尴尬。</p><p>如果让别人做事情，要先交代好背景，然后指出，让每个人干什么，需要什么支持，必要时直接@某个人。让人家知道要干什么。不要一直说，特别是很多人的群，大家都不知道到底要人家干啥。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有个项目要推动别人修改，或者有个会议要邀请别人审批。结果程序员在群里说了很多，最后没有人回答，整个群里都是一个人的语言，很尴尬。&lt;/p&gt;
&lt;p&gt;如果让别人做事情，要先交代好背景，然后指出，让每个人干什么，需要什么支持，必要时直接@某个人。让人家知道要干什么。不要一直说，特别</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章——《管理者如何发挥人的长处》</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E3%80%8A%E7%AE%A1%E7%90%86%E8%80%85%E5%A6%82%E4%BD%95%E5%8F%91%E6%8C%A5%E4%BA%BA%E7%9A%84%E9%95%BF%E5%A4%84%E3%80%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E3%80%8A%E7%AE%A1%E7%90%86%E8%80%85%E5%A6%82%E4%BD%95%E5%8F%91%E6%8C%A5%E4%BA%BA%E7%9A%84%E9%95%BF%E5%A4%84%E3%80%8B/</id>
    <published>2018-12-05T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>组织把人集中在一起，要想发挥作用，达到目标，必须用人所长。通过运用每个人的长处，共同完成任务。就像一个篮球队，队员的身材、技能、脾气都不同，但是发挥每个球员的长处，才能让球队取得好的成绩。</p><p>如何发挥每个人的长处，作为管理者，要能看到每个人的长处，而不是关心每个人的不足。关心每个人贡献什么，而不是他不能做什么。让每个人发挥自己的长处，才是最重要的，对组织才是最有利的。</p><p>要了解一个人的长处，才能对他的绩效提出要求，提出更有挑战的绩效目标。能够充分调用积极性，发挥自身长处。用人的时候，必须能够容忍人的短处。（这里说的短处是有底线的，指的是在技能或其他方面对组织无害的短处。如果突破了道德，或者组织条例，无论如何是不行的。也不能因为这个短处成为他发展的阻碍。）</p><p>优秀的组织不能说少不了某个人就不能运转了。如果真的有这种情况，大多数是组织潜在着某些问题，例如规章流程不到位，靠特殊人的特殊技能在支撑而已。要做的事情应该是马上梳理制度，完善流程，让组织中大多数人都能够胜任。例如：某个系统太复杂，只有一个程序员能够把整个系统运维完善。这是不对的，也是很危险的。要查找为什么复杂，复杂的原因是什么。消除复杂性，简化架构，增强可维护性才是最合理的做法。</p><p>除了管理下属，对于上级，也要学会向上管理，发挥上级的长处。身为下属，协助上司发挥所长，是促进发挥有效性的最好方法。但不是唯命是从，要看什么是正确的事，以上司能够接收的方式提出建议。</p><p>发挥自己的长处，不要画地为牢。「别人不让我干」是一个很通用的接口，但是别人也没让你不干。不要给自己设定范围，发现是对的事情，并且没有和规章制度冲突，放手去做。真正的高效人士是没有借口的，他们所担心的事情是时间和资源不够。要「向天再借五百年」。</p><p>管理者要起带头作用，能够身先士卒，整个团队才能按照既定的方向前进。同时团队中起到带头作用的人才，也要赋予他领导力，把他们安置到能「制定标准」并能创造成绩的位置上。这样团队才能有良性的发展。</p><p>管理者的任务就是要让各个人的才智、健康以及灵感都得到充分发挥，从而使组织的整体效益得到成倍的增长。</p><p>用人所长是卓有成效的管理者必须具备的一种素质，是一个组织工作是否有效的关键，也是知识工作者和社会不可或缺的素质。</p><hr><h1 id="书上摘抄"><a href="#书上摘抄" class="headerlink" title="书上摘抄"></a>书上摘抄</h1><p>管理者为实现目标，必须用人所长——用其同事之所长，用其上级之所长，用其本身之所长。充分发挥人的长处，才是组织存在的唯一目的。管理者的任务，就是要充分运用每个人的长处，共同完成任务。</p><p>有效的管理者，知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。关心的是他能贡献什么，从来不问他不能做什么，而是他能做什么。</p><p>重视一个人的长处，对他的工作绩效提出要求。先发掘一个人最擅长做些什么，再来「苛求」他做些什么。过多考虑人的短处，会影响组织实现自己的目标。</p><p>因人设事还是因事设人</p><p>「因人设事」不能解决问题，因为组织中任何一个职位的变更，都会造成一连串的连锁反应。主治中的职位都是相互联系、相互依存，牵一发而动全身。</p><p>只有坚持因事用人而非因人设事，才能为组织提供所需的各种人才。才能容忍各色人等的脾气和个性。</p><p>怎样用人，才不致于因人设事的陷阱。<br>四原则：</p><ol><li>职位必须由人来单人，不会设置一个「常人」不能胜任的职位</li><li>职位的要求要严格，涵盖要广。能充分发挥长处，而且收到挑战的人，工作肯定最起劲，也肯定最能有所成就。</li><li>用人时先考虑某人能做什么，而不是优先考虑职位的要求是什么。（程序不拘泥于语言）挖掘潜能。</li><li>用人之时，必须容忍人之所短。</li></ol><p>如果说少不了某人：</p><ol><li>某人并不行，不过是管理者没有对他苛求</li><li>管理者本人太差，无用人才来支撑</li><li>本来潜伏着某种严重的问题，因为误用掩盖了。</li></ol><p>发挥上司之所长</p><p>不能唯命是从，应该从正确的事情着手，并已上司能够接收的方式向其提出建议。</p><p>协助上司发挥其所长，是促使管理者有效的最好方法。</p><p>充分发挥自己的长处</p><p>所谓「别人不让我干」，恐怕是惰性和没有勇气的接口。能找出许许多多的重大的工作，只怕时间和资源不够而已。乾隆向天再借五百年。</p><p>习惯无所谓好坏，反映的对客观世界和对自己的认识。</p><p>任何一个团体，行事标准都取决于领导人的表现，有效的管理者会把自己的表率作用建立在充分发挥所长上。</p><p>有条件作出突出贡献，并能起到带头作用的人才，赋予他们领导人的地位，把他们安置到能「制定标准」并能创造成绩的位置上。不看缺点的前提是缺点不会阻碍其长处的发挥。</p><p>管理者的任务就是要让各个人的才智、健康以及灵感都得到充分发挥，从而使组织的整体效益得到成倍的增长。</p><p>尽量发挥下属的长处，不但是管理者必须对机构承担的义务，更重要的是，这也是为人处世的道理：他应该协助下属得到应有的发展。组织必须为每一位成员服务，使每一位成员都能凭其才干达成成就，而不必顾念其所短。</p><p>总结一句：用人所长是卓有成效的管理者必须具备的一种素质，是一个组织工作是否有效的关键，也是知识工作者和社会不可或缺的素质。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h1&gt;&lt;p&gt;组织把人集中在一起，要想发挥作用，达到目标，必须用人所长。通过运用每个人的长处，共同完成任务。就像一个篮球队，队员的身材、技能、脾气都不同，</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员如何处理好时区问题</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A5%BD%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A5%BD%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</id>
    <published>2018-11-25T06:33:46.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>写国际化的程序，经常会遇到两种问题：字符编码、时间问题。今天我们就聊聊程序中如何处理时间问题。</p><p>首先，要了解一些基本的概念，只有对概念有清晰的掌握，才能明白解决方法。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>GMT时间</strong>：格林尼治标准时间（英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。</p><p>由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被原子钟报时的协调世界时（UTC）所取代。</p><p><strong>UTC时间</strong>：协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。</p><p>对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。</p><p><strong>UNIX时间戳</strong>：Unix time又叫POSIX time或UNIX Epoch time，是从UTC时间1970年1月1日起到现在的秒数，不考虑闰秒，一天有86400秒。</p><p><strong>时区</strong>：时区是地球上的区域使用同一个时间定义。世界各个国家位于地球不同位置上，因此不同国家特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p><p><strong>闰秒</strong>：闰秒是在协调世界时（UTC）中增加或减少一秒，使它与平太阳时贴近所做调整。在UTC时间中，有时会出现一分钟有59秒或61秒。</p><p><strong>夏令时</strong>:美国原本于每年4月的第一个星期日凌晨2时起至10月的最后一个星期日凌晨2时实施夏时制；但经美国国会2005年通过的能源法案，自2007年起延长夏时制，开始日期从每年4月的第一个星期日，提前到3月的第二个星期日，结束日期从每年10月的最后一个星期日，延后到11月的第一个星期日。美国夏时制实行与否，完全由各州各郡自己决定。</p><p><strong>时间格式的标准</strong>:参考ISO_8601日期格式标准 <a href="https://zh.wikipedia.org/wiki/ISO_8601%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A2004-05-03T17:30:08+08:00">https://zh.wikipedia.org/wiki/ISO_8601。例如：2004-05-03T17:30:08+08:00</a> 在时间前面加上大些字母T，要标明偏移的时区时间。</p><h2 id="概念解读"><a href="#概念解读" class="headerlink" title="概念解读"></a>概念解读</h2><p>通过上面的概念介绍了解到，GMT就是0时区的时间，以前是标准，但现在国际上已经用UTC取代他了。在写程序时，可以认为UTC和GMT是等价的。为了严谨只需要关心UTC时间。</p><p>UNIX时间戳是程序中最常用的，他的特点是和UTC时间的1970年1月1日到现在的秒数，<strong>和时区无关，无论在地球上的那个角落，同一时刻，UNIX时间戳都是一样的</strong>。是一个通用的时间偏移度量，计算每个时区当地时间时，都可以用时间戳推算出来。</p><p>不同时区的时间，都用UTC时间的偏移来计算。例如北京是东八区，比UTC时间快8个小时，所以计算北京时间，就在UTC时间的基础上加8个小时实现。</p><p>我们在调用系统函数展示时间时，底层是根据UNIX时间戳转换为UTC时间，再加上偏移的小时数，就得出了程序要用的当地时间。</p><p>UNIX时间戳可以映射到每个时区的当地时间，如果程序涉及到两个时区的时间转换，最好的方法是存储UNIX时间戳，在使用的时候再做转换。</p><p>在各种语言的函数库中，都已经定义了时间时区转换的函数。在使用时，还有一点要注意「时区偏移（time offset）」和「时区地区（time zone）」是两个不同的概念。</p><p>偏移是一个数学上的值，直接能计算出时间。时区地区，会根据当地的法律规则，来得出最终的时间，混入了人为的规则。</p><p>例如：<br>在夏令时时，北京和纽约时差是12个小时，但是当夏令时结束时，北京和纽约的时差是13个小时。如果一直用固定的时间偏移，就会计算出错。如果用指定的地区当参数，就会根据当地规则返回正确时间。</p><p>具体例子见代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>                                                                              </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;Asia/Shanghai&#x27;</span>);                                        </span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">strtotime</span>(<span class="string">&quot;2018-11-04 13:00:00&quot;</span>);                                               </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Beijing &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;America/New_York&#x27;</span>);                                     </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NewYork &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;                                                                         </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;Asia/Shanghai&#x27;</span>);                                        </span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">strtotime</span>(<span class="string">&quot;2018-11-04 14:00:00&quot;</span>);                                               </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Beijing &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;America/New_York&#x27;</span>);                                     </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NewYork &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;                                                                                                                                          </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;Asia/Shanghai&#x27;</span>);                                        </span><br><span class="line"><span class="variable">$d</span>=<span class="title function_ invoke__">strtotime</span>(<span class="string">&quot;2018-11-04 15:00:00&quot;</span>);                                               </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Beijing &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                                                   </span><br><span class="line"><span class="title function_ invoke__">date_default_timezone_set</span>(<span class="string">&#x27;America/New_York&#x27;</span>);                                     </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;NewYork &quot;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y-m-d h:i:sa&quot;</span>, <span class="variable">$d</span>) . <span class="string">&quot;\n&quot;</span>;                                 </span><br><span class="line">                                                      </span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Beijing 2018-11-04 01:00:00pm   //没结束夏令时时，时差12个小时</span><br><span class="line">NewYork 2018-11-04 01:00:00am</span><br><span class="line"></span><br><span class="line">Beijing 2018-11-04 02:00:00pm   //夏令时切换，时差为13个小时</span><br><span class="line">NewYork 2018-11-04 01:00:00am</span><br><span class="line"></span><br><span class="line">Beijing 2018-11-04 03:00:00pm</span><br><span class="line">NewYork 2018-11-04 02:00:00am</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>涉及到多个时区的转换，统一使用unix时间戳存储或交互，或者使用带有时区信息的字符串。</li><li>尽量在上层的代码层面修改时区配置，不要修改系统或软件的配置，防止其他程序因为修改受到影响。</li></ol><p><strong>本质</strong>：时区概念是上层人为转换的概念，程序的逻辑不要依赖于他，要有个统一的时刻值概念来衡量真实的时间（例如UNIX时间戳），然后在上层做转换。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%A8%99%E6%BA%96%E6%99%82%E9%96%93">https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E6%A8%99%E6%BA%96%E6%99%82%E9%96%93</a></p><p><a href="https://en.wikipedia.org/wiki/Unix_time">https://en.wikipedia.org/wiki/Unix_time</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6">https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA">https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA</a></p><p><a href="https://www.cnblogs.com/zihanxing/articles/6224263.html">https://www.cnblogs.com/zihanxing/articles/6224263.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写国际化的程序，经常会遇到两种问题：字符编码、时间问题。今天我们就聊聊程序中如何处理时间问题。&lt;/p&gt;
&lt;p&gt;首先，要了解一些基本的概念，只有对概念有清晰的掌握，才能明白解决方法。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何设计「前后端交互协议」</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E3%80%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE%E3%80%8D/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E3%80%8C%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%8D%8F%E8%AE%AE%E3%80%8D/</id>
    <published>2018-11-13T06:15:07.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>客户端和服务器交互，web页面和后端交互，都需要设计前后端交互协议。究竟怎么样设计最好，是否有些方法论呢？有的。 方法很简单：<strong>前端侧重展示，后端侧重逻辑；轻前端，重后端。</strong> 理由如下：</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>无论是客户端，还是web页面，在黑客面前，都是可以修改逻辑的。所以重要的逻辑，都是要做在后端，即使是游戏为了性能和体验，在后端也要做校验逻辑。 逻辑在后端是省不掉的，至于前端，能省则省。不用相同的逻辑实现两次，以后升级修改，只要改后端就可以了，前端只要保证根据后端传过来的展示规则，正常展示就可以。</p><h2 id="易于升级"><a href="#易于升级" class="headerlink" title="易于升级"></a>易于升级</h2><p>web页面还好，可以控制发布。但是客户端，分发就要用很久，而且用户不一定马上升级。所以对协议的制定要求更高，最好是只后端修改，前端就能用上新功能。 这样后端也好维护，不用根据客户端版本而写不同的逻辑。前端也不用关心后端是否有变动要一致。</p><h2 id="易于实现和扩展"><a href="#易于实现和扩展" class="headerlink" title="易于实现和扩展"></a>易于实现和扩展</h2><p>前端只关心展示，相当于一个哑终端。服务器发下来什么指令，客户端就展示什么，并不需要了解业务逻辑。 出现问题也好查，展示问题前端负责，逻辑问题后端负责。只要把前后端交互的内容打印日志出来，就知道是谁的问题。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一个活动页面，用户进来展示一个中奖列表，列表有两只股票A和B。根据用户是否有交易过，B股票上展示一个「不可领取」的戳。 <strong>方案一：</strong> 前后端协议只有一个字段，用户是否交易过。 前端默认进来都展示A和B，根据从后端得到的字段，确定是否展示「不可领取」戳。 后端除了查询是否有交易过，也要每次查看用户是否有中过奖，领取过A或B。 <strong>问题：</strong> 如果哪天产品经理修改了需求，可以领二十支股票，前后端都要修改，而且每次前端都要把产品的逻辑领会全，根据产品经理的要求修改。每增加减少一支股票，都要修改，很烦。 怎么解决呢？ <strong>方案二：</strong> 前端后端协议是一个列表，列表中包含要展示的股票信息，有的字段表示是否展示戳。 前端不关心产品逻辑，只是按照这种来展示。 后端根据用户数据，把协议打包好，传给前端。 前后端可以想象为一个单机程序，如果写个单机程序，肯定是写一次逻辑。逻辑层负责实现逻辑和表现层展示UI，后端对应逻辑层，前端对应表现层。但是为什么网络的就要写两次呢，不是必须的。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>协议要有扩展性，根据字段或版本号识别不同版本。 客户端要兼容不识别的字段，不要因为升级新字段不认识而产生异常行为（crash或逻辑出错）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;客户端和服务器交互，web页面和后端交互，都需要设计前后端交互协议。究竟怎么样设计最好，是否有些方法论呢？有的。 方法很简单：&lt;strong&gt;前端侧重展示，后端侧重逻辑；轻前端，重后端。&lt;/strong&gt; 理由如下：&lt;/p&gt;
&lt;h2 id=&quot;安全性&quot;&gt;&lt;a href=&quot;#安</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>代码中的一致性问题</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2018-11-09T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，数据一致性是一个很难题。通常都是保证可用性，实现最终一致性。最近在review代码过程中，发现代码一致性也很重要，很多小伙伴都容易忽略。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>一个发奖脚本，有两个功能：</p><p>1.打印获奖名单，发送邮件供产品经理审核。 </p><p>2.给获奖名单的用户发送奖品。</p><p>开发同学在实际实现功能时，分别写了两个函数，逻辑大部分类似。只是打印函数加了发邮件和数据格式化功能，发送奖品函数调用发奖服务接口。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这样做是有几个问题。</p><p><strong>一、逻辑一致性维护的问题</strong></p><p>同样的逻辑，分布在两个函数中，必须要保证两个地方函数逻辑一致。让以后维护代码增加了难度。一旦改漏，会导致审核和发送逻辑不同，很有可能导致事故。即使不出错，如果有修改，也要时时刻刻关注两个地方逻辑一致，增加了比对的工作量。</p><p><strong>二、功能实现不完全</strong></p><p>该功能只想到产品经理审核全部通过或全部不通过。万一产品发现中奖名单里有个用户不应该发奖，要怎么办？发奖函数完全不支持这种功能。为了实现审核功能，只能去改动数据库，无疑又增加了风险。数据库设计时有没有软删除字段，只能物理删除，在生产环境也是不允许的。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>两个函数有相同点，可以用两种方法解决。</p><p>第一种是把公用部分抽象成函数。两个函数分别调用。</p><p>但是在这个case里，还不是最好的办法。</p><p>由于审核和发奖是一个前后依赖的流程，把他们做成串行的，发奖的输入数据是审核的输出数据。</p><p>审核只负责导出名单给产品，让产品决策谁该发，谁不该发。发奖只负责发，你给我什么名单，我就给谁发，最多再加个校验逻辑，校验下名单中的人是否在最初的审核表格中存在。</p><p>把审核后的输出作为发奖的输入，就能把问题解决了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码中维护逻辑一致性，可以用设计模式解决。</p><p>在实现产品逻辑时，也要考虑是否有逻辑重合，可以通过输入输出连接，串行处理，达到相同逻辑复用，也能降低复杂度，易于调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在分布式系统中，数据一致性是一个很难题。通常都是保证可用性，实现最终一致性。最近在review代码过程中，发现代码一致性也很重要，很多小伙伴都容易忽略。&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>代码中的奥卡姆剃刀原理</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86/</id>
    <published>2018-11-07T14:14:46.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如无必要，勿增实体。 过早的优化是万恶之源。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一个抽奖活动，要求在展示奖品股票时，显示股票价格。开发在实现这个功能的时候，用redis缓存每只股票的价格，每两小时调用行情服务更新一次。 问为什么要做个缓存，而不是直接访问行情服务直接读取，给出了几个理由：</p><ol><li>减少对行情的请求，直接访问redis一次就能查很多。</li><li>用缓存速度快。</li><li>奖品展示、获奖排行榜都要用行情数据，防止不一致。</li><li>用行情的地方很多，不用每次请求行情服务。</li><li>前端需要拉取的数据，在需求范围内，可以接受两小时不变，不用每次重新计算。</li></ol><p>但是这些理由都站不住脚，直接访问行情服务并不会有问题。 优化过渡，过早加了缓存，增加了代码的复杂度，产生了数据的不一致性。 没有解决具体的问题，看到的只是一些表象，看似解决了问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>逐条思考下上面的几点理由。 理由1. 减少对行情的请求，直接访问redis一次就能查很多。 说法是对的，确实减少了对行情的访问。但是为什么要减少对行情的访问呢？ 行情的服务很稳定，而且性能也很好，并没有什么问题。没有解决具体问题。 理由2. 用缓存速度快。 如果直接访问行情数据源速度是瓶颈吗，有遇到性能问题吗？没有。行情也是内存访问，速度不一定比redis慢的。而且开发也没有数据支撑。 理由3. 奖品展示、获奖排行榜都要用行情数据，防止不一致。 为什么要一致，不一致有什么问题？对于排行榜，大家都有预期，是一定时间才更新一次的，只要在排行榜界面有说明即可。就像游戏的排行榜，很多都是24小时更新一次。没有必要为了和排行榜数据一致，而修改代码。这个问题在产品形态上就能解决，也是个伪问题。 理由4. 用行情的地方很多，不用每次请求行情服务。 同理由1，多怎么了？正常访问就可以了，如果性能瓶颈再优化。 理由5. 前端需要拉取的数据，在需求范围内，可以接受两小时不变，不用每次重新计算。 具体的产品形态，可以有加缓存的余地，但不意味着必须要加缓存。除非遇到有性能问题，否则代码的可维护性、稳定性是最重要的。 再换个角度，如果行情的接口性能真的很慢，要怎么优化呢？ 不是直接暴露redis接口的，有更好的方法。 把行情获取部分单独封装成为一个独立函数，对外不依赖具体的内部实现。 不管是直接访问行情服务、读缓存，还是访问一个单独封装的优化行情服务模块，对外接口都不变。 整理下常见的避免过渡优化场景： <strong>1、能同步实现的代码，就不要用异步；</strong> <strong>2、能实时实现的代码，就不要用定时；</strong> <strong>3、能用数据源读取的，就不要用缓存。</strong> 先保证程序简洁，满足性能要求，等遇到问题的时候，再去优化，避免过早优化，引入问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>解决问题前，先思考是否有问题，问题是什么，而不是直接去做。</strong> 「如无必要，勿增实体」代码模块中，在没有遇到问题时，不要引入过多的模块，缓存，增加代码的复杂性。既不易于阅读，也不易于维护。 遇到性能优化，不优化有问题，优化过渡，即使没产生问题，也是浪费。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如无必要，勿增实体。 过早的优化是万恶之源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一个抽奖活动，要求在展示奖</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>培养学习能力的三个阶段</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%9F%B9%E5%85%BB%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%9F%B9%E5%85%BB%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5/</id>
    <published>2018-11-04T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>随着科技的进步，各行各业都突飞猛进地发展，拥有良好的学习能力是职场必备技能。</p><p>怎样培养学习能力呢？一般要经过三个阶段：<strong>在人指导下进行学习；寻找学习机会，学以致用；总结提炼，帮助他人学习。</strong> 这三个阶段从初级到高级，一步一个脚印，就像打怪练级一样。</p><h2 id="在人指导下进行学习"><a href="#在人指导下进行学习" class="headerlink" title="在人指导下进行学习"></a>在人指导下进行学习</h2><p>对于程序员来说，这是学习的初级阶段，一般是刚入行1-2年。这时最重要的是学习的意愿，能够在别人的指导，或者要求下进行学习。了解学习的目的，学以致用。能够通过指定的学习资源掌握做好自身岗位工作所需要的知识、技能、工具和信息等。</p><p>是「不知道自己不知道」的时候。要虚心请教，当知道自己哪个方向有空白，需要学习的情况下，能够去主动学习，积极主动地掌握知识。遇到问题把问题理解，寻找解决方法，然后进行学习，最终解决问题。</p><p>初级阶段就是丰富自己的「目录输」，然后把一些常用的章节搞透，能够满足工作的基本需求。</p><p>例如前辈推荐的技术书籍，项目组内的框架文档，项目设计文档，都是必须学会的学习资料。否则，连基本的工作内容都很难做好。</p><h2 id="寻找学习机会，学以致用"><a href="#寻找学习机会，学以致用" class="headerlink" title="寻找学习机会，学以致用"></a>寻找学习机会，学以致用</h2><p>经过一两年的锻炼，能够对工作上的问题解决的七七八八了。不要自满，还要继续寻找学习的机会。要制定成长规划，利用公司的培训机会，积极地为自己安排培训和学习，保持专业只是技能的更新。</p><p>虽然工作上的事情都能搞定，但是是最优的吗？能够拔高一点吗？把学到的知识学以致用，不断探索改善和提高自身工作效率。</p><p>生活中不缺少美，但缺少发现。平时工作中就有很多有价值的信息，也有很多机会，要抓住，掌握。</p><p>记得刚工作的时候都用的自己设计的二进制协议，要写代码转字节序，很繁琐，还容易出错，浪费很多时间。后来自己研究能不能自动打包，描述完协议，填写字段后就打包成功了。然后顺着这个方向学习，对底层的字节序，还有代码能力都有很大提升。最后发现google也有人做这种事情，而且做的更好「proto buffer」。经过学习，调研，测试，最终在项目中使用，大大提升了开发效率。在过程中也成长了很多，培养了学习能力。</p><h2 id="总结提炼，帮助他人学习"><a href="#总结提炼，帮助他人学习" class="headerlink" title="总结提炼，帮助他人学习"></a>总结提炼，帮助他人学习</h2><p>这个阶段要站到更高的一层。了解专业领域的发展情况，关注行业内新技术，新方法的应用，并能够在工作中运用。与上个阶段的区别，这个阶段更主动，不一定是自己遇到了才去找，而是发现外部有新知识，就主动去向，能不能用到公司的项目中。</p><p>能够运用所学的知识，举一反三。由点及面，不是遇到一个问题解决一个，而是把这类的问题都解决掉。能够抽取方法论，从问题的本质去解决。</p><p>不断总结自己过去和他人的实践经验，从中汲取有价值的帮助。<br>不在一个坑跌倒两次，而且也不是所有坑都要亲自跌过，从别人的经验中总结有价值的信息。例如：发现有因为把测试环境配置同步给正式环境导致事故，除了要每次操作仔细。还要想想，能不能有防止这种误操作的方法，能不能高效快速地把所有项目都用上这种方法，杜绝再次发生事故。</p><p>如果能给别人讲明白一个知识点，那么才是真正的掌握。除了要自己学的好，还要能与团队成员交流和分享相关知识、经验，帮助他人了解更好的学习方式和学习机会。不只是自己强，还要对团队的价值观，整体技术水平有贡献。互相学习，培养良好的学习氛围，才能有更高的水平。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习是一个发展自我，修行的过程，需要有很强的自律能力才能坚持下来。掌握学习能力是任何时代都很重要的技能。</p><p>就像打王者荣耀，开始跟着新手引导打，或者「师父」让你去上路你就去上路，让你走，你就走，在别人的指导下学习。</p><p>慢慢掌握基础玩法后，就会主动学习，看别人怎么打，对手怎么打。和其他玩家讨论，主动学习，主动找人练习，把段位提高。</p><p>随着段位的提高，总结出各种职业怎么打，各种装备怎么出。出了新英雄，新装备，都能马上融会贯通。也能教「徒弟」，甚至出新的地图也能很快上手，对这类游戏都有了心得。</p><p>学习能力的培养，就是一个从被动，到主动，先跟着别人学，然后自己学，最后影响他人互相学习的一个过程。</p><p>活到老，学到老！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着科技的进步，各行各业都突飞猛进地发展，拥有良好的学习能力是职场必备技能。&lt;/p&gt;
&lt;p&gt;怎样培养学习能力呢？一般要经过三个阶段：&lt;strong&gt;在人指导下进行学习；寻找学习机会，学以致用；总结提炼，帮助他人学习。&lt;/strong&gt; 这三个阶段从初级到高级，一步一个脚印，</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何设计抽奖活动</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8/</id>
    <published>2018-11-04T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>如何设计抽奖活动</p><h2 id="抽奖的意义"><a href="#抽奖的意义" class="headerlink" title="抽奖的意义"></a>抽奖的意义</h2><p>抽奖是一个很好的运营手段，通过抽奖，能够短时间内吸引大量用户，让用户集中使用产品。<br>是运营活动中最常用的方法。</p><h2 id="抽奖中的注意事项"><a href="#抽奖中的注意事项" class="headerlink" title="抽奖中的注意事项"></a>抽奖中的注意事项</h2><p>设计一个完美的抽奖活动，需要思考很多细节，最本质只有一个词「可控」。</p><p>所有的细节都是围绕着可控来实行的。</p><h3 id="概率可控"><a href="#概率可控" class="headerlink" title="概率可控"></a>概率可控</h3><p>这是最基本的，抽奖要能控制概率。大奖概率低，小奖甚至不中奖概率高。如果人人可中，那是福利。如果人人都不中，就成了耍猴。</p><p>在设计抽奖奖品的时候，要有抽中概率字段。一般直观想到的是按百分比，例如有两个奖品。配置表如下：</p><p>A 25%<br>B 25%</p><p>但是这种配置方法是不对的。为什么呢？扩展性不强。</p><p>因为把概率总和定位100了，每次增减或修改奖品概率，都要保证百分比加起来是100%，增加了运算逻辑。</p><p>最好的方法是用权重，如果一个奖品不想让有人抽中，直接调为0，其他的奖品项也不用更改。</p><h3 id="数量可控"><a href="#数量可控" class="headerlink" title="数量可控"></a>数量可控</h3><p>每个奖品只有概率约束还不完整，还要加上每个奖品的数量，控制奖品的产出。即使有概率控制，百万分之一，一百万人抽奖，也不一定只有一个人中，理论上存在一百万人都中的情况。所以除了有权重，还要有奖品的数量控制。</p><p>怎么确定奖品发光了呢？<br>一种是每发一个奖品，给奖品数减少，另外一种是加个抽了多少个的字段，每抽到一个，给「已抽数量」加一。<br>好处是后面增加奖品库存时不存在写冲突，而且经过多次加减抽奖数量，也知道实际发送了多少。</p><p>如果奖品抽光了，可以有多种策略：<br>1、该奖品的权重自动降为0，从其他奖开始抽。<br>2、当有奖品数为0时被抽到，找剩余有奖品权重最大的那个给他。</p><h3 id="时间可控"><a href="#时间可控" class="headerlink" title="时间可控"></a>时间可控</h3><p>抽奖有时效，有活动时间控制。要能后端修改，就能立即终止或开启抽奖活动。当系统有故障时，这是一个很好的开关。</p><p>发奖也要有时间控制，防止由于其他人把程序启动，活动都过了，还能继续发奖。</p><h3 id="预算可控"><a href="#预算可控" class="headerlink" title="预算可控"></a>预算可控</h3><p>每个活动都有预算，发出去的奖品都是有价值的，发现发送的奖品累计价值超过了预算，要及时告警，停止发送。而且接近预算也要告警，人工确定到底是奖品快抽光了，还是程序有问题发多了。</p><h3 id="满足抽奖资格组合模式"><a href="#满足抽奖资格组合模式" class="headerlink" title="满足抽奖资格组合模式"></a>满足抽奖资格组合模式</h3><p>活动会对积极抽奖，或积极参加的用户给予一些优惠。例如游戏中的十连抽比重高级卡牌。当满足九次抽奖时，第十次的奖池就是一个单独奖池了。要支持多奖池配置，逻辑能根据用户的状态选择不同的奖池。</p><h3 id="防止多抽"><a href="#防止多抽" class="headerlink" title="防止多抽"></a>防止多抽</h3><p>很多程序都是分布式的，会导致并发，产生抽奖次数变多。例如一个人只能有一次抽奖机会。但是如果并发产生了两个请求，两个进程分别处理，会都读到有一次抽奖机会，然后都能抽成功，就造成了多了一次抽奖机会。如果用程序产生更多的并发，抽的更多。</p><p>这里要加锁处理。对于一个用户的抽奖次数加锁。大多数都用乐观锁，<br>一种是加抽奖状态：未抽奖、抽奖中；<br>一个用户要想抽奖，必须先把用户的状态从未抽奖变为抽奖中，此时其他并发的进程发现已经是抽奖中了，就返回失败。</p><p>还有一种是控制抽奖数量，当抽完奖品后，并不马上返回前端，而是去更新抽奖数量，更新时要判断是否有超过最大数量，如果超过，直接算作失败，回滚抽到的奖品，返回前端。</p><h2 id="发放奖励"><a href="#发放奖励" class="headerlink" title="发放奖励"></a>发放奖励</h2><p>有些活动是抽完马上发奖，有的是抽完隔一段时间发奖。本质也是一样的。只是间隔的时间长短。发奖和抽奖是两种事情，也要慎重对待。</p><h3 id="先标记，再发送"><a href="#先标记，再发送" class="headerlink" title="先标记，再发送"></a>先标记，再发送</h3><p>判断一个奖品是否已经发送，都会有一条记录表，有个字段表示是否已发送。是先发送奖品，再更新发送字段，还是先标记字段，再发奖呢？<br>先标记，再发送。</p><p>因为在标记和发送中间，会有程序突然crash的情况。先发再标，会导致多发；先标再发，会少发。</p><p>对于活动举办方，肯定是少发最好，少发了可以补，多发想要回来就难了。</p><h3 id="大奖发送要慎重"><a href="#大奖发送要慎重" class="headerlink" title="大奖发送要慎重"></a>大奖发送要慎重</h3><p>对于一些金额比较大的奖品，发送要慎重，要经过审核。因为本身奖品数就不多，审核包括是否有多发，是否抽奖人符合资格，是否程序有问题……</p><h3 id="防止多发"><a href="#防止多发" class="headerlink" title="防止多发"></a>防止多发</h3><p>在发奖环节，也有类似与多抽的并发问题。也要有锁，保证一条发奖记录，不会被发送多次。通常也是加发送状态。未发送、发送中、已发送。先用发送中抢到发送资格，再慢慢发送这条，发完标记为已发送。如果发现有发送中，证明没有处理完，要人工检查下为什么。</p><p>多发有在一个机器或多台机器启动多个进程，导致多发。</p><p>还有同样一个请求，两次发送，导致多发。这种要用唯一id保证幂等性，及时相同的请求出现多次，也不会造成多发情况。唯一id要用能唯一标识发送记录的字段，而不应该用时间戳，随机值等每次都变的变量。</p><h3 id="发送通知也要防止多发"><a href="#发送通知也要防止多发" class="headerlink" title="发送通知也要防止多发"></a>发送通知也要防止多发</h3><p>防止一个人发送了多条通知消息；</p><p>防止把通知消息发送给未中的人。</p><p>这些都要控制好发送逻辑，要经过细心review才能发现。</p><h3 id="对账机制"><a href="#对账机制" class="headerlink" title="对账机制"></a>对账机制</h3><p>对于发奖，要有对账机制，实际用户抽到的奖励，和发送的要有数量价值比对。做好风控和审计。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抽奖和发奖，想做好并不容易。要多思考很多细节才能做好。</p><p>本质上就是让程序可控，一切尽在控制。</p><p>程序的并发、幂等性，产品逻辑的扩展性，奖品数量调整，概率调整，都需要经过推敲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何设计抽奖活动&lt;/p&gt;
&lt;h2 id=&quot;抽奖的意义&quot;&gt;&lt;a href=&quot;#抽奖的意义&quot; class=&quot;headerlink&quot; title=&quot;抽奖的意义&quot;&gt;&lt;/a&gt;抽奖的意义&lt;/h2&gt;&lt;p&gt;抽奖是一个很好的运营手段，通过抽奖，能够短时间内吸引大量用户，让用户集中使用产品。&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>毕业生如何准备技术类面试</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%AF%95%E4%B8%9A%E7%94%9F%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%8A%80%E6%9C%AF%E7%B1%BB%E9%9D%A2%E8%AF%95/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%AF%95%E4%B8%9A%E7%94%9F%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%8A%80%E6%9C%AF%E7%B1%BB%E9%9D%A2%E8%AF%95/</id>
    <published>2018-10-27T09:00:33.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>又到了一年一度的校园招聘时间，最近面试了上百个毕业生，发现很多学生没有准备好面试，也不会面试。 毕业生究竟如何准备校园招聘呢？写些建议，希望能够对毕业生有所帮助。</p><h3 id="了解自己的需求。"><a href="#了解自己的需求。" class="headerlink" title="了解自己的需求。"></a>了解自己的需求。</h3><p>自己的兴趣是什么，擅长什么技术，对自己有个清晰的认识。到底适合什么公司，什么岗位，有目标的准备面试，会节约时间，提升通过率。</p><h3 id="了解公司的需求。"><a href="#了解公司的需求。" class="headerlink" title="了解公司的需求。"></a>了解公司的需求。</h3><p>通过师兄师姐，网上搜集，对心仪的公司有一定的了解。衡量下公司是否和自己的需求相匹配。还要知道公司的要求，因为找工作是双向选择。 公司都要经过笔试面试等几轮筛选，才能选中一个候选人。不同公司，不同岗位的面试规则都不大一样，毕业生可以通过网络搜索。甚至有些 面试题网上都有，可以模拟准备下。</p><h3 id="积极准备。"><a href="#积极准备。" class="headerlink" title="积极准备。"></a>积极准备。</h3><p>最重要的准备在平时，在大学的几年学习中已经完成。把专业课学好，把要过的考试都给过了，把老师留得作业都认真完成，就是最好的准备了，也是最基本的。 准备简历，简历不用太花哨，能够突出自己的能力就行。内容简洁重点突出，让人在几秒钟能阅读到你的优势。例如擅长什么语言，获得过奖学金等。 如果不是自己擅长的，千万不要写。技术类的面试，面试官会针对简历上的内容深挖，会给面试挖坑。</p><h3 id="与面试官交流"><a href="#与面试官交流" class="headerlink" title="与面试官交流"></a>与面试官交流</h3><p>学生是学校的名片，行为举止和谈吐都代表了学校。一旦决定面试，就展示出最好的一面。一般面试官都会最开始让自我介绍。这是一个重要的环节，做好了会有很好的 第一印象。准备面试的时候可以多联系下，在一两分钟内把自己的优势介绍出来。 在问题问答环节，如果发现某个知识点不会，面试官还不停地问，直接说自己不擅长这方面就可以了。 有时面试官会给些提示，要重视，都不是随便问的，一定是哪里没想清楚，要顺着指引找下原因。 题目出来先说下思路，不要直接就做，为什么要有面试，而不是直接放到一边笔试，就是有个交流沟通的场景。如果错的太离谱，面试官会给些提示。 尽量节省自己的面试时间，不要一个问题纠结太久，面试官面试的同学非常多，在一些题目上和面试官纠缠，导致最后时间剩的太少，影响面试的质量。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>公司面试毕业生，看中的是<strong>学习能力，聪明度</strong>，后期到公司会再培养。毕业生重要的是学好基础，展示学习能力，而且不要固守一种技术。在学校学的是很初级的，要有 拥抱变化，随时学习新方向的能力。时代发展很快，明天流行的东西，可能今天还没发明出来，如果固步自封敝帚自珍，会被时代所淘汰。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>毕业生要对自己和公司都有清晰的认识，今天面试的成败，都是大学日常学习积累的结果。 和面试官的有效沟通，完美地展示自己的能力，才能顺利通过面试。 <strong>任何时候都不要忘了学习，都要有颗终身学习的心。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又到了一年一度的校园招聘时间，最近面试了上百个毕业生，发现很多学生没有准备好面试，也不会面试。 毕业生究竟如何准备校园招聘呢？写些建议，希望能够对毕业生有所帮助。&lt;/p&gt;
&lt;h3 id=&quot;了解自己的需求。&quot;&gt;&lt;a href=&quot;#了解自己的需求。&quot; class=&quot;header</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>我能贡献什么-《卓有成效的管理者》第3章</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%88%91%E8%83%BD%E8%B4%A1%E7%8C%AE%E4%BB%80%E4%B9%88-%E3%80%8A%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E3%80%8B%E7%AC%AC3%E7%AB%A0/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%88%91%E8%83%BD%E8%B4%A1%E7%8C%AE%E4%BB%80%E4%B9%88-%E3%80%8A%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E3%80%8B%E7%AC%AC3%E7%AB%A0/</id>
    <published>2018-10-18T13:25:37.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-我能贡献什么"><a href="#第三章-我能贡献什么" class="headerlink" title="第三章 我能贡献什么"></a>第三章 我能贡献什么</h2><p>有效的管理者注重贡献，并懂的将自己的工作与长远目标结合起来，强调责任。 重视贡献是有效性的关键。有效性包括： 1. 自己的工作，包括工作内容、工作水准及其影响； 2. 自己与他人的关系，包括上司、对同事和下属； 3. 各项管理手段的运用，例如会议或报告等。 但大多数人只重视勤奋，忽略成果。 一个重视贡献的人，注意对成果负责的人，才算是管理人员，因为对整个机构的经营绩效负责。 所以，每个管理者都要经常思考一个重要的问题 <strong>「我能贡献什么」</strong>。</p><h3 id="管理者的承诺"><a href="#管理者的承诺" class="headerlink" title="管理者的承诺"></a>管理者的承诺</h3><p>要注重外部需求，而不是局限于自己的技术，所属部门等。只有外部世界才是产生成果的地方。 许多工作看起来辉煌，但是与潜在的贡献比起来，实在是微不足道。 刚开始做开发的同学，总是想运用新技术，升级新软件，各种尝试方法。如果被阻止还会有些愤愤不平。只是从技术的角度出发，没有从贡献的角度。明明跑的很稳定，为什么要去折腾换工具，升级软件也有很大风险，而且从贡献上也没有变化，但看起来很诱人，很振奋人心。 一般机构对成效的要求表现在： 1. 直接成果 2. 树立新的价值观及对这些价值观的重新确认 3. 培养与开发明天所需要的人才 直接成果很简单，就是组织的明确要求，考核指标生产指标等。 价值观对组织就很重要了，一个组织要有自己的主张和想法，否则难免解体、混乱和瘫痪。例如阿里巴巴：让天下没有难做的生意。大家靠着相同的价值观汇聚到一起，当有时走到了分岔路，不知道如何选择时，价值观会为我们指一条明路。（如果看不懂，慢慢体会，有些经历就看懂了。人生也是如此。） 组织存活的时间可以比人的生命要长，要想基业长青，就要英才辈出，让组织有新的活力，让组织存活下去。培养人才就是对组织延续发展的贡献。 管理者常见的失败，不能或不愿意为适应新的职位的需要而改变。不能总躺在从前的功劳簿上。有时人的成功和运气也有关，但是运气不是每次都光顾，所以还是要重视客观环境，不断适应环境的变化，才能不断成功。 管理者要常想：「我能有什么贡献」这个问题。这才是一个合格的管理者，才是一个有发展的管理者。 自己也思考过这个问题： 以我的技术能力把架构做好，以项目管理经验把项目做好，为组织培养更多的人才。 把我的所知，所学，经验包括教训，都传递给年轻人，让他们能够快速发展，承担更重要的工作，产出更大的贡献。 一方面对组织有利，另一方面也是传承，我的今天也得益于前辈的悉心教导。</p><h3 id="如何使专业人员的工作卓有成效"><a href="#如何使专业人员的工作卓有成效" class="headerlink" title="如何使专业人员的工作卓有成效"></a>如何使专业人员的工作卓有成效</h3><p>专业人员要开放，要把自己的知识让更多人能够理解。要从别人的需要角度出发，把知识转化为生产力，对社会产生作用，有效用，才能有所贡献，才是卓有成效。 不能守着知识敝帚自珍，脱离实际需要，那样产生不了价值。</p><h3 id="正确的人际关系"><a href="#正确的人际关系" class="headerlink" title="正确的人际关系"></a>正确的人际关系</h3><p>有良好人际关系的管理者，工作也因此富有成效。 有良好人机关系的管理者，可能性格不同，但有共同特点：忠诚待人，令人乐于亲近。为别人着想。真诚。 一个好汉三个帮，人在组织中，在社会中，都需要别人的帮助才能把事情做好。我们的成长，发展，都离不开别人的帮助，同样，我们也要帮助别人。有良好的人际关系，才能让别人愿意与你沟通，愿意帮你。一个人浑身是铁，能碾几颗钉。 有效人际关系的四项基本条件： - 互相沟通 - 团队合作 - 自我发展 - 培养他人 一些下属是不知道以贡献为重的，管理者有责任，让大家思考组织的期望，如何能有贡献。 希望下属以贡献为重：「我们的组织和我，应该期望你有怎样的贡献呢？我们该期望你做什么？如何才能使你的知识和能力得到最大的发挥？」 给下属空间，让下属自己思考对组织的贡献，让下属自己设定目标。 团队间要互相支持，也要注重贡献，会更容易促成合作。在同一个组织贡献是一致的，大家都有所贡献，朝一个目标发展。</p><h3 id="有效的会议"><a href="#有效的会议" class="headerlink" title="有效的会议"></a>有效的会议</h3><p>高效会议，在会前就想清楚会议的目的，开会必须真正有所贡献。 不能既主持会议又高谈阔论。 会议要高效，要有效，一个管理者很多时间都是在开会，这部分时间的效率，对有效性影响很大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思考我能贡献什么，就是从目标出发。能够让人在一团乱麻事务中，理出轻重缓急。 个人发展和贡献联系在一起，就能最大程度的被需要。 <strong>重视贡献，就是重视有效性!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-我能贡献什么&quot;&gt;&lt;a href=&quot;#第三章-我能贡献什么&quot; class=&quot;headerlink&quot; title=&quot;第三章 我能贡献什么&quot;&gt;&lt;/a&gt;第三章 我能贡献什么&lt;/h2&gt;&lt;p&gt;有效的管理者注重贡献，并懂的将自己的工作与长远目标结合起来，强调责任。 重视</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>《卓有成效的管理者》1-2章读书笔记</title>
    <link href="https://yunpengzhang.github.io/2018/%E3%80%8A%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E3%80%8B1-2%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://yunpengzhang.github.io/2018/%E3%80%8A%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%E3%80%8B1-2%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2018-09-25T10:40:07.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司组织大家学习管理，第一本就是《卓有成效的管理者》。这本书已经看过多次。为了这次学习，又重新看了一遍。常翻常新，又有新的体会。 书还是那本书，内容也没有变，变化的是人。经历了一些事，思维转变后，再看相同的文字，就有了不同的体会。</p><h2 id="为什么要读这本书"><a href="#为什么要读这本书" class="headerlink" title="为什么要读这本书"></a>为什么要读这本书</h2><p><strong>首先，这是一本很有“名气”的书。</strong> 书的作者是彼得.德鲁克。管理学大师中的大师。本书第一次出版在1966年，历经了半个多世纪，被翻译成20多种语言，在亚洲、欧洲、美洲等许多国家，都被印证是管理学的经典。海尔集团张瑞敏先生，运用德鲁克的管理学方法，对海尔集团的管理进行改进，「日清」工作法让海尔集团的冰箱业务脱颖而出。早期中央干部学习管理，也有人推荐这本书。朱镕基总理也评价过该书——对改革开放的影响是难以估量的，“其意义有如西方文艺复兴运动的启蒙作用”。 <strong>其次，这是一本言简意赅，干货满满的书。</strong> 全书供八个章节，不到200页。但是浓缩了成为卓有成效管理者的全部精华。语言直白易懂，不到一天，就能读完全部内容。是入门管理学的佳作。也是提升自身素质的良师。<strong>知识工作者，都应该阅读《卓有成效的管理者》，也必须卓有成效。</strong></p><h3 id="管理者的自身发展"><a href="#管理者的自身发展" class="headerlink" title="管理者的自身发展"></a>管理者的自身发展</h3><p>这是一本告诉管理者如何管理自己的书。<strong>如果管理者连自己都管理不好，还怎么管理其他人。</strong> 组织的成功依赖于管理者卓有成效，管理者必须卓有成效，否则对组织来说就没有价值。身为管理者，必须要学习如何卓有成效。 任正非说过，公司只看功劳，不看苦劳。如果只有苦劳，还要罚，因为浪费了公司的资源。</p><h3 id="客观局限"><a href="#客观局限" class="headerlink" title="客观局限"></a>客观局限</h3><p>管理者也有写客观局限，必须通过学习，来提高有效性。 有效性是很难达成的。主要有三点： 1. 管理者面临的问题大多是不确定，具有不确定性。(可参考「问题的分析与解决」) 2. 管理者的时间属于别人。 3. 管理者所面对的问题，必须采取行动，才能改变一切。 管理者的工作和面临的挑战，要求管理者必须要通过学习来提升自己，克服已有的困难，解决存在的不确定，不明晰的问题。 另外，管理者一般也是某个领域的专业人士，专业认识容易因专们学问而自满，不屑于其他领域。在刚成为管理者的人身上，容易看到这点。</p><h2 id="第一章-卓有成效是可以学会的"><a href="#第一章-卓有成效是可以学会的" class="headerlink" title="第一章 卓有成效是可以学会的"></a>第一章 卓有成效是可以学会的</h2><p>有效性是一种后天习惯，是一种实践的综合。能够通过学习，实践来掌握。 是一门科学，而不是艺术。不需要具备超于常人的天赋，就可以学习获得。对于个人来说是个好消息，因为世界上大多数人都是普通人。对组织来说也是个好消息，寻找或培养卓有成效的管理者，比需要通才或天才要更容易。 卓有成效主要包含以下几个方面，本书都是针对这几方面展开： 1. 善用时间 2. 重视贡献 3. 用人所长 4. 要事优先 5. 有效决策（科学决策） 组织对管理者的要求：<strong>按时做完该做的事情；对组织有贡献，才算有效。</strong></p><h3 id="谁是管理者"><a href="#谁是管理者" class="headerlink" title="谁是管理者"></a>谁是管理者</h3><p><strong>每一位知识工作者，都是管理者。</strong> 这本书写于60年代，当时依靠肌肉和双手的体力劳动逐步被脑力劳动所取代。脑力劳动的产出是<strong>知识、创意和信息</strong>。知识工作者的作用越来越重要，但对知识工作者的要求和监督是很模糊的，很难量化、明确。 要求知识工作者利用知识技能进行产出时，无法验密细致地进行监督，只能协助。知识产出的成果难以量化，并且很难在短期衡量效果。 这些要求知识工作者必须对自己进行管理，提高有效性，才能充分发挥价值。</p><h2 id="第二章-掌握自己的时间"><a href="#第二章-掌握自己的时间" class="headerlink" title="第二章 掌握自己的时间"></a>第二章 掌握自己的时间</h2><h3 id="记录自己的时间"><a href="#记录自己的时间" class="headerlink" title="记录自己的时间"></a>记录自己的时间</h3><p>要想解决问题，必须要发现问题。人的感觉是不可靠的，管理者想到自己的时间花费，通常是他自己的意愿，而不是实际。要即时记录，即使事后回忆补录都不准确。</p><h3 id="管理时间"><a href="#管理时间" class="headerlink" title="管理时间"></a>管理时间</h3><p>要高效管理时间，要事优先，合理安排时间。才能有更多的时间<strong>做正确的事，而非正确地做事</strong>。（关于时间管理可以参考「如何高效工作」沙龙分享）</p><h3 id="统一安排时间"><a href="#统一安排时间" class="headerlink" title="统一安排时间"></a>统一安排时间</h3><p>也属于时间管理的一部分。管理者的一些工作，就是要消耗大块时间来思考和处理的。所以要安排出多的时间拉来进行。例如组织内谈话、人事决策……</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>卓有成效是可以学习的，只要用心学习，注重实践，一定能学会的。最根本还是心态上的改变。一些道理想通了，后面的学习方向就很自然被掌握。</p><h3 id="管理者的时间不是属于自己的"><a href="#管理者的时间不是属于自己的" class="headerlink" title="管理者的时间不是属于自己的"></a>管理者的时间不是属于自己的</h3><p>管理者要想产生绩效，有所贡献，必须和组织外进行沟通。有很多人依赖你，要和你沟通，需要你确认，所以你的时间就是要做这些事情的。 <strong>管理者的时间往往只属于别人，而不属于自己。</strong>甚至可以说是组织的「囚徒」。每一个人都可以随时来找他。</p><h3 id="管理中的一些事，就是要花费很长时间的"><a href="#管理中的一些事，就是要花费很长时间的" class="headerlink" title="管理中的一些事，就是要花费很长时间的"></a>管理中的一些事，就是要花费很长时间的</h3><p>管理者要维护组织内的人事关系，要做一些人事决策。这些在专业知识领域是几乎不涉及的，也是初级管理者所不擅长的。通常会产生疑问，为什么要用这么多的时间来处理这些事情。但这是必须的，这就是管理者的日常工作内容之一，而且处理人事问题就是要用很多时间。如果太过于匆忙，还会起到反作用。</p><h3 id="克服「人性」"><a href="#克服「人性」" class="headerlink" title="克服「人性」"></a>克服「人性」</h3><p>好的组织就是单调乏味的，因为一切都正常运转。没有那么多激动人心的事情发生。有些管理者认为好的组织是轰轰烈烈的，其实不然，正常的组织，一切都井然有序，在可控的范围内。<strong>危机都早已预见，且已将解决办法变成了例行工作。</strong>就如同一部精确的钟表，精准地运行。生活也是一样，很难像影视剧中那样每天都此起彼伏。 人本身是爱拖延，成为管理者要自律，要做很多克制和自律的事情。 <strong>同一个危机如果重复出现，往往是疏忽和懒散造成的。</strong> 要求管理者必须采取行动，克服惰性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过前两章的学习，能够对全书有个概括理解。知道为什么要卓有成效，卓有成效的标准。对具体的「管理者掌控自己时间」有深一步的了解，学会掌控自己的时间。迈出成为卓有成效管理者的第一步。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近公司组织大家学习管理，第一本就是《卓有成效的管理者》。这本书已经看过多次。为了这次学习，又重新看了一遍。常翻常新，又有新的体会。 书还是那本书，内容也没有变，变化的是人。经历了一些事，思维转变后，再看相同的文字，就有了不同的体会。&lt;/p&gt;
&lt;h2 id=&quot;为什么要读这本</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始跑——《爱上跑步的十三周》</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%B7%91%E2%80%94%E2%80%94%E3%80%8A%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5%E7%9A%84%E5%8D%81%E4%B8%89%E5%91%A8%E3%80%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%B7%91%E2%80%94%E2%80%94%E3%80%8A%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5%E7%9A%84%E5%8D%81%E4%B8%89%E5%91%A8%E3%80%8B/</id>
    <published>2018-09-22T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>《爱上跑步十三周》是一本很适合初级跑者的入门书。通过这本书，能够养成跑步的习惯，了解跑步的初级常识，最终能够跑到10公里。</p><p>按照书中的介绍，完成了13周的训练，亲测有效。</p><p>如果想养成了跑步的习惯，对跑步这项运动也有兴趣，那么入门跑步就读这本书吧。</p><h2 id="为什么跑步"><a href="#为什么跑步" class="headerlink" title="为什么跑步"></a>为什么跑步</h2><p>书中列举了很多跑步的原因，总体跑步的原因有两种：<strong>身体健康、提升毅力</strong>。</p><h3 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h3><blockquote><p>锻炼身体的人血管中瘀块较少，心脏病发作和中风的风险也就小。</p><p>适度的锻炼还能够提高免疫系统的功能，这是通过改善杀手T细胞的功能来实现的。</p><p>锻炼能够缓解压力。</p></blockquote><p>跑步能够锻炼身体，生命在于运动，从而对心脏，肌肉，免疫系统都有好处。</p><p>周围经常跑步的人身体都很好，还能够消耗脂肪，达到减肥健身目的。</p><blockquote><p>锻炼可以激发身体产生内啡肽——身体内天然的止痛剂。</p></blockquote><p>跑步一段时间后，会对跑步特别感兴趣，跑完身体会很轻松，就像吸烟一样。是因为身体分泌了「啡肽」，是一种无害的「兴奋剂」，增强跑步的欲望。</p><h3 id="提升毅力"><a href="#提升毅力" class="headerlink" title="提升毅力"></a>提升毅力</h3><blockquote><p>虽然实施一个跑步计划需要毅力，但是这种毅力可以在你生活的方方面面帮助你。</p></blockquote><p>十三周，跨度很长，能够坚持下来很不容易。</p><p>中间会遇到下雨，会有加班……你要克服种种困难，才能坚持下来。</p><p>一路走来，如果没有清晰的目标，和坚强的意志，是很难完成全部训练的。生活中的其他问题，亦需要同样的精神去坚持。经此训练，磨练自信和意志，提升自己的毅力。</p><h2 id="为跑步作好准备"><a href="#为跑步作好准备" class="headerlink" title="为跑步作好准备"></a>为跑步作好准备</h2><h3 id="适度"><a href="#适度" class="headerlink" title="适度"></a>适度</h3><blockquote><p>一般认为心血管系统比肌肉骨骼系统更强壮。<br>不幸的是，你的骨骼、韧带、肌腱和肌肉并不能相应地作出调整。</p></blockquote><p>跑步初期呼吸系统和心脏会进步很快，但是身体的肌肉骨骼是跟不上的。大脑的感觉是还能跑，但是四肢是难以支撑这种感觉的。需要适度训练，不要着急，按照课程的频率，跑量进行训练。</p><p>即使在后期成为初级跑者了，也要时刻警告自己，倾听身体的声音，不要突然加大跑量。</p><h3 id="一致"><a href="#一致" class="headerlink" title="一致"></a>一致</h3><blockquote><p>当你的训练保持一致的时候，你的身体会有更多的时间来适应训练的强度。更重要的是，如果你保持一致，就没有必要去弥补失去的时间。一两天额外的艰苦训练不能弥补那些错过的训练课程。<br>锻炼后感觉有点僵硬和酸痛并不完全是坏事，它是让你身体变得更强健的过程的一部分。</p><p>无氧能量的供给能够持续5~60秒在无氧状态中，化学反应产生的乳酸会聚集在肌肉中。研究人员认为这导致了剧烈运动后的肌肉酸痛。同样，根据身体强健状况不同，你的身体需要一天或更长的休息时间来消除乳酸。</p></blockquote><p>循序渐进，不要一曝十寒。训练是长期的，要坚持的，一天跑三小时，不如一周三天每天跑一小时。</p><p>训练和长跑都是看长期，看谁能一直坚持到最后，在人生和养成习惯方面也是一样，偶尔的一次勤奋，并不能弥补一直的懒惰。</p><h2 id="跑步计划"><a href="#跑步计划" class="headerlink" title="跑步计划"></a>跑步计划</h2><p>书中最精华的部分，针对初级跑者，给出了一份循序渐进的跑步计划。一共有13周的训练，每周3次。</p><p>前6周都是跑步、走路穿插训练，跑几分钟中间走几分钟。</p><p>在第6周后，根据训练效果，选择完全跑步训练，或者继续跑走训练。</p><p>一般不经常跑步的人，开始很难跑很久，会容易有挫败感。用6周的跑走练习，能够让人坚持跑步计划，养成每周3次的跑步习惯。在此期间，体能也会提高，更适应跑步训练。</p><p>我跑完6周后，感觉进步明显，到第10周以后，才开始完全的跑步训练。</p><p>计划表是死的，不用墨守成规，在训练过程中，要根据自己的实际情况进行选择和替换。要倾听自己身体的声音。</p><p>跑步训练还有一步，就是写训练笔记。通过笔记，能够回顾训练过程中的进步，及时得到反馈，有助于坚持跑步计划。</p><p>文末有详细计划表的下载链接。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>养成良好的生活习惯，注意健康饮食，合理睡眠，适度休息。</p><p>在每次跑步之前和跑完之后，都要做十分钟左右的拉伸，能够减少运动损伤的风险，也能加速身体恢复。</p><p>没有训练的日子里，做些交叉训练，效果会更好。例如在下雨天做下俯卧撑，或者跳绳，能够休息跑步时用到的肌肉。而且人体是个整体，其他部分的肌肉得到锻炼后，也能够增强跑步的能力。</p><p><strong>拉伸、健康饮食、合理休息对跑步效果影响很大。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跑步的目的是为了健康，在训练的过程中，要注意<strong>适度</strong> 和 <strong>一致</strong>。</p><p>要关注你身体的反馈，不舒服就休息，严重就看医生，身体健康是第一前提。</p><p>循序渐进，不要一曝十寒。训练是长期的，要坚持的，一天跑三小时，不如一周三天每天跑一小时。</p><p>当你按照训练表格完成训练时，你已经是一个初级跑者了，那时你经验更丰富，能知道下一步需要做什么，那时会自己寻找到更高阶的跑步知识。</p><p>重要的不是跑了多少或跑了多快，而是通过跑步强健了身体，养成好的运动习惯，通过跑步磨练毅力。跑量和速度，在养成习惯后，会自然的获得的，是过程中顺带得到的，不用强求。</p><p>就像生活，把财富、名利作为人生的目标，一味地去追求，反而很难获得，而且会很功利，影响你的发挥。当有更高层次的人生追求，和对做的事情产生发自心底的兴趣，并投入全部热情，不想成功都难。喜欢做，想做，那么就放手去做。就像nike的广告语——「JUST DO IT.」。</p><hr><p> <a href="./%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%B7%91%E2%80%94%E2%80%94%E3%80%8A%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5%E7%9A%84%E5%8D%81%E4%B8%89%E5%91%A8%E3%80%8B/%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5%E7%9A%8413%E5%91%A8+%E8%AE%A1%E5%88%92%E8%A1%A8.pdf">爱上跑步的13周+计划表.pdf</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《爱上跑步十三周》是一本很适合初级跑者的入门书。通过这本书，能够养成跑步的习惯，了解跑步的初级常识，最终能够跑到10公里。&lt;/p&gt;
&lt;p&gt;按照书中的介绍，完成了13周的训练，亲测有效。&lt;/p&gt;
&lt;p&gt;如果想养成了跑步的习惯，对跑步这项运动也有兴趣，那么入门跑步就读这本书吧。</summary>
      
    
    
    
    <category term="跑步" scheme="https://yunpengzhang.github.io/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>你的能力超乎你想象</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BD%A0%E7%9A%84%E8%83%BD%E5%8A%9B%E8%B6%85%E4%B9%8E%E4%BD%A0%E6%83%B3%E8%B1%A1/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BD%A0%E7%9A%84%E8%83%BD%E5%8A%9B%E8%B6%85%E4%B9%8E%E4%BD%A0%E6%83%B3%E8%B1%A1/</id>
    <published>2018-09-20T15:25:00.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>上周去华科校招，宣讲会结束后笔试，几名同学直接背书包走了。以为对公司的宣讲有什么意见。但原因是几名同学是电子学院的，只学过C语言，没学过C++，看到我们招的是C和C++方向，认为不满足主动放弃了。而且说只找C语言的工作，不考虑其他的语言。</p><p>只是语言的原因，就固步自封，着实可惜。大公司校招，考察的是基础知识和对问题的解决思考能力。笔试、面试题都是针对基础来考察的。只要在校有认真学习，就能顺利通过笔试。但是这几名同学自己把自己给否定了。我们的职位非常多，而且待遇不错，只要基础够，想选哪个都可以。</p><p>毕业生要自己给自己创造机会。你是否渴望这个职位，你是否要找这份工作。<br>如果回答都是“是”，那么就努力去做，不要想太多，把你的能力都发挥出来。<br>如果自认为能力欠缺，那么缺什么补什么。<strong>你想要得到什么，就先要配得上它。</strong></p><p>先思考清楚目标，为了实现目标需要什么本领，<br>然后<strong>刻苦学习，深入思考，刻意练习</strong>。<br>让自己达到要求的水平。<br>而不是人云亦云，看别人做什么跟着做什么。<br><strong>经过思考，就算跟大家的选择相同，你也是经过思考的，是活得明白的。</strong></p><p>当然，就算有了很强的能力，也要谦虚谨慎，人外有人，天外有天。</p><p>乔帮主是创造机会的典范。在《乔布斯传》中写到：</p><blockquote><p>他拿起电话打给了惠普的CEO：“那个时候，所有的电话号码都是登记在册的，所以我在电话簿上寻找住在帕洛奥图的比尔·休利特，然后打到了他家。他接了电话并和我聊了20分钟，之后他给了我那些零件，也给了我一份工作，就在他们制造频率计数器的工厂。”乔布斯髙中第一年的暑假就在那里工作，主要就是在一条流水线上“安装基本元件”。</p></blockquote><p>乔帮主需要电子原件，就直接打电话给惠普CEO。<br>换做大多数人都会心存顾虑，找一万个理由不去做这件事。<br>可实际是只要去做，就成了。在后来乔帮主做iPhone，iPad，<br>，所以他的成功和他为自己创造机会，不放弃是强相关的</p><p>日常工作中也一样，一件事不去做，能够找到一万种理由放弃。但成功的人只需要看到<br>一个机会。<strong>要关注事情的价值，而不是困难。</strong></p><p>机会偏爱有准备的人，当准备好了后，要主动去创造机会。<br>当上帝关上了一扇门时，要能踹开一扇窗。</p><p>光有自信，胆子大是远远不够的。还要有能力。很少有人的能力是天生下来，跟着身体生长的。普通人都要经过刻苦学习，独立思考，刻意练习提升能力，一步都不能少。</p><p>要思考你的目标，你到底是要做什么，认真做选择做决策。要找工作，找什么样的工作，为了钱？为了进入互联网行业？为了去一线城市？要有明确的目标，经过思考和分析后认真做决定。</p><p>千万不要人云亦云，那是大多数人的选择，不是你的选择。及时最后思考也是和大家一样，但是你思考过，你知道你要的是什么，带着目的去准备，去奋斗，会更有力量。</p><p>在生活中也同样，要着眼于机会，而不是困难。做什么事情要做好都很难，各行各业都累。为了目标，就得去奋斗，因为困难而止步，特别是还没有尝试就放弃，失败的原因你是自己，怪不得困难。</p><p>即使能力很强，也要有敬畏之心，谦虚谨慎。毕竟人外有人天外有天！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上周去华科校招，宣讲会结束后笔试，几名同学直接背书包走了。以为对公司的宣讲有什么意见。但原因是几名同学是电子学院的，只学过C语言，没学过C++，看到我们招的是C和C++方向，认为不满足主动放弃了。而且说只找C语言的工作，不考虑其他的语言。&lt;/p&gt;
&lt;p&gt;只是语言的原因，就固</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>素食跑步修行</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%B4%A0%E9%A3%9F%E8%B7%91%E6%AD%A5%E4%BF%AE%E8%A1%8C/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%B4%A0%E9%A3%9F%E8%B7%91%E6%AD%A5%E4%BF%AE%E8%A1%8C/</id>
    <published>2018-09-10T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>这本书的作者是“斯科特.尤雷克”，他是一名著名的超级马拉松运动员，获得过很多超级马拉松的冠军和记录。书的主要内容是斯科特的跑步生涯的介绍，从他小时候，一直到他成年参加各种超级马拉松的经历。</p><p>开始很想读这本书，以为会介绍一些跑步的方法和技巧；中间不怎么爱读，发现是作者的自传，和跑步技巧比较少相关；后面又很想读，因为比赛的经历还是有些挺精彩的。</p><p>书中的素食参考性不大，材料比较难买，而且并不一定适合国人。网上有热心人总结了菜谱，感兴趣的可以照着烹饪。<br><a href="https://www.douban.com/note/612997316/">‘ 超马之神 ’ 的 素食食谱 – 整理自《素食 跑步 修行》</a></p><p>他小时候他爸爸和他说“去做就对了”对他影响很深，他遇到问题时都是思考这个问题。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得心神安宁的钥匙</span><br><span class="line"></span><br><span class="line">我跑步，并保持跑步的习惯，正是因为我领悟到：一旦你开始做某件事，而且一直没有放弃，你就得继续做下去。这是生命的真谛，也像超马赛事一样，没有回头路，只能向前跑。</span><br><span class="line"></span><br><span class="line">方法只有一个：爬起来，继续跑。人生中遭遇任何困难，解决方法永远是努力向前走！</span><br></pre></td></tr></table></figure><p>在2001和2002参加香港乐施毅行者，获得冠军还破了记录。 </p><p>超马更多靠的是意志，有恶劣的天气，伤痛，都要坚持跑完，还有强劲的竞争者。能够冲过终点线，都是很不容易的。<br>跑步可以去各种地方跑，领略各种不同的风土人情。<br>跑步的对手，在生活中还成了朋友，一起生活和训练。</p><p>对于参加毅行者的同学，是有参考意义的，通过这个能够了解超级马拉松的跑步和训练过程，对超马有所了解。而且有些章节的内容还是很精彩的。</p><p>跑者中有些怪人，而且印第安人也有擅长跑步的塔拉乌马拉人，跑超跑的人并不是为了名和钱靠那些很难坚持跑完。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书的作者是“斯科特.尤雷克”，他是一名著名的超级马拉松运动员，获得过很多超级马拉松的冠军和记录。书的主要内容是斯科特的跑步生涯的介绍，从他小时候，一直到他成年参加各种超级马拉松的经历。&lt;/p&gt;
&lt;p&gt;开始很想读这本书，以为会介绍一些跑步的方法和技巧；中间不怎么爱读，发现</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="跑步" scheme="https://yunpengzhang.github.io/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>十分钟了解ZAB（Zookeeper Atomic Broadcast）协议</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ZAB%EF%BC%88Zookeeper%20Atomic%20Broadcast%EF%BC%89%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ZAB%EF%BC%88Zookeeper%20Atomic%20Broadcast%EF%BC%89%E5%8D%8F%E8%AE%AE/</id>
    <published>2018-09-07T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper基于ZAB（Zookeeper Atomic Broadcast），实现了主备模式下的系统架构，保持集群中各个副本之间的数据一致性。</p><p>ZAB协议定义了选举（election）、发现（discovery）、同步（sync）、广播(Broadcast)四个阶段。</p><p>选举（election）是选出哪台为主机；<br>发现（discovery）、同步（sync）当主选出后，要做的恢复数据的阶段；</p><p>广播(Broadcast)当主机和从选出并同步好数据后，正常的主写同步从写数据的阶段。</p><p>下面简单地介绍下ZAB协议，目的是能够快速了解其精髓，快速掌握ZAB协议。然后通过论文了解具体协议的细节。主要介绍选举和广播两个阶段。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们了解下zk的一些基本概念。</p><p>zk集群有三种角色：</p><ul><li>leader 就是我们说的主；</li><li>follower 就是我们说的从；</li><li>observer 可以认为是主的clone copy，不参与投票，本文可忽略；</li></ul><p>zk集群的一个节点，有三种状态：</p><ul><li>looking 选举状态，当前群龙无首；</li><li>leading leader才有的状态；</li><li>following follower才有的状态；</li></ul><p>每次写成功的消息，都有一个全局唯一的标识，叫zxid。是64bit的正整数，高32为叫epoch表示选举纪元，低32位是自增的id，每写一次加一。<br>可以想象为中国古代的年号，例如万历十五年，万历是epoch，十五年是id。</p><p>zk集群一般都是奇数个机器（2n+1）,只有一个主机leader，其余都是从机follower。选主还是写数据，要有&gt;&#x3D;n+1台选举相同，才能执行选举的操作。</p><p>投票优先级：优先比较zxid，如果相等，再比较机器的id，都按从大到小的顺序。</p><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>当集群新建，或者主机死机，或者主机与一半或以上的从机失去联系后，都会触发选择新的主机操作。有两种算法<code>fast paxos</code>和<code>basic paxos</code>。</p><h3 id="fast-paxos"><a href="#fast-paxos" class="headerlink" title="fast paxos"></a>fast paxos</h3><p>默认ZAB采用的算法是fast paxos算法。</p><p>每次选举都要把选举轮数加一，类似于zxid里的epoch字段，防止不同轮次的选举互相干扰。</p><p>每个进入looking状态的节点，最开始投票给自己，然后把投票消息发给其它机器。内容为**&lt;第几轮投票，被投节点的zxid，被投节点的编号&gt;**。</p><p>其他looking状态的节点收到后，</p><p>1 首先判断票是否有效。<br>是否有效的方法为看票的投票轮数和本地记载的投票轮数是否相等：</p><p>2.1 如果比本地投票轮数的小，丢弃。</p><p>2.2 如果比本地投票轮数的大</p><pre><code>证明自己投票过期了，清空本地投票信息，更新投票轮数和结果为收到的内容。通知其他所有节点新的投票方案。</code></pre><p>2.3 如果和本地投票轮数相等，按照投票的优先级比较收到的选票和自己投出去的选票。</p><pre><code>2.3.1 如果收到的优先级大，更新自己的投票为对方发过来投票方案，把投票发出去。2.3.2 如果收到的优先级小，则忽略该投票。2.3.3 如果收到的优先级相等，则更新对应节点的投票。</code></pre><p>3 每收集到一个投票后，查看已经收到的投票结果记录列表，看是否有节点能够达到一半以上的投票数。如果有达到，则终止投票，宣布选举结束，更新自身状态。然后进行发现和同步阶段。<br>否则继续收集投票。</p><h3 id="basic-paxos"><a href="#basic-paxos" class="headerlink" title="basic paxos"></a>basic paxos</h3><p>1 每个looking节点先发出请求，询问其他节点的投票。</p><p>其他节点返回自己的投票 &lt; zk的id，zxid &gt;。第一次都投自己。</p><p>2 收到结果后，如果收到的投票比自己投票的zxid大，更新自己的投票。</p><p>3 当收到所有节点返回后，统计投票，有一个节点的选举达到一半以上，则选举成功。<br>否则继续开始下一轮询问，直到选择出leader结束。</p><h3 id="basic-paxos和fast-paxos区别"><a href="#basic-paxos和fast-paxos区别" class="headerlink" title="basic paxos和fast paxos区别"></a>basic paxos和fast paxos区别</h3><p>这里fast是主动推送出，只要结果有更新，就马上同步给其他节点。其他节点可能还没把自己的票通知给所有节点，就发现自己投的票优先级低，要更新投票，然后更新再重新通知给所有节点。</p><p>basic则要每一节点都询问完，才能知道新结果，然后再去问其他节点新的选举结果。</p><p>fast比basic快的地方，是一个节点，不用和每个节点都交换投票信息后，才能知道自己的票是否要更新。会减少交互次数。</p><h2 id="广播——主从同步"><a href="#广播——主从同步" class="headerlink" title="广播——主从同步"></a>广播——主从同步</h2><p>主从同步数据比较简单，<br>当有写操作时，如果是从机接收，会转到主机。做一次转发，保证写都是在主机上进行。</p><p>主先提议事务，收到过半回复后，再发提交。<br>主收到写操作时，先本地生成事务为事务生成zxid，然后发给所有follower节点。<br>当follower收到事务时，先把提议事务的日志写到本地磁盘，成功后返回给leader。<br>leader收到过半反馈后对事务提交。再通知所有的follower提交事务，follower收到后也提交事务，提交后就可以对客户端进行分发了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过只有主控制写然后同步从，保证了生成全局zxid不冲突。全局唯一的zxid能够给选举和同步数据区分出优先级。<br>选举主部分了解fast paxos原理即可。<br>核心思想是<strong>递增的zxid顺序，保证了能够有优先级最高的节点当主。</strong><br>主从同步通过<strong>提议和提交两个阶段</strong>，有超过一半的节点写成功，则认为数据写成功。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.xiaohansong.com/2016/08/25/zab/">Zookeeper ZAB 协议分析</a></p><p><a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf">ZooKeeper’s atomic broadcast protocol:Theory and practice</a></p><p><a href="https://www.jianshu.com/p/8bf3b7ce3eaa">Zookeeper与Paxos</a><br><a href="http://frankfan915.iteye.com/blog/2092779">link</a><br><a href="https://www.jianshu.com/p/ccaecde36dd3">Zookeeper的FastLeaderElection算法分析</a></p><p><a href="http://techlog.cn/article/list/10182987">http://techlog.cn/article/list/10182987</a></p><p>官方文档 – <a href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p><p>paxos algorithm – <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">https://en.wikipedia.org/wiki/Paxos_(computer_science)</a></p><p>What is a simple explanation of the Paxos algorithm? – <a href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm">https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm</a></p><p>Paxos – <a href="http://www.cs.yale.edu/homes/aspnes/pinewiki/Paxos.html">http://www.cs.yale.edu/homes/aspnes/pinewiki/Paxos.html</a></p><p>paxos算法如何容错的–讲述五虎将的实践 – <a href="http://blog.csdn.net/russell_tao/article/details/7238783">http://blog.csdn.net/russell_tao/article/details/7238783</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zookeeper基于ZAB（Zookeeper Atomic Broadcast），实现了主备模式下的系统架构，保持集群中各个副本之间的数据一致性。&lt;/p&gt;
&lt;p&gt;ZAB协议定义了选举（election）、发现（discovery）、同步（sync）、广播(Broadca</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper典型应用场景解析</title>
    <link href="https://yunpengzhang.github.io/2018/zookeeper%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90/"/>
    <id>https://yunpengzhang.github.io/2018/zookeeper%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90/</id>
    <published>2018-09-04T14:19:34.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>zookeeper实现了主动通知节点变化，原子创建节点，临时节点，按序创建节点等功能。通过以上功能的组合， zookeeper能够在分布式系统中组合出很多上层功能。下面就看几个常用到的场景，及使用方式和注意事项。</p><h2 id="名字服务-NameService"><a href="#名字服务-NameService" class="headerlink" title="名字服务(NameService)"></a>名字服务(NameService)</h2><p>顾名思义，就是给分布式系统中的资源，使用人易于理解的名字，能够找到需要的资源。例如：一个统一接口系统，接收服务然后转给后端服务的具体server。当新增接口时，请求方只要传递新接口的名字，系统就能够根据名字找到对应的server，发现服务并转发请求。 在zookeeper中，按照命名的规则，建立对应的目录层级，例如 &#x2F;company&#x2F;team&#x2F;service 就能找到一个公司，一个team下的提供的某个服务的路径。当上线新业务时，服务在zk中找到自己名字的节点，建立一个临时节点，写入配置信息。当调用方使用时，统一接口查询对应目录下的节点，选择合适的读取配置。当业务下掉时，直接删除服务，临时节点自动删除，服务自动下线掉。</p><h2 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理(Configuration Management)"></a>配置管理(Configuration Management)</h2><p>分布式系统位于不同主机的服务，有时要使用统一的配置。可以在zookeeper中的znode节点存储配置数据，每个客户端都监控（watch）znode的变化，当配置变更时，会通知推送，然后各个客户端再拉取新的配置。 注意：zk的watch是一次性的，客户端读取后要重新watch，并且检查是否是最新版本。</p><h2 id="组员管理-Group-Membership"><a href="#组员管理-Group-Membership" class="headerlink" title="组员管理(Group Membership)"></a>组员管理(Group Membership)</h2><p>在Master、Slave模式下，Master要知道都有哪些Slave，进行同步等操作。也要及时知道哪些Slave死掉，然后去做相应处理。具体做法是Master先建立一个&#x2F;Slave节点，每个Slave上线时都在&#x2F;Slave建立一个临时节点，写入配置，server监控&#x2F;Slave节点，对增加或消失的节点进行相应处理。 以上三种用法都属于配置类服务，按照一定的规则进行配置，需要读取配置的地方监控配置的变化。</p><h2 id="简单互斥锁-Simple-Lock"><a href="#简单互斥锁-Simple-Lock" class="headerlink" title="简单互斥锁(Simple Lock)"></a>简单互斥锁(Simple Lock)</h2><p>每个进程都在&#x2F;lock下创建锁znode，并watch &#x2F;lock，只有一个创建成功，当成功的进程释放锁或者停止超时会通知其他进程，重新进入竞争锁的机制。</p><h2 id="互斥锁-Simple-Lock-without-Herd-Effect"><a href="#互斥锁-Simple-Lock-without-Herd-Effect" class="headerlink" title="互斥锁(Simple Lock without Herd Effect)"></a>互斥锁(Simple Lock without Herd Effect)</h2><p>为了不引发惊群效应，只要能给竞争进程排序就可以了，每个进程都在&#x2F;lock的节点下创建带序号的znode，并且每个znode只监听比他次小的节点，当次小的节点释放锁后，比他次大的节点会收到通知，拿到锁权限。 <img src="http://www.owenzhang.net/blog/wp-content/uploads/2018/09/zookeeper.jpg"> 注意：防止还没有执行到的进程死掉，要更新监听顺序。例如：2监听1，3监听2，如果2进程提前死掉，3要监控到这种状态，判断是否是2关闭，还是2释放锁，如果不是正常关闭，要去监听1更新监听。</p><h2 id="读写锁-Read-Write-Lock"><a href="#读写锁-Read-Write-Lock" class="headerlink" title="读写锁(Read&#x2F;Write Lock)"></a>读写锁(Read&#x2F;Write Lock)</h2><p>读写锁：多个读可以并发执行，但是写和读，写和写不能同时执行。 改动互斥锁方案，<strong>如果是写锁，监听他次小的节点，次小节点释放锁后，写锁检测是否还有更小的节点，如果有继续监听，如果没有获得写锁执行</strong>；如果是读锁，监听左侧最大的写锁，当写锁释放后就获得读锁。 也要注意中间节点死掉提前释放的问题，要重新监听节点。 <img src="http://www.owenzhang.net/blog/wp-content/uploads/2018/09/zookeeper1-1.jpg"></p><h2 id="屏障-Barrier"><a href="#屏障-Barrier" class="headerlink" title="屏障(Barrier)"></a>屏障(Barrier)</h2><p>在分布式系统中，屏障是这样一种语义: 客户端需要等待多个进程完成各自的任务，然后才能继续往前进行下一步。 例如凌晨备份，等待每个进程把数据都dump结束后，再打包压缩传走。 client先设置&#x2F;mybarrier的znode，然后启动每个进程，每个进程执行结束成功后，在&#x2F;mybarrier下创建结束的znode节点，client发现&#x2F;mybarrier下的node数都达到了，再继续下面的任务。</p><h2 id="双屏障-Double-Barrier"><a href="#双屏障-Double-Barrier" class="headerlink" title="双屏障(Double Barrier)"></a>双屏障(Double Barrier)</h2><p>双屏障是这样一种语义: 它可以用来同步一个任务的开始和结束，当有足够多的进程进入屏障后，才开始执行任务；当所有的进程都执行完各自的任务后，屏障才撤销。 进入屏障：创建&#x2F;ready和&#x2F;process节点，每个进程都先到ready中注册，注册数量达到要求时，通知所有进程启动开始执行。 离开屏障：在&#x2F;process下把注册ready的进程都建立节点，每个进程执行结束后删掉&#x2F;process下的对应节点。当&#x2F;process下为空时，任务全结束。 锁、屏障，本质都是排序，给要使用的节点排序，根据顺序来执行策略，保证执行不冲突。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的应用场景，并不是只有zk能实现的，而且实现的方式也是通用的，换做其他组件，只要满足了通知和原子创建、自增id，都可以实现这些场景的使用。而且实现的方法也是通用的，不仅在zk中才这样用。 本质上就是统一配置通知机制，和原子简历自增id节点排序机制，实现了配置类和锁类协调的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《ZooKeeper原理及使用》 <a href="http://www.wuzesheng.com/?p=2609">http://www.wuzesheng.com/?p=2609</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;zookeeper实现了主动通知节点变化，原子创建节点，临时节点，按序创建节点等功能。通过以上功能的组合， zookeeper能够在分布式系统中组合出很多上层功能。下面就看几个常用到的场景，及使用方式和注意事项。&lt;/p&gt;
&lt;h2 id=&quot;名字服务-NameService&quot;&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一种快速简洁的一致性哈希算法</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AE%80%E6%B4%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AE%80%E6%B4%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</id>
    <published>2018-09-04T05:34:07.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统路由分配上，一致性哈希算法有很大的优势。在之前的文章中也讲过原理。算法容易理解，但是实现上要注意很多细节，虚节点加入也要消耗更多的存储来维护映射关系。但是今天介绍的<code>jump consistent hash</code>是一种比较新颖的方法，代码简短，内存消耗少。下面我们来详细看看这个算法。</p><p>首先我们先了解下这个算法，有个初步的概念。然后看下这个算法适用于哪些场景，有什么作用。最后，详细分析下算法原理。</p><h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="type">uint64_t</span> key, <span class="type">int32_t</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        key = key * <span class="number">2862933555777941757ULL</span> + <span class="number">1</span>;</span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="built_in">double</span>(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>) / <span class="built_in">double</span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是算法的全部代码，输入参数分别是64位的key，桶的数量（一般对应服务器的数量），输出是一个桶的编号（从0开始）。</p><p>满足算法的要求：</p><p>平衡性，把对象均匀地分布在所有桶中。</p><p>单调性，当桶的数量变化时，只需要把一些对象从旧桶移动到新桶，不需要做其它移动。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>用于分布式存储产品中，而不太适合用在缓存类型的产品。因为有节点不可用时，jumphash用存活节点分担不可用节点的能力不强，会导致分布不均。但是在存储类中，节点都会有主备，主节点不可用路由到备节点，key的分布不会有变化。</p><p>适合在<strong>分布式系统中</strong>，根据key来选择被分配到的服务场景。每次新增新的服务节点，只有1&#x2F;n的key会变动，不会因为扩容或缩容瞬间<br>造成大部分缓存失效。</p><p>但是也有局限，和其他的一致性hash相比。如果有中间的桶失效，是不能够像割环hash一样，均匀分配到其他节点的，只能找个新替换<br>节点来取代。但是优点是不用存储，计算量也不大。代码短，易于实现。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>利用线性同余计算的固定性，每次输入参数固定，输出就固定的特性，来替代用存储。利用运算，减少存储空间。</p><p>由于运算量的优化，比查找存储空间速度更快，所以从时间、空间上算法更优。</p><p>引申：有时用运算生成的数字串，映射要存储的空间，会使算法有意想不到的效果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么上面的代码能够实现一致性hash的功能，我们一步一步来看。要实现的功能就是多加一个节点，节点数变为n，只有1&#x2F;n的key会变动。</p><p>我们先构造一个函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch(key, num_buckets) </span><br><span class="line"></span><br><span class="line">表示有num_buckets个桶，一个key的值会分配到的bucket编号[0, num_buckets)。</span><br></pre></td></tr></table></figure><p>所以对于任意key，k，ch(k,1)&#x3D;0,因为只有一个桶。为了让算法平衡，ch(k,2)讲有一半的key留在0号桶中，一半的移到1号桶中。</p><p>总结的规律是，ch(k,n+1)和ch(k,n)相比，n&#x2F;(n+1)的key是不动的，1&#x2F;(n+1)的key移动到第n号桶。</p><p>对于每次新增桶的个数时，计算每个key的新位置，确定是否要移动到新的桶中。</p><p>通过随机数生成器，来判定key是否要移动到新的桶中，概率是1&#x2F;(n+1)要移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    int b = 0; // This will track ch(key, j +1) .</span><br><span class="line">    for (int j = 1; j &lt; num_buckets; j ++) &#123;</span><br><span class="line">        if (random.next() &lt; 1.0/(j+1) ) b = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代码中的random.next()产生[0,1)的随机数，随机数序列只和key有关，key为随机种子。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码是满足算法的平衡性和单调性的，算法复杂度是O(N)。满足了正确性，接下来优化性能。</p><p>从算法代码可以看出，大多数情况下<code>random.next() &lt; 1.0/(j+1)</code>是不被执行的。</p><p>对于一个key来说，ch(key,j+1)的值，很少会随着j增长而变化的。当ch(key,j+1)!&#x3D;ch(key,j)时，<br>ch(key,j+1)&#x3D;j。</p><p>&#x2F;&#x2F;我们假设ch(key,j)是一个随机变量，通过伪随机数，来确定一个数值b，当j增长到b时，ch(key,b)!&#x3D;ch(key,b-1),<br>并且ch(key,j)&#x3D;ch(key,b-1)。</p><p>假设一个key的值为k，b为一个跳变的桶数量。则ch(k,b)!&#x3D;ch(k,b+1),并且ch(k,b+1)&#x3D;b.</p><p>下面寻找下一个比b大的跳变的桶数量j。则ch(k,j+1)！&#x3D;ch(k,j),ch(k,j)&#x3D;b,ch(k,j+1)&#x3D;j。<br>有</p><p>ch(k,b+1)&#x3D;b</p><p>ch(k,j)&#x3D;b,</p><p>ch(k,j)&#x3D;ch(k,b+1)</p><p>ch(k,j+1)&#x3D;j</p><p>ch(k,b)!&#x3D;ch(k,b+1)</p><p>ch(k,j+1)！&#x3D;ch(k,j)</p><p>所以，我们已知k，b时，要找到j，对于(b,j]区间的变量i，如果不发生跳变，必须满足<br>ch(k,i)&#x3D;ch(k,b+1)。</p><p>所以有概率</p><p>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先举几个例子P(ch(k,10)=ch(k,11))的概率是10/11,</span><br><span class="line"></span><br><span class="line">P(ch(k,11)=ch(k,12))的概率是11/12,</span><br><span class="line"></span><br><span class="line">所以P(ch(k,10)=ch(k,12))的概率是P(ch(k,10)=ch(k,11))*P(ch(k,11)=ch(k,12))=(10/11)*(11/12)=10/12</span><br><span class="line"></span><br><span class="line">对于任意的n&gt;=m,P(ch(k,n)=ch(k,m))=m/n。</span><br></pre></td></tr></table></figure><p>所以对于上面的等式，<br>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))&#x3D;(b+1)&#x2F;i。</p><p>假设一个随机数r在(0,1)区间，由k和j确定。</p><p>如果r&lt;&#x3D;(b+1)&#x2F;i,那么P(j&gt;&#x3D;i)&#x3D;（b+1)&#x2F;i为不跳变。<br>那么产生随机数r后，就能确定i的最小值为(b+1)&#x2F;r。<br>因为r&lt;&#x3D;(b+1)&#x2F;i   &#x3D;&gt;    i&lt;&#x3D;(b+1)&#x2F;r.</p><p>又因为i是整数，所以有<br>r！&#x3D;0</p><p>i&#x3D;floor((b+1)&#x2F;r)</p><p>代码可改写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">random.seed(key);</span><br><span class="line">int b = -1; // bucket number before the previous jump</span><br><span class="line">int j = 0; // bucket number before the current jump</span><br><span class="line">while (j &lt; num_buckets) &#123;</span><br><span class="line">b = j;</span><br><span class="line">r = random.next();</span><br><span class="line">j = floor((b + 1) / r);</span><br><span class="line">&#125;</span><br><span class="line">return = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设r的期望为0.5，时间复杂度为Olg(N)。<br>这个算法有点绕，通过随机数的产生来判定下一跳的j，优化算法，保证在整体key的跳变满足增加桶数为n+1时，只有1&#x2F;(n+1)的数据移动。</p><p>我们再看</p><p>key &#x3D; key * 2862933555777941757ULL + 1;<br>j &#x3D; (b + 1) * (double(1LL &lt;&lt; 31) &#x2F; double((key &gt;&gt; 33) + 1));</p><p>和<br>r &#x3D; random.next();<br>j &#x3D; floor((b + 1) &#x2F; r);</p><p>有什么关系。</p><p>利用线性同余算法产生一个64位的整数，然后通过映射到（0，1]区间的小数。</p><p>(key&gt;&gt;33)+1是取key值的高31位的值再加1，范围为(1,2^31+1)<br>1LL&lt;&lt;31的值为2^31。</p><p>所以<br>[(key&gt;&gt;33)+1]&#x2F;1LL&lt;&lt;31 的取值范围是(0,1],如果(key&gt;&gt;33)&#x3D;2^31那么会大于1，由于是c的整数运算，大于1也会取证忽略掉小数部分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该算法的精髓：通过随机种子产生随机数，减少存储；利用概率和随机数，确定key在bucket_num范围内落在的桶序号。</p><p>既减少了运算量，也易于实现，对于存储类路由非常适合，而且key的分散性不依赖key本身，只依赖随即生成器，对key的要求不高，不用做转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在分布式系统路由分配上，一致性哈希算法有很大的优势。在之前的文章中也讲过原理。算法容易理解，但是实现上要注意很多细节，虚节点加入也要消耗更多的存储来维护映射关系。但是今天介绍的&lt;code&gt;jump consistent hash&lt;/code&gt;是一种比较新颖的方法，代码简短，</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出zookeeper之一：功能及本质</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAzookeeper%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%8F%8A%E6%9C%AC%E8%B4%A8/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAzookeeper%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%8F%8A%E6%9C%AC%E8%B4%A8/</id>
    <published>2018-08-26T15:39:20.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>zookeeper（下文简写为zk）大家都不陌生。但是，看到很多同学对zookeeper的理解过于程式化，有些地方甚至需要背，是大可不必的。把本质理解了，概念性和功能介绍都可以推出来的，而且架构要活学活用，透过现象看本质，才能对技术和技术领悟有大的提升。下面来看下zk的功能及本质。</p><h2 id="zookeeper的定义及用途"><a href="#zookeeper的定义及用途" class="headerlink" title="zookeeper的定义及用途"></a>zookeeper的定义及用途</h2><p>我们先了解官方的定义。</p><blockquote><p>Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination. Apache ZooKeeper 是一个致力于开发和维护开源服务器，该服务器实现高可用的分布式协调框架。 ZooKeeper is a high-performance coordination service for distributed applications. It exposes common services - such as naming, configuration management, synchronization, and group services - in a simple interface so you don’t have to write them from scratch. zookeeper是一个高性能的分布式应用协调服务框架。它以简单接口形式实现了一系列的通用服务,比如** 命名、配置管理、同步、分组 **等，因此你不必从一堆草稿中去实现他们.</p></blockquote><h2 id="zookeeper的本质功能"><a href="#zookeeper的本质功能" class="headerlink" title="zookeeper的本质功能"></a>zookeeper的本质功能</h2><p>通过官方的定义介绍，我们知道了zk是一个server，擅长分布式协调功能。我们来分析下功能的本质实现是怎样的。 zk的数据模型是以znode的形式存储和组织。与标准文件系统类似，是一个树形结构，根节点是’&#x2F;‘。 <img src="http://zookeeper.apache.org/doc/current/images/zknamespace.jpg" alt="zk的znode结构"> 图中每个节点都是一个znode，类似于文件系统中的一个文件，形成了一个树形结构，每个znode内部还可以存储不超过1M的数据。这些znode可以是持久的，还可以是短期的（ephemeral ）。 短期的（ephemeral ）znode当创建他的客户端session超时，会被zk主动删除。有点类似给文件加锁，进程异常退出后，锁立刻解除。 zk的数据模型类似文件系统，这点也没什么特别的。本质还是kv形式，如果kv的value还要求是kv格式，那么就和zk的数据模型一样。表示成树形的格式，更容易表示层级关系。 zk的特别之处在于： 0. <strong>zk内部的选主和写数据机制。</strong>有超过一半的zk集群节点选出来的主节点，成为集群的leader节点，负责主写和同步其他丛属follower节点。底层用的ZAB（ZooKeeper Atomic Broadcast）协议。 1. <strong>短期的（ephemeral ）znode功能。</strong>方便实现锁类操作，在分布式中处理超时状态。 2. <strong>客户端可以设置监控watch某个znode的功能</strong>，当znode发生变化（版本号变更）时，会主动通知watch的客户端有变化了。该功能让客户端不必轮询，能够有序地知道znode变更顺序。 命名、配置管理、同步、分组等功能，都是通过1、2两点结合实现的。我们自研的业务如果想实现，也都能想到，或者用类似方式实现。 zk内部的选主和写数据机制。就不那么容易想了，只能依靠论文实现。所以这点更要好好学习下，这种方法很有特点，并且不容易想出来，也不容易理解。</p><h3 id="与已有自研业务的区别"><a href="#与已有自研业务的区别" class="headerlink" title="与已有自研业务的区别"></a>与已有自研业务的区别</h3><p>自研业务中，实现zk功能的，比较像的是配置中心（下文简称cc）。 一般实现cc，采用一主多从，主节点负责写，从节点只读。主节点通过binlog同步从节点，保证最终一致性。 主节点有两个写数据途径： 1、通过管理台的配置中心更新配置表； 2、通过客户端api上报服务状态，更新客户端节点负载和健康状况。 3、把心跳和变更回包作为一个协议，通知客户端配置更新。 如果从节点死机，不影响集群服务，对应的客户端寻找新的从节点去读。 如果主节点死机，cc只提供读服务，要人工来恢复。 影响：故障期间不能新增或修改配置以及配置项的负载。 如果用zk来实现cc，在正常情况下运行方式和cc是一样的。但是当主死机后，会用算法重新选出主，对客户端透明。<strong>让主节点死机停写的概率降低。但是如果有一半的节点死掉，会造成整个zk集群不可用。</strong> 对比：</p><p>自研cc</p><p>zk</p><p>选主方式</p><p>人工配置，主死了集群只读，人工介入恢复</p><p>集群协商选主，自恢复后继续服务</p><p>集群完全不可用条件</p><p>所有节点都死掉</p><p>一半节点死掉（可能有分区问题造成zk内部同步有问题，但是节点是可以服务的）</p><p>zk的选主方式，并没有完胜一主多从的所有场景。 1. 算法比较复杂，不容易理解和实现。 2. 某些重要任务，出现主写问题，为了一致性，要人工介入恢复，自动选新主切换会造成数据丢失。 3. 对于业务特定的场景特点，做一些弥补方案，能降低单点主写的风险。例如搭建多套cc，并行写，都对外提供服务，因为配置节点健康和负载的少量不一致，对业务来说是可以接受的。还可以在业务中增加缓存，保证主死了能够有足够的时间恢复。 以上自研业务没有引入ZAB或paxos协议的原因。在出现zk之后，想用的业务可以直接在zk之上构建集群内节点选主功能。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>我们在zk上构建服务的时候，要注意zk死一半节点就全集群死掉的特点。要考虑到<strong>如果zk集群不服务，业务有备选方案，能够对外尽力服务</strong>。例如zk充当配置中心，client要设置缓存，或默认配置。 为了节约资源，zk集群必须是奇数台机器。但是zk的机器数变多，对性能会有较大影响。写数据同步和选主都会变得越来越慢。 解决方法： 1. 读多写少：增加观察者节点来扩展读性能。观察者节点不参与主从节点的协商和选举，只负责同步主节点。 2. 读少写多：根据业务特点划分set，做到平行扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>zookeeper通过ZAB协议实现了集群内部选主和写同步功能，提高了服务的健壮性，和写操作的有序性。是实现的难点，背后有严密的数学理论推理。 通过实现，短期的（ephemeral ）znode和主动通知节点变更消息的功能，客户端能够及时知道监听节点变化，在客户端和zk断开连接后，也能够自动释放节点。轻松地实现锁类服务和监听更新类需求。这些是实现名字服务、配置管理、同步、分组等服务的基础。 <em>后面会再写介绍ZAB协议和zk典型应用场景用法的文章</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;zookeeper（下文简写为zk）大家都不陌生。但是，看到很多同学对zookeeper的理解过于程式化，有些地方甚至需要背，是大可不必的。把本质理解了，概念性和功能介绍都可以推出来的，而且架构要活学活用，透过现象看本质，才能对技术和技术领悟有大的提升。下面来看下zk的功能</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>教人怎样读书的书——《如何阅读一本书》</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%95%99%E4%BA%BA%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B9%A6%E2%80%94%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%95%99%E4%BA%BA%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B9%A6%E2%80%94%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/</id>
    <published>2018-08-20T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>读书能够让人增长心智，提高认知，对一个个分散的问题找到解决方法。</p><p>在读书本身这件事上，也是有方法可循。</p><p>《如何阅读一本书》就是教人怎样读书的书。对于经常读书的人，可以学习下其中的方法，走一些捷径。</p><p>这本书的两个作者是<code>莫提默·J. 艾德勒</code>和<code>查尔斯·范多伦</code>他们是《大英百科全书》的编辑，在1940年就写出了这本书。虽然年代久远，但是对于读书来说，里面的方法是很实用的，一点都不过时。</p><h1 id="阅读的四个阶段"><a href="#阅读的四个阶段" class="headerlink" title="阅读的四个阶段"></a>阅读的四个阶段</h1><p>阅读分为四个阶段：基础阅读、检视阅读、分析阅读、主题阅读。由浅入深，每个阶段都包括前一阶段的全部内容，前一阶段是后一阶段的基础。</p><p>四个阶段不是要分成四个步骤，当你阅读技巧熟练时，可以在一次阅读中完成多个阶段。</p><h2 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h2><p>就像小学生识字，或读外国文献一样，把书中的文字和句子内容认识出来，读懂语义，是最初级的阅读。一般经过学校训练的学生，都具备这种能力。当读某种国外文字时，我们有时会退化到基础阅读，要逐字逐句地翻译理解句子的意思。</p><h2 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h2><p>阅读一本书时，要先对书的主题有所研究，不用一开始就详细地读书的每个细节。对书的内容主题有个大概的了解，让我们在一开始就先界定这本书是否有用，哪些地方是我们要重点读的有个界定。</p><ol><li>先看书名页，注意副标题，可以对书的主题有概念。将书分类。</li><li>研究目录页，对书的架构有概括性了解，目录是一本书的纲要，作者花费很多心思在目录的组织上，我们能够通过目录了解一本书的架构。</li><li>书的索引，书衣上的出版社介绍，都是概括书主要内容的重要线索。</li><li>略读书的内容，遇到难懂的内容也不要停下来，这步的主要目标是对书有个整体的把握。要快速的把书读完，哪些需要慢慢读的部分，留到后续的分析阅读中去读。</li></ol><p>看书名页、目录页、索引都是比较容易忽略的，但是里面对全书的架构有概括的描述，是最值得在初读一本书时重点看的。</p><p>检视阅读相当于略读，大体读懂书的内容即可，不懂的可以留到后面读，先对书有整体把握，知道书在讲什么，是什么类型的书，是否是自己需要读的书籍。</p><h2 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h2><p>分析阅读是详细地读一本书，发掘作者的观点，和论述的方法。对一本书的整体和细节都有详细的了解。能够描述出一本书的架构，每部分都是写的怎么，每个部分论述是怎么组织的。就是精读一本书。</p><p>在分析阅读时，最好不借助外力，自己一个人阅读，如果经常这么做，就越发现不用外界助理了。</p><p>当下各种书摘书评都很多，但是那是别人经过处理的，难免会有些丢失，如果总依赖这种，会在短时间内觉得知识丰富了，但是对于图书的一些精髓，和你阅读时能够受到的触发或感受，是得不到的，长远看对心智的成长是不利的。</p><p>在精读时要独立思考，评判性地读一本书，书中的观点是否正确，为什么正确，为什么错误，要有理有据。这样才能吃透一本书。</p><h2 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h2><p>主题阅读不局限于一本书了，而是要对一个问题，找一系列的书来论证该问题。要先找到相关的书，然后对这些书做过滤和筛选，找到这些书中对问题有关系的部分。抽取出对问题有帮助的内容。来解决这个主题的问题。</p><p>有点像大学写论文，要把相关文献都读一遍进行总体归纳。我们平时对一个技术问题进行研究时，也要翻阅大量的书籍，或通过搜索引擎读大量的网页，最终总结出知识点。</p><p>四个阅读阶段，和我们做系统架构也很类似。</p><ul><li><p>基础阅读——刚接触一个业务时，要会业务模块的语言，熟悉用的组件的功能，否则没办法接手一个业务。</p></li><li><p>检视阅读——对业务部署有大体的了解，熟悉架构图，知道每个模块间的调用关系。</p></li><li><p>分析阅读——对每个模块内部，每条协议，每个方法都详细了解，对这个业务抽丝剥茧，全部熟悉。</p></li><li><p>主题阅读——找和模块相关的主题，例如缓存怎么设计，消息系统怎么设计，把业内类似的系统都了解，总结出方法论，<br>对系统设计有整体思考和对比。</p></li></ul><h2 id="读书的态度"><a href="#读书的态度" class="headerlink" title="读书的态度"></a>读书的态度</h2><p><strong>读书要主动阅读，带着问题和目标去读，如果不喜欢，被动阅读，不如不读。</strong></p><p>主动阅读要能提出四个主要问题：</p><ol><li>这本书在谈什么？</li><li>作者细说了什么，怎么说的？</li><li>这本书说的有道理吗？是全部有道理，还是部分有道理？</li><li>这本书和你有什么关系？</li></ol><p>很多人读书是被动的，被人逼着读，或者听说某本书好就去读，不是自己真的感兴趣。这样的读是低效的，是浪费时间。要思考上面的四个问题，特别是最后一个问题，在每次要翻开一本书时，都想想，这本书到底和你有关系吗？</p><p>总阅读在能力范围之内的书，是没法提升阅读能力的。必须能操纵超越能力的书，阅读超越头脑的书，能够帮助思想成长。除非能增长心智，否则学不到东西。</p><p>好读者也是阅读要求高的，阅读时也是很主动的。</p><p>书中的方法论只是理论，要通过读其他的书，来练习读书的方法，才能提高心智，成为一个好的读者。</p><p><strong>读书要分主次，消遣或资讯类的不用详细读</strong>，甚至可以不读，这类书知识提高了读的量，但是并没有太多实质的东西，<br>只是让你知道了某些事情。特别现在的新闻app，都是些无用的新闻，但是却很“有趣”，把时间花在这些内容上，得不偿失。</p><p>即使是书籍，有用的，称得上精华的，也不足万分之一，要有独立思考和筛选的能力，读好书，多读书。</p><h2 id="为什么读书？"><a href="#为什么读书？" class="headerlink" title="为什么读书？"></a>为什么读书？</h2><p>读更多的书，才能更了解世界，更了解人类，提高我们的心智和认知，减少我们的困惑，真正的提升自己，而获取更好的生活。</p><p>一本好书能够叫你了解这个世界以及你自己。你不只是更懂得如何读的更好，还懂得生命。你变得更有智慧，<br>而不只是更有知识。你会成为一位智者，对人类生命中的永恒真理有更深刻的体认。</p><p>从读书、读好书、会读书开始，做个心智健全，对人类、世界更了解的人！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读书能够让人增长心智，提高认知，对一个个分散的问题找到解决方法。&lt;/p&gt;
&lt;p&gt;在读书本身这件事上，也是有方法可循。&lt;/p&gt;
&lt;p&gt;《如何阅读一本书》就是教人怎样读书的书。对于经常读书的人，可以学习下其中的方法，走一些捷径。&lt;/p&gt;
&lt;p&gt;这本书的两个作者是&lt;code&gt;莫提</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>了解一致性hash算法</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2018-08-07T14:01:23.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一致性hash算法，在维基百科的定义是：</p><blockquote><p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p></blockquote><p>翻译过来的意思就是当hash表更新节点的数量时，只有k&#x2F;n的关键字位置有变化，其他关键字的位置映射关系不变。与其他的hash算法比，其他的算法节点个数n变化后，更多的key关键字和节点的映射会发生变化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一致性hash主要用在路由中，对有状态的服务，根据key进行转发到对应的服务中。保证相同的key一直落到同一个服务器，当有服务节点增减时，只有少量(k&#x2F;n)的请求位置是变化的。减少重新建立缓存或存储的成本。</p><h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>前提：</p><ul><li>每个请求的key范围[0,2^32)，一共有k个key;</li><li>一共有N个节点，结点和服务器对应。</li></ul><h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><p>取key所映射的所有值最大空间（2^32）个，组成一个环，然后随机在这个环上落N个点，相邻的两个点形成一个左闭右开（关于左闭右开参考《聊聊左闭右开区间》)区间。共有N个区间。 对于每个key，一定只落在N个区间中的一个，它属于该区间所分配的节点。 当有服务节点增减时，会有区间新增或消失，平均只有k&#x2F;N个key会受影响，变更属于的节点。 如下图，在插入nodeC之前，2、3、8key都属于nodeA，当插入nodeC后2、3归属C，属于B的节点不会改变。 <img src="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7329-20240718185222474.png" class="" title="image common hash"></p><h4 id="改进：增加虚节点"><a href="#改进：增加虚节点" class="headerlink" title="改进：增加虚节点"></a>改进：增加虚节点</h4><p>常规实现在实际应用中会遇到问题。当N的数量太少时，会导致N个节点所管辖的区间并不均匀。 既然是N的数量太少，那增加N的数量不就行了?正解，可以成倍地增加N的数量，一个实际的节点扩充为100倍的虚节点，每个key先查找属于哪个虚节点，再查看该虚节点属于那个实节点。 由于众多虚节点的引入，使每个实节点被分配到的key数量的差距变少。 <img src="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7335-20240718185218204.png" class="" title="image vnode common"> 从图中可见，增加了nodeA和nodeD的虚节点后，把区间分得更细小，会使分布更均匀。还可以通过设置权值，让不同处理能力的实节点，处理不同量级的key。</p><h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>通过上面的讲解，可以熟悉一致性hash的算法，但是在实际使用中，还是有很多需要注意的地方。</p><h4 id="如何加入虚节点"><a href="#如何加入虚节点" class="headerlink" title="如何加入虚节点"></a>如何加入虚节点</h4><p>加入虚节点能够解决分布不均的问题，但是如何加入也是有技巧的。如果完全随机，就是撞大运编程。要利用搜索算法，加入节点时要检测，保证每个实节点的区间不能差异太大。必要时要回溯，剪枝，或者用启发性搜索。</p><h4 id="节点配置同步"><a href="#节点配置同步" class="headerlink" title="节点配置同步"></a>节点配置同步</h4><p>一个大系统，每个真实节点有1000个虚节点，一共1000个实节点，有1M条目数据。每当更新节点信息时，要保证快速更换、传递更新数据，而且要有检查功能。节点配置的同步、检测也会有很多细节问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;一致性hash算法，在维基百科的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Consistent hashing is a speci</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>三门问题</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</id>
    <published>2018-08-03T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个游戏：有3扇关闭着的门，其中2扇门后面各有一只羊，另一扇门后面有一辆车。</span><br><span class="line">参与者：一个游戏者和一个主持人。主持人事先知道各扇门后的物品，而游戏者不知道。</span><br><span class="line">游戏目的：游戏者选择到车。</span><br><span class="line">游戏过程：1、游戏者随机选定一扇门；2、在不打开此扇门的情况下，主持人打开另一扇有羊的门。3、此时面对剩下2扇门，游戏者有一次更改上次选择的机会。</span><br><span class="line">问题：游戏者是否应该改变上次的选择，以使选到车的概率较大？</span><br></pre></td></tr></table></figure><p>问题的学名叫《蒙提霍尔问题》，<a href="http://baike.baidu.com/view/657835.htm#4">阅读原文</a>有来龙去脉。</p><p>答案有换和不换两种，有的认为是换概率是2&#x2F;3,有的认为是不换和换都一样，概率是50%，因为后面剩两个概率是相同的。</p><p>正确答案是应该换，几种解释：</p><ol><li>游戏者坚持每次都换，开始选中羊的概率是2&#x2F;3, 在第一次选中羊的情况下，换了就能够得到车，所以换能得到车的概率是2&#x2F;3。</li><li>假设有1000个门，只有一个后面有车，如果主持人帮游戏者打开选后的998个门，要不要换？当然换，排除了错误答案的情况，换的概率会高很多。</li></ol><p>除了思考的方式，还可以写个程序，用实验的方式验证。（在一些不容易想的问题上，可以用程序模拟多次独立事件，直观查看结果，但不一定和理论完全一样）</p><p>代码和结果如下，如果在主持人提示后换的话，也是2&#x2F;3的概率选中车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define DOOR_COUNT 3</span><br><span class="line">int getrand( int max )</span><br><span class="line">&#123;</span><br><span class="line">    double max_rand = RAND_MAX * 1.0;</span><br><span class="line">    return (rand() /max_rand) * max;</span><br><span class="line">&#125;</span><br><span class="line">int choose( int changed )</span><br><span class="line">&#123;</span><br><span class="line">    char door[ DOOR_COUNT ] = &#123; 0 &#125;;</span><br><span class="line">    int moto_index = getrand( DOOR_COUNT );//车子所在的门序号</span><br><span class="line">    door[ moto_index ] = 1;</span><br><span class="line">    int choose_index = getrand( DOOR_COUNT );//游戏者第一次选的门序号</span><br><span class="line">    int left_index = -1;</span><br><span class="line">    int display_index = -1;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; DOOR_COUNT; i++) &#123;</span><br><span class="line">        if( i == choose_index  )</span><br><span class="line">            continue;</span><br><span class="line">        if( i == moto_index )</span><br><span class="line">            continue;</span><br><span class="line">        display_index = i;//主持人打开的门序号</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    for( i=0; i &lt; DOOR_COUNT; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        if( i == choose_index  )</span><br><span class="line">            continue;</span><br><span class="line">        if( i == display_index )</span><br><span class="line">            continue;</span><br><span class="line">        left_index = i;//最后没打开的门序号</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;moto_index = %d first_choose_index = %d display_index = %d left_index = %d\n&quot;,</span><br><span class="line">            moto_index, choose_index, display_index, left_index);</span><br><span class="line">    if( changed == 1)</span><br><span class="line">        choose_index = left_index;</span><br><span class="line">    if( choose_index == moto_index )</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    srand( ( unsigned  )time( NULL ) );</span><br><span class="line">    int count = 10000;</span><br><span class="line">    int changed = 1;//交换</span><br><span class="line">    int motocount = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        int iRet = choose( changed );</span><br><span class="line">        motocount += iRet;</span><br><span class="line">    &#125;</span><br><span class="line">    printf( &quot;changed = %d count = %d motocount = %d, rate = %0.2f\n&quot;,</span><br><span class="line">            changed, count, motocount, motocount*1.0/count);</span><br><span class="line">    system( &quot;pause&quot; );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">moto_index = 0 first_choose_index = 1 display_index = 2 left_index = 0</span><br><span class="line">moto_index = 2 first_choose_index = 2 display_index = 0 left_index = 1</span><br><span class="line">moto_index = 1 first_choose_index = 2 display_index = 0 left_index = 1</span><br><span class="line">......</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 1 first_choose_index = 0 display_index = 2 left_index = 1</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 1 display_index = 2 left_index = 0</span><br><span class="line">moto_index = 1 first_choose_index = 0 display_index = 2 left_index = 1</span><br><span class="line">moto_index = 0 first_choose_index = 2 display_index = 1 left_index = 0</span><br><span class="line">moto_index = 2 first_choose_index = 1 display_index = 0 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 2 display_index = 1 left_index = 0</span><br><span class="line">changed = 1 count = 10000 motocount = 6692, rate = 0.67</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>问题的分析与解决案例</title>
    <link href="https://yunpengzhang.github.io/2018/%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%A1%88%E4%BE%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%A1%88%E4%BE%8B/</id>
    <published>2018-07-24T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-外呼号码加拨0"><a href="#1-外呼号码加拨0" class="headerlink" title="1. 外呼号码加拨0"></a>1. 外呼号码加拨0</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>客户经理要给用户打电话，在系统界面上，只能看到用户的牛牛号。系统通过牛牛号查询电话号码，再用电话号码给用户拨打电话。</p><p>电信系统要求，对于深圳本地手机号，直接拨打，对于外地手机号，要加拨0，然后拨打。</p><p>程序用的是一个离线库，判断手机号是否为深圳本地号，如果不是，加拨0拨打。</p><p>由于离线库更新不及时，部分深圳新号码，被判断为外地号，导致客户经理给用户打不出电话，要找开发处理，开发把新号段增加到数据库后，客户经理再给用户拨打。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何解决客户经理遇到新号码要加拨0的问题？</p><h3 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>方法一、 购买号码归属地判断服务，在24小时内更新，准确率99%以上，但是需要程序修改，需要花钱购买。也不确定服务是否真的如广告上说的那么好用。</p><p>方法二、 建立处理流程，出现需要加拨0时，客户经理给具体开发申请，提供牛牛号，开发保证在1小时内完成查询号码，把新号段加入数据库操作。</p><p>方法三、 当出现没有加拨0弹窗时，在窗口增加一个按钮“加拨0拨打”，用户主动要求要加拨0，程序后台变为不查归属地，直接加拨0拨打，如果发现拨打成功，那么自动记录号段日志，把号段加入外地号段数据库，并统计上报。</p><blockquote><p>以上为真事，方法一、二、三都是有人想过的，最终采用了方法三。解决了本质问题“让客户经理能够快速地拨通用户的电话”。这里要解决的问题是拨通电话，归属地判断只是一种实现的途径，不要花费很大精力解决旁路逻辑，而忽视主要问题。而且解决问题要看性价比，改动架构，增加成本，都是比较中的代价。</p></blockquote><h2 id="2-wifi签到"><a href="#2-wifi签到" class="headerlink" title="2. wifi签到"></a>2. wifi签到</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>公司采用企业微信签到，但是总有人会忘记签到，导致漏签。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>如何能让大家不忘记签到？</p><h3 id="分析与解决-1"><a href="#分析与解决-1" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>大家到了公司，实际就满足了签到的条件。什么方式能监控到大家到公司了呢？</p><p>刷门禁：可以解决，但是会造成门口拥堵。</p><p>wifi连接：每个人的手机不会经常更换，根据收集mac地址，能够确定一个人，当他到公司时，手机会自动连接wifi，离开公司也会有断开wifi的日志。可以不用专门签到了。</p><h2 id="3-客服工作台的质量问题"><a href="#3-客服工作台的质量问题" class="headerlink" title="3. 客服工作台的质量问题"></a>3. 客服工作台的质量问题</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>收到反馈，客服工作台服务不稳定，希望能提高稳定性。</p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>怎样提高客服工作台的稳定性？</p><h3 id="分析与解决-2"><a href="#分析与解决-2" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>1、找到真正的问题</p><p>为什么大家会觉得不稳定，要查看原因。</p><p>咨询反馈人：觉得客服群里的截图太多了，总有客服截图反馈问题。查看最近三个月的聊天记录，发现反馈的都是一些提示性的弹窗，客服看不懂，因为都是开发自己能看懂的错误码和英文提示。例如：没有权限，网络抖动也弹窗出来。</p><p>查看数据：从程序架构角度，查看视图和事故单，发现质量是稳定的，架构并没有问题。</p><p>真正的问题是：对客服的引导不够友好，如何提高引导性。</p><p>解决：<br>对问题分类：<br>1、有些弹窗可以不弹。<br>客服感知不到的，不影响操作的，不必弹窗，只要记录日志和告警就可以了。</p><p>例如：网络偶尔不通，只要客服没有操作，后面会自动恢复，在客服看来是没影响 的。给他们弹窗，最后也解释已经好了，没有用途的。可以参考其他软件，网络断开时，只要你不操作，后面再连上，都和什么事都没发生一样。</p><p>2、弹窗分类，错误和提示分开<br>区分错误码，哪些是提示性的，提示客服，用提示性弹窗。<br>哪些是错误类的，表明系统有错误，要及时同步开发。分类处理，提示明确，节约客服时间。</p><p>3、bug类<br>bug是难免的，建立快速的反馈和监控机制。重要属性设置告警，客服群反馈及时处理。每月总结客服群的反馈记录，总结解决方法，让问题收敛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-外呼号码加拨0&quot;&gt;&lt;a href=&quot;#1-外呼号码加拨0&quot; class=&quot;headerlink&quot; title=&quot;1. 外呼号码加拨0&quot;&gt;&lt;/a&gt;1. 外呼号码加拨0&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>运营事故的处理及预防</title>
    <link href="https://yunpengzhang.github.io/2018/%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E9%A2%84%E9%98%B2/"/>
    <id>https://yunpengzhang.github.io/2018/%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E9%A2%84%E9%98%B2/</id>
    <published>2018-07-08T14:39:29.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一流的人生，就是看着别人犯错误，自己不犯错误，吸取经验教训；</span><br><span class="line">二流的人生，是自己犯错误，自己吸取教训；</span><br><span class="line">三流的人生，是自己犯错误，自己还不吸取教训。</span><br></pre></td></tr></table></figure><p>互联网工程师，特别是后台工程师，经常遇到线上出问题，引起事故。事故有大有小，影响不一，有些能自动恢复，有些影响巨大刻骨铭心。今天就来聊聊运营事故的处理及预防。</p><h2 id="如何处理运营事故"><a href="#如何处理运营事故" class="headerlink" title="如何处理运营事故"></a>如何处理运营事故</h2><p>虽然发生运营事故是大家都不想看到的，但是真发生了，还是有处理的方法。</p><h3 id="1、第一时间同步给leader"><a href="#1、第一时间同步给leader" class="headerlink" title="1、第一时间同步给leader"></a>1、第一时间同步给leader</h3><p>为什么要同步给leader呢？自己弄好，谁也不说行吗？肯定不行，纸包不住火。同步给leader只有好处，没有坏处。 同步后，你可以专心处理事故，leader会帮你决策处理方法，通知相关人，评估事情的严重性，寻找经验更丰富的人等。因为leader一般经验丰富，能够快速定位问题，帮你出主意，做决策。如果影响相关团队，还能帮你协调外部资源。如果自己一个人处理，处理不好会事情越来越严重，影响越来越大。处理好了，也违反了流程。<strong>按照流程办，就不会出大问题。处理流程也是在众多流血的事故中总结出来的。</strong></p><h3 id="2、快速恢复"><a href="#2、快速恢复" class="headerlink" title="2、快速恢复"></a>2、快速恢复</h3><p>工程师都有个习惯，遇到问题喜欢弄明白，有学习精神。但是在发生事故时，第一时间想的应该是如何快速恢复，而不是讨论技术和学习。只要能快速恢复和降低事故影响的办法，都是可行的。就像在战士受伤时，衣服也可以撕开当纱布止血用，这时衣服和流血比，还是止血重要。 例如：有的事故是发布新特性导致主流程出了问题，那么即时回滚，比查问题更重要，先回滚恢复，再查为什么。不要让用户的体验一直在流血。</p><h3 id="不能快速恢复怎么办"><a href="#不能快速恢复怎么办" class="headerlink" title="不能快速恢复怎么办"></a>不能快速恢复怎么办</h3><h4 id="评估影响"><a href="#评估影响" class="headerlink" title="评估影响"></a>评估影响</h4><p>看下都哪些用户受影响，影响范围，和严重程度怎么样？如果恢复要多长时间，能恢复在什么程度？有没有替代的方案来处理，即使没有那么完美。</p><h4 id="安民告示"><a href="#安民告示" class="headerlink" title="安民告示"></a>安民告示</h4><p>通知相关人，整理话术，对外通知出了什么问题，多久会恢复。让外部有个准备，知道发生了什么事情，不会有人乱猜，而引起更严重的误会。</p><h4 id="壮士断臂"><a href="#壮士断臂" class="headerlink" title="壮士断臂"></a>壮士断臂</h4><p>有时要作出决策，要考虑柔性，舍弃一些正常的功能来保证主功能。<strong>决策要砍脖子，到底是手旁边的，还是脑袋旁边的脖子？</strong></p><h3 id="事后复盘"><a href="#事后复盘" class="headerlink" title="事后复盘"></a>事后复盘</h3><p>事故发生后，要进行详细的复盘，<strong>分析原因整改，要记录事故详细过程，事故的原因，造成的影响，改进措施和排期</strong>。</p><h2 id="如何预防事故"><a href="#如何预防事故" class="headerlink" title="如何预防事故"></a>如何预防事故</h2><h3 id="事故发生的原因"><a href="#事故发生的原因" class="headerlink" title="事故发生的原因"></a>事故发生的原因</h3><p>事故发生的原因有很多，<strong>本质都是一个“变更”</strong>。</p><h4 id="发布导致变更"><a href="#发布导致变更" class="headerlink" title="发布导致变更"></a>发布导致变更</h4><h4 id="用户行为变更"><a href="#用户行为变更" class="headerlink" title="用户行为变更"></a>用户行为变更</h4><p>来的用户多了，热点事件导致用户对某种操作变多了。引起系统过载等问题。一般还是容量管理没有做好，不能应对大流量。 要对容量有个评估，能应对多少请求，当用户行为变更时，能够及时扩容，或柔性可用。</p><h4 id="依赖变更导致"><a href="#依赖变更导致" class="headerlink" title="依赖变更导致"></a>依赖变更导致</h4><p>是另外一个系统变更所为，到底是自己的防御编程没做好，还是依赖方的程序没写到位？</p><h4 id="bug触发"><a href="#bug触发" class="headerlink" title="bug触发"></a>bug触发</h4><p>代码中写了“定时炸弹”，例如做系统初期分配的空间写的太小了，随着规模扩大，突破的分配。 有些代码没有用，却放到那里，阴差阳错又被调用了。 既然有这么多原因，如何预防呢？</p><h3 id="对变更要保有敬畏之心"><a href="#对变更要保有敬畏之心" class="headerlink" title="对变更要保有敬畏之心"></a>对变更要保有敬畏之心</h3><p>每一次代码变更，发布变更。都要谨慎，认真执行review和发布流程。要有柔性预案。要有防范事故的意识。例如：申请ip都是同一机房的，如果线路断了怎么办，机房停电呢？能不能备份了数据，能不能快速搭建一套新的服务，有没有备机？ 但是事故发生的原因多种多样，有防范意识很好，但是也难应对所有情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吾生也有涯，而知也无涯 。以有涯随无涯，殆已！</span><br></pre></td></tr></table></figure><p>为了不“殆已”，要抓住主要环节，最终的出口——<strong>监控</strong>。不管发生什么问题，都能即使发现，尽早预警。对SLA的指标监控。这是能够做到的。很多事故不是发生了处理不了，而是没发现。<strong>发现问题要比解决问题更难。</strong> 除此之外要能控制上限，例如发奖，总有个预算，万一多发了，也不至于把钱都发出去。给用户发短信，也不会一天发超过10条，如果超了就别发了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事故的减少，本质还是人的意识提高。 按照流程规范开发和运维，就不会出大问题。 不要两次被一块石头绊倒，从事故报告中吸取经验教训，减少事故。像圣斗士一样，不会被同一招打倒两次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>互联网服务线上数据迁移的原则和方法</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2018-06-29T06:12:00.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>互联网业务变更非常快，随着业务规模扩大，线上的业务也会涉及重构和迁移。比较难的就是存储迁移，可能从前的存储不适合新的业务模型了，例如从关系型数据库迁移到nosql，或者数据的存储格式发生了巨大的变化。</p><p>为什么说涉及数据迁移的业务最难呢？因为数据是有状态的，不像逻辑和接入层，方便灰度，即使出问题马上回滚就能恢复（如果涉及写数据也也有问题）。然而数据是有状态的，如果切换后发现新的写存储数据有问题，是很难修复的，也很难发现的。</p><p>任何迁移或更新，涉及到数据的，都有一个原则：要有验证比对和回滚能力。</p><h3 id="验证比对"><a href="#验证比对" class="headerlink" title="验证比对"></a>验证比对</h3><p>数据迁移后，要有办法验证这次迁移是成功的，没问题的。只是从代码上说，看，前后逻辑都一样，肯定没问题是靠不住的。我们要从结果，从用户的角度来验证，查看新老数据是否一致，是否有问题。</p><p>一般的方法是双写。老的数据库还对外服务，把写操作同步一份给新数据库，两个库一起写。把有改动的用户数据同步过来，然后再写一个同步程序，把所有用户的全量数据导过来。检测程序，能够根据每个key进行比对，定期把库里所有的数据进行新老比对，当比对率达到阈值以后。还要做一个数据比对层，用户读写的时候先走比对层，同时给新老两个逻辑层同步包，也接收回包。然后把回包进行二进制比对，保证返回给用户的数据也是一致的。</p><p>当都达到一致之后，就可以切换了，切换后以新层为主，老层为辅，也接收同步数据。</p><h3 id="回滚数据能力"><a href="#回滚数据能力" class="headerlink" title="回滚数据能力"></a>回滚数据能力</h3><p>为什么验证比对里最后老层还要接收新层的同步呢，直接切换不好吗？是因为万一切换后出现bug，发现其他地方有问题，可以马上回滚回老数据。保证线上服务正常，给开发修复bug留下充足的时间，不会有很大的时间压力。如果不能马上回滚，只能在线修bug。后续的每次发布修改，对开发的个人能力和状态依赖大，不可控因素太多。很难保证服务质量。</p><p>再多说一下，由于是重构，有时会发现从前数据里的错数据，或逻辑bug。不建议马上修复，新的要先和老的逻辑数据对齐，稳定后再修复老bug。否则bug改完后就没有一个标杆来验证数据是否一致了。</p><p>有人会说，弄这么多，得多久能完成迁移啊，效率太低。考试题目做的再快，不对也是白搭，之所以做这么多，就是保证万无一失。欲速则不达，如果数据错了再去修补，时间花费的更多，而且有时是补不回来的，只能回档，那时给用户造成的损失就大了。在QQ后台，每次数据迁移都要经过几周的发布比对才能切换，重大的数据层重构，没个一年半载达到六个9的一致性，根本不会切换的。这也是为什么一次次在行动的火车上换发动机能够成功的原因！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>涉及到数据的变更发布，要有比对能力，有从结果出发的方法，能够验证数据迁移后是正常的才可以。只从代码逻辑层面分析是不靠谱的。</p><p>要有plan B，如果真的有问题，要能够回滚，有回旋的余地。</p><p>做到以上所说，才能立于平滑迁移数据服务的不败之地！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互联网业务变更非常快，随着业务规模扩大，线上的业务也会涉及重构和迁移。比较难的就是存储迁移，可能从前的存储不适合新的业务模型了，例如从关系型数据库迁移到nosql，或者数据的存储格式发生了巨大的变化。&lt;/p&gt;
&lt;p&gt;为什么说涉及数据迁移的业务最难呢？因为数据是有状态的，不像</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>关于排期的思考</title>
    <link href="https://yunpengzhang.github.io/2018/%E5%85%B3%E4%BA%8E%E6%8E%92%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://yunpengzhang.github.io/2018/%E5%85%B3%E4%BA%8E%E6%8E%92%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2018-06-27T15:24:33.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<p>之前一次例会，讨论到了排期，究竟怎样看待排期，如何能排得准，总结了一些内容。</p><h2 id="如何看待排期"><a href="#如何看待排期" class="headerlink" title="如何看待排期"></a>如何看待排期</h2><p>每个项目，都要有明确的deadline，越大的项目对deadline要求越明确，越不能延期。一些关乎于公司生死存亡的项目，更是上线时间点都不可变更的。 作为一个专业的程序员，给出的排期就是一份契约，答应的时间要做到，否则会影响信誉。如果中间评估时间不够，真的要延期，要提前说出来。而不要最后时刻，给人final surprise。没有按照约定完成，要反思。 项目经理要的排期既不是写代码的时间，也不是设计+实现代码的时间，而是项目上线的时间。太多的程序员把写完代码的时间，当作上线时间承诺出去，代码没上线就是不可用的，要把部署测试的时间都算进去。</p><h2 id="如何排期排得准"><a href="#如何排期排得准" class="headerlink" title="如何排期排得准"></a>如何排期排得准</h2><h3 id="正确地划分任务"><a href="#正确地划分任务" class="headerlink" title="正确地划分任务"></a>正确地划分任务</h3><p>大需求先分解为迭代和里程碑，再细分成小需求，分得越细，排得越准。 分成好几个迭代，有deadline的项目，要在开始前就把几个迭代的预估和需求做的范围都确定好，再排期。 防止边做边排，到最后几个迭代的时候发现有很多重要的工作没估准，导致回旋的余地很小，难以协调。因为前几个迭代把时间用光了，没有做最关键的事情。</p><h3 id="留有余地"><a href="#留有余地" class="headerlink" title="留有余地"></a>留有余地</h3><p>百密必有一疏，留有必要的缓冲时间（buffer），给突发情况。</p><h3 id="理解需求"><a href="#理解需求" class="headerlink" title="理解需求"></a>理解需求</h3><p>项目初期要讨论好需求，明确需求点，找到实现最小需求需要做的工作（核心需求），根据deadline中的时间资源，来决定能开发到什么程度。不要不可能而为之，最后又没完成。 需求点的明确是需要讨论和花费时间的，需要有类似流程图一样的东西来指导，开发和产品都要想自己部分的流程图，都要想清楚。开发有责任让产品想清楚，再给出准确排期。防止最后做出成品再返工。 在资源有限的情况下，要理出最小闭环需求，对需求进行取舍。 <strong>完成比完美更重要！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一次例会，讨论到了排期，究竟怎样看待排期，如何能排得准，总结了一些内容。&lt;/p&gt;
&lt;h2 id=&quot;如何看待排期&quot;&gt;&lt;a href=&quot;#如何看待排期&quot; class=&quot;headerlink&quot; title=&quot;如何看待排期&quot;&gt;&lt;/a&gt;如何看待排期&lt;/h2&gt;&lt;p&gt;每个项目，都要有</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>改变对思考的想法——读《快思慢想》</title>
    <link href="https://yunpengzhang.github.io/2018/%E6%94%B9%E5%8F%98%E5%AF%B9%E6%80%9D%E8%80%83%E7%9A%84%E6%83%B3%E6%B3%95%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E5%BF%AB%E6%80%9D%E6%85%A2%E6%83%B3%E3%80%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E6%94%B9%E5%8F%98%E5%AF%B9%E6%80%9D%E8%80%83%E7%9A%84%E6%83%B3%E6%B3%95%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E5%BF%AB%E6%80%9D%E6%85%A2%E6%83%B3%E3%80%8B/</id>
    <published>2018-06-18T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人类对于自己的思考了解吗？传统经济学里人都是理性的，人会理性作出决策，让利益最大化，真实的人类是这样吗？</p><p>心理学家，诺贝尔经济学奖得主卡尼曼的《快思慢想》，回答了以上疑问。虽然思考是习以为常的事，但是人类并不了解自己的思考方式。甚至觉得自己是懂的，但实际并清楚大脑作出决策的方式。</p><p>书中通过大量的示例，和严谨的实验推导，像我们展示了人类思考的方式。论证严谨，干货满满，是一本好书，值得反复阅读。</p><p>通过这本书，重新认识了思考，改变了对决策的认知。对于日常遇到的一些现象，也有了合理的解释。</p><p>下面是对本书的小结。</p><h2 id="系统一、系统二"><a href="#系统一、系统二" class="headerlink" title="系统一、系统二"></a>系统一、系统二</h2><p>为了理解思考方式，建立了两个虚拟的概念。系统一和系统二，是人类大脑中的两个进行思考的系统。</p><p>系统一是快思考，自动化运行，非常快，不费力气，不受自主控制，也关闭不掉。判断两个物体哪个更近，话语中是否有敌意，在宽广的马路上开车等场景，都是系统一在起作用。系统一不用专门控制，大脑快速反映并给出结论。</p><p>系统二是慢思考，用注意力去做费力的心智活动，包括复杂的计算。在人群中搜寻某个人，比较两个东西的性价比，在很窄的街道停车，这些场景都要用到系统二。要专心做要做的事情，不能分心。专注时也会忽略一些周围的事情。系统二运行会消耗人的能量。</p><p>系统一自动化运作，持续给系统二建议。系统二认可后转换为信念。当系统一碰到困难时，叫系统二用比较详细和特定的方式来处理问题。</p><p>使用系统二处理是有代价的，消耗的“能量”较大。系统二运行需要自我控制，自我控制太多会使精力损耗而且不愉快。</p><p><em>人的精力是有限的，把精力放到关键的事情上，事半功倍。如果放到鸡毛蒜皮的事情上，收到的效果就大打折扣。</em></p><p><em>人类的这种思考方式，是对人类应对自然环境，快速作出决策来生存是有利的。像《人类简史》里说的，随着人类的发展，我们所处的社会环境，自然环境和智人时代已经不同了，但是人类的身体进化却没有太大的变化。我们的思考方式也是远古时期遗传过来的方式，面对现在的经济，生活的决策，人类对概率、多维等，就没有先天优势，要不断地锻炼修改思考方式，才能在现代社会中表现的更好。</em></p><h2 id="注重因果，忽视统计"><a href="#注重因果，忽视统计" class="headerlink" title="注重因果，忽视统计"></a>注重因果，忽视统计</h2><p>未经过专业训练的人，对于事情的判断，很少会用统计和概率的知识，更多是基于因果关系。</p><h3 id="小数原则"><a href="#小数原则" class="headerlink" title="小数原则"></a>小数原则</h3><p>对一件事进行调查取样时，大样本会比小样本更值得相信。但是非专业人士没这个意识，对小样本得到结果后，系统一还会主动地编出各种原因，让自己信服，支持这个结论。</p><p>例如在小医院，每天生出男孩和女孩的比例，就会偏离1：1较大，因为样本太少，但是人还是会构造原因解释结论。</p><p>做互联网业务更要注意，要科学地取样分析，不能取太少（也不是样本取得越多越好，有合适的取样数量）。不能只看官方反馈的用户建议，也要通过多渠道去问券，防止幸存者偏差。</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>给定一个数字，后面的谈判的结果会和这个数字差不太远，都是围绕着这个数字去谈。在谈判和砍价方面，经常有人运用这种方法。</p><p>书中给出了一个的例子，先给志愿者看一些无关的数字，然后再让他们估算一些事情结果的概率，发现志愿者明显被先前给的数字所影响。看较大数字的志愿者们平均估算值大，看较小数字的志愿者们平均估算值小。</p><h3 id="回归平均值"><a href="#回归平均值" class="headerlink" title="回归平均值"></a>回归平均值</h3><p>由于“运气”的存在，有些时候，人的表现会超乎平常。例如运动员某场比赛超常发挥，如果不是水平提高，后面会回归到自己的平均表现。但是人们却喜欢把这些归于因果，例如运动员后面的回归是太紧张了，最近没休息好等。</p><p>就像世界杯，冰岛队战平了阿根廷，门将扑出梅西的点球，后面比赛冰岛队也会回归平均的。但是媒体报道就会分析，冰岛门将研究了梅西，梅西状态不行了……看上去分析得头头是道。阿根廷是强队，冰岛应该是发挥超长，让我们拭目以待，看谁能走的更远。另外，媒体也不一定不懂“运气”成分，但归功于“运气”的分析，就不会更吸引观众。</p><h2 id="选择与风险"><a href="#选择与风险" class="headerlink" title="选择与风险"></a>选择与风险</h2><p>同样100万奖金，对于有100万，和900万的两个人，产生的效用是不一样的。对于有100万的人是20个效用，对于900万的人是4的效用。在做相同赌局的时候，两者的选择也不同。前者更倾向于风险小，即使少得一些钱，后者更倾向于风险多一点。</p><p>在伯努利实验里，是从期望来算的，哪个期望高选哪个，但实际人的心理是不一样的，拥有不同财产的人对下注的心理也不同。</p><p>现实中，不同财富拥有者选择的投资策略不同，也印证了这个观点。保险业也运用这种方法制定保费。</p><p>人们也会高估自己已经获得的物品价值，如果这个物品不是用来交易。例如：卖房者总是认为自己的房子是独一无二最好的，即便并不真的那么好，但是他心中是最好的。因为是他已获得的物品。</p><h2 id="两个自我"><a href="#两个自我" class="headerlink" title="两个自我"></a>两个自我</h2><p>人有两个自我，经验自我和记忆自我。医生检查我们的身体，按某些部位，问疼不疼，有什么反映，是经验自我。问最近怎么样，我们回答的是记忆自我。</p><p>对于一次一星期的旅行，结束以后，记忆里的时间只有一个半小时左右。大多数当时的体验都忘记了。除了照片能够回忆一些，很多过程中的体验都记不得了。</p><p>经验自我过程中经历的痛苦，在记忆自我中，可能就没那么痛苦了，因为痛苦的感觉不完全是由峰值痛苦决定的，也和结局有关。</p><p>遇到挫折，挺过去，就真的撑过去了。只要结局是好的，人类会忘记中间的痛苦的感觉，记忆自我中不会觉得那么痛苦。相反，对于好的体验也一样，经验自我已经很好了，但是结局不是很好，也会影响对过程幸福感的体验。例如欣赏唱片，过程很美，在最后听到了噪音也会让整段记忆毁掉。</p><p>幸福如何度量，也是个难题。就像在旅行中应多拍些照片，方便回忆。还是更注重过程中经验自我的体验，而尽量不让拍照影响观赏景观，要看个人选择了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>人类对于自己的思考，不是天生就了解。就像知道吃食物能够生长、健康，但并不了解身体吸收的原理。明白了蛋白质、脂肪、碳水化合物，和消化器官的原理后，就能更科学地摄取营养，控制健康。《快思慢想》对于思考的作用，也如同营养学、生物学之于身体。能够让人深入了解思考的本质，科学地做出决策。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;人类对于自己的思考了解吗？传统经济学里人都是理性的，人会理性作出决策，让利益最大化，真实的人类是这样吗？&lt;/p&gt;
&lt;p&gt;心理学家，诺贝尔经济</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS专题</title>
    <link href="https://yunpengzhang.github.io/2018/XSS%E4%B8%93%E9%A2%98/"/>
    <id>https://yunpengzhang.github.io/2018/XSS%E4%B8%93%E9%A2%98/</id>
    <published>2018-05-24T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS专题"><a href="#XSS专题" class="headerlink" title="XSS专题"></a>XSS专题</h1><p>[TOC]</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>XSS（Cross-site scripting，跨站脚本）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</p><h2 id="2-成因"><a href="#2-成因" class="headerlink" title="2 成因"></a>2 成因</h2><h3 id="2-1-Html-JavaScript-是用户端可触达的解析性语言"><a href="#2-1-Html-JavaScript-是用户端可触达的解析性语言" class="headerlink" title="2.1 Html&#x2F;JavaScript 是用户端可触达的解析性语言"></a>2.1 Html&#x2F;JavaScript 是用户端可触达的解析性语言</h3><p>Html&#x2F;JavaScript 和 SQL 一样，都是用户端可触达的解析性语言。所以，用户可以改变最终的代码。（不同于 PHP 等，用户无法改变 PHP 的代码，只能改变数据）</p><p>用户可触达，所以用户就能改变代码来进行攻击。</p><h3 id="2-2-浏览器如何解析-html-javaScript"><a href="#2-2-浏览器如何解析-html-javaScript" class="headerlink" title="2.2 浏览器如何解析 html&#x2F;javaScript"></a>2.2 浏览器如何解析 html&#x2F;javaScript</h3><ul><li><a href="http://coolshell.cn/articles/9666.html">http://coolshell.cn/articles/9666.html</a></li><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">http://taligarsiel.com/Projects/howbrowserswork1.htm</a><blockquote><p>自己的理解：浏览器接收到了后端返回的html原文件后，会生成一个DOM树，解析javaScript动作列表之类的，然后，javaScript 就在做自己的动作了。同时，浏览器会动态实时监控DOM树的变化，看是否有新的 javaScript 生成或旧的灭亡，有的话，就把其加入到动作列表或从列表中删除。</p></blockquote></li></ul><p><strong>直接插入标签是不会执行的。要创建script元素才可以。</strong><br><a href="https://github.com/damoclesX/damoclesX.github.io/issues/17">https://github.com/damoclesX/damoclesX.github.io/issues/17</a></p><blockquote><p>结论：用户可控制的输入在前端形成了完整的 javaScript 语句，即可完成攻击。</p></blockquote><h2 id="3-分类"><a href="#3-分类" class="headerlink" title="3 分类"></a>3 分类</h2><h3 id="3-1-反射型（非持久性XSS）"><a href="#3-1-反射型（非持久性XSS）" class="headerlink" title="3.1 反射型（非持久性XSS）"></a>3.1 反射型（非持久性XSS）</h3><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">简单流程：</span><br><span class="line">    用户访问带有XSS代码的URL请求</span><br><span class="line">    服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器</span><br><span class="line">    浏览器解析带有XSS代码的数据后，最终造成XSS漏洞</span><br><span class="line">可能攻击流程：</span><br><span class="line">    • 用户aaa在网站www.xxx.com浏览网页</span><br><span class="line">    • 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码，代码功能为盗取用户Cookie并发送到指定站点www.xxser.com</span><br><span class="line">    • hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击</span><br><span class="line">    • 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com</span><br><span class="line">    • hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息</span><br></pre></td></tr></table></figure><h3 id="3-2-存储型（持久性XSS）"><a href="#3-2-存储型（持久性XSS）" class="headerlink" title="3.2 存储型（持久性XSS）"></a>3.2 存储型（持久性XSS）</h3><p>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试技巧：</span><br><span class="line">    • 首先确定输入点和输出点，比如留言，</span><br><span class="line">    如：&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot; /&gt;</span><br><span class="line">    • 确定输出点后根据相应的标签构造HTML代码来闭合，如：&quot; /&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;，最终在html中为：</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;&quot; /&gt;</span><br><span class="line">测试步骤：</span><br><span class="line">    • 添加正常留言，用firebug快速查找显示标签，若显示区域不在html属性内则可以直接使用XSS代码注入</span><br><span class="line">    • 若不能得知内容输出的位置，可以使用模糊测试方案，XSS代码如下：</span><br><span class="line">        a. &lt;script&gt;alert(document.cookie)&lt;/script&gt;  //普通注入</span><br><span class="line">        b. &quot; /&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;   //闭合标签注入</span><br><span class="line">        c. &lt;/textarea&gt;&#x27;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;   //闭合标签注入</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-DOM-型"><a href="#3-3-DOM-型" class="headerlink" title="3.3 DOM 型"></a>3.3 DOM 型</h3><p>DOM型就完全与后端无关，是前端的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Welcome!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hi&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var pos=document.URL.indexOf(&quot;name=&quot;)+5;</span><br><span class="line">      document.write(document.URL.substring(pos,document.URL.length));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://www.test.com/welcome.html?name=lihua</span><br><span class="line"></span><br><span class="line">http://www.test.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-防护策略"><a href="#4-防护策略" class="headerlink" title="4 防护策略"></a>4 防护策略</h2><h3 id="4-1-危害"><a href="#4-1-危害" class="headerlink" title="4.1 危害"></a>4.1 危害</h3><blockquote><p>JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。</p></blockquote><ul><li>盗取管理员Cookie</li><li>XSS Worm</li><li>挂马(水坑攻击)</li><li>键盘记录(有局限性)</li><li>利用网站重定向</li><li>修改网页内容</li><li>等等</li></ul><h2 id="5-攻击策略"><a href="#5-攻击策略" class="headerlink" title="5 攻击策略"></a>5 攻击策略</h2><h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6 参考链接"></a>6 参考链接</h2><ul><li><a href="https://xss-game.appspot.com/">https://xss-game.appspot.com/</a></li><li><a href="https://www.google.com/about/appsecurity/learning/xss/">https://www.google.com/about/appsecurity/learning/xss/</a></li><li><a href="http://www.jianshu.com/p/9b285eac9d60">http://www.jianshu.com/p/9b285eac9d60</a></li><li><a href="http://www.freebuf.com/articles/web/40520.html">http://www.freebuf.com/articles/web/40520.html</a></li><li><a href="http://www.firmianay.com/2016/03/27/xss-e5-88-9d-e5-ad-a6-e6-80-bb-e7-bb-93/">http://www.firmianay.com/2016/03/27/xss-e5-88-9d-e5-ad-a6-e6-80-bb-e7-bb-93/</a></li><li><a href="http://www.freebuf.com/articles/web/42727.html">http://www.freebuf.com/articles/web/42727.html</a></li></ul><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>Cookie可以使用httponly的方式来解决</p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><blockquote><p><a href="https://xss-game.appspot.com/">https://xss-game.appspot.com</a></p></blockquote><ol><li><script>alert(1)</script><p>反射型xss<br>后端收到来自用户的输入直接原样返回给前端</p></li><li><img src="/2018/XSS专题/undefined"  onerror="alert('1')">单页面html已经加载完毕后，你再手动往html里面加入代码是没有意义的，因为此时的js已经编译完毕了，不再读取html中的js代码，要通过js的一个语句才能重新读取某段js，加入到js编译后的代码中。（这种情况类似于：页面通过json拿回来数据，再组装到dom中。）</li></ol><p>此时，我们可以通过标签的行为来运行时执行新的js语句。</p><p>参考说明：<a href="https://github.com/damoclesX/damoclesX.github.io/issues/17">https://github.com/damoclesX/damoclesX.github.io/issues/17</a></p><ol start="3"><li>.jpg’ onerror&#x3D;’alert(1)’ &#x2F;&gt;&lt;img src&#x3D;’&#x2F;static&#x2F;level3&#x2F;cloud<br>正如前面说的，运行时直接插入是不行的。要再运行时执行，必须借助于标签的属性。</li></ol><p>另外这里告诉我们可以通过组装的方式。</p><ol start="4"><li>这个不行   1’);alert(‘1        要用这个  1%27)%3balert(%271<blockquote><p>When browsers parse tag attributes, they HTML-decode their values first. <foo bar='z'> is the same as &lt;foo bar&#x3D;’&#x7a;’ 标签中的内容，浏览器会自动作html转码</p></blockquote></li></ol><p>如果你能改变属性中的值，那即使输入被作了html转义也没有用。</p><ol start="5"><li><pre><code>javascript:alert(1)%3b   javascript:alert(1) 都可以</code></pre></li></ol><p>a标签的href可以这样用</p><h3 id="这里要理清html转义（编码解码）-和-url编码解码"><a href="#这里要理清html转义（编码解码）-和-url编码解码" class="headerlink" title="这里要理清html转义（编码解码） 和 url编码解码"></a>这里要理清html转义（编码解码） 和 url编码解码</h3><p>总结，如果我们不能有效地改变源码（插入不被转意的<script>到源码中），那么就只能考虑要通过标签。如何能改变源码，就两种方式都考虑。（构造script和构造标签）</p><h2 id="攻击用例"><a href="#攻击用例" class="headerlink" title="攻击用例"></a>攻击用例</h2><blockquote><p><a href="https://www.lvtao.net/dev/xss.html">https://www.lvtao.net/dev/xss.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;a.jpg&quot; onerror=&#x27;alert(1)&#x27; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xss绕过与白名单机制"><a href="#xss绕过与白名单机制" class="headerlink" title="xss绕过与白名单机制"></a>xss绕过与白名单机制</h2><p>富文本，通常用白名单。但是，既然是写的程序，很有可能就会被绕过白名单。<br><a href="http://blog.idhyt.com/2014/10/15/technic-xss-bypass/">http://blog.idhyt.com/2014/10/15/technic-xss-bypass/</a></p><p><a href="https://www.lvtao.net/dev/xss.html">https://www.lvtao.net/dev/xss.html</a></p><p>这个白名单绕过的机制，可以在前端可以自己过滤一遍收到的数据，后端必须要先过滤一下</p><h2 id="防御与监控"><a href="#防御与监控" class="headerlink" title="防御与监控"></a>防御与监控</h2><p><a href="http://www.freebuf.com/articles/web/110583.html">http://www.freebuf.com/articles/web/110583.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS专题&quot;&gt;&lt;a href=&quot;#XSS专题&quot; class=&quot;headerlink&quot; title=&quot;XSS专题&quot;&gt;&lt;/a&gt;XSS专题&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>两个解决并发问题的案例</title>
    <link href="https://yunpengzhang.github.io/2018/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>https://yunpengzhang.github.io/2018/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A1%88%E4%BE%8B/</id>
    <published>2018-05-21T14:15:19.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近和zhiyong聊天，有两个关于并发的场景比较有意思，记录下思考的过程。</p><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>A和B在微信里发消息，如果A发的消息顺序是A1，A2，A3，B发的消息顺序是B1，B2，B3。</p><p>两个问题：</p><ol><li>如果A2由于网络原因，比A3后到服务器，B收到的消息是什么样的？</li><li>如果都不丢消息，A1和B1同时发出，几乎同时到服务器，再分别传给A和B，那么在聊天窗口的表现是什么？</li></ol><p>经过zhiyong的黑盒逆向测试，问题1的答案是B看到A1和A3，在A看到A2发送失败，有个红色叹号，如果点击重发，相当于发出了一个相同内容的A4。</p><p>问题2的答案是可能A看到的是A1，B1，B看到的是B1，A1，即在不同人之间的消息，没有严格的顺序，以客户端本地上屏的顺序为主。（在A来说，A1发完就上屏，B1是后来接收到的，就A1在上面，同理B也是）。如果这时打开一个新终端来同步，那么以服务器那份数据为主，按照时间线的顺序拉取。</p><p>分析</p><p>问题1中，在微信客户端上传消息时，应该给每条消息都加了序列号，按照发送的顺序升序，如果服务器发现序列号回跳缩小了，就丢弃掉，并返回客户端失败。这样做的好处是处理简单，不会造成用户收到一条消息，突然又蹦出一跳消息插在了前面，导致漏看消息，都是追加写。<br>当然也有另外的实现方式，就是没序号，你发什么服务器收什么，哪条先到就哪条在先，但是会有个新问题，用户本想发的是A1，A2，因为人的语言是有顺序的，但是看到的是A2，A1，有些语境乱掉的会引起歧义。</p><p>在丢消息和乱消息两者，选择了可以丢。</p><p>问题2也是，可以做到以服务器为准，纠正客户端的表现，做到强一致，但是微信认为这不是个问题，两个人同时发的哪个先哪个后不影响理解内容，以每个手机上屏时间为准。但是在同步新消息时，以服务器为准，因为此时根本没有冲突。</p><p>如果单纯从技术角度解决这两个问题，也有很直接的方法。对于问题一，发现漏了序号，服务器再下发一小消息，让客户端重传，然后等待重传成功再发给接收方，但这种方法复杂，出问题也不易调试，在产品需求上得不偿失。对于问题二，建立个全局id，每条消息都分个先后，对于全局id的一致和出错恢复的影响，要投入巨大精力来实现，能解决的还是个很少发生的场景问题，甚至真发生了，也不算个问题。</p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>用户从其他渠道拿到兑换码，然后在小米官网输入兑换码，兑换奖品，每个码只能用一次，每个用户一天只能兑换2次奖品。此时会有问题。兑换码标记失效，和给用户发奖，是两个动作，会有并发问题。两个动作的先后顺序，哪个先哪个后。是否要用事务。</p><p>也是两个问题：</p><ol><li>两个用户A和B用同一个兑换码同时兑换，怎么处理？</li><li>一个用户同时用两个兑换码兑换，发现当天只能有一次兑换机会时，两个码都失效吗，会多扣一个码吗？</li></ol><p>分析</p><p>方法一最简单方法，用事务，每次兑换前开启事务，兑换后结束事务。优点：代码简单。缺点：事务太重，在互联网高并发的场景中，性能不高。</p><p>方法二先扣兑奖次数，再失效兑换码。这种情况在两个用户用同一个码并发时，会判断都有兑换次数，都扣，但失效兑换码时，只有一个人成功，失败的那个人被多扣了一次抽奖机会。</p><p>方法三先失效兑换码，再扣抽奖次数。两个用户用同一个码时，后用的提示码已用过，没问题。一个用户用两个码并发时，先把两个码都失效，再根据兑奖次数，只有一个兑换码成功兑换了奖品，多扣了一个兑换码。</p><p>最后选择的方法三，因为两个用户用同一个码是存在的，但是一个用户同时用两个码的概率比较小，用户要输入码再点确定才行。还有如果给用户多扣了一个兑换码的情况，只有用户当天没有兑换次数的时候才出现，不会对用户造成更大的损失。后台根据告警，用修复脚本把多扣的券找出来恢复，用户第二天还能用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>并没有什么银弹，设计的那种方案的好坏，要结合具体需求，详细分析，深入思考需求的特点，在实现复杂度和满足需求找到平衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近和zhiyong聊天，有两个关于并发的场景比较有意思，记录下思考的过程。&lt;/p&gt;
&lt;h3 id=&quot;场景一&quot;&gt;&lt;a href=&quot;#场景一&quot; class=&quot;headerlink&quot; title=&quot;场景一&quot;&gt;&lt;/a&gt;场景一&lt;/h3&gt;&lt;p&gt;A和B在微信里发消息，如果A发的消息顺序</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>理解依赖注入和控制反转</title>
    <link href="https://yunpengzhang.github.io/2018/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    <id>https://yunpengzhang.github.io/2018/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</id>
    <published>2018-05-17T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解依赖注入和控制反转"><a href="#理解依赖注入和控制反转" class="headerlink" title="理解依赖注入和控制反转"></a>理解依赖注入和控制反转</h2><p>在了解lumen框架的时候有遇到这两个概念，当时看了觉得模模糊糊地明白了，但是上周在上课时发现还是没<br>理解透，又重新梳理了解了下，总算有点明白了。</p><h3 id="基本定义和关系"><a href="#基本定义和关系" class="headerlink" title="基本定义和关系"></a>基本定义和关系</h3><p>首先明白几个定义，然后理清他们之间的关系。</p><p><strong>依赖反转原则（Dependency inversion principle，DIP）</strong><br>是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p><p><strong>控制反转（Inversion of Control，缩写为IoC）</strong><br>是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><p><strong>依赖注入</strong>：依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p><p><strong>依赖查找</strong>：依赖查找更加主动，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态</p><p><strong>容器</strong>：容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入（DI）”。</p><p><strong>反射</strong>：反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。</p><p>依赖反转、控制反转都是<strong>设计思想</strong>，是一种设计意识，指引方向。</p><p>依赖注入、依赖查找是<strong>设计模式</strong>，用来实现上面两个思想的实现方法。</p><p>容器可以理解为一种<strong>数据结构</strong>，是具体的编程方法。方便管理不同的类在一起管理。</p><p>反射是语言层面的特性，在代码运行的过程中，根据运行的中间状态来动态生成对象，让程序更灵活，简练。</p><blockquote><p>依赖反转、控制反转是设计思想，依赖注入、依赖查找是实现思想的设计模式，使用容器和反射功能，能够更好地实现两种设计模式。</p></blockquote><h3 id="用途和实例"><a href="#用途和实例" class="headerlink" title="用途和实例"></a>用途和实例</h3><p>上面理顺了几个定义和他们之间的关系，再看下知道这些关系能有什么用途呢？</p><p>明白了上面的关系，就知道控制反转是思想，其他下层的概念是实现这种思想的途径。这里说的用途就是这种思想的用途。</p><p>控制反转、依赖反转的用途，就是<strong>解耦</strong>，方便扩展，带来的好处就是代码易扩展、测试、功能更稳定等。</p><p>例如做日志组件，日志可以记录到磁盘、数据库、udp发包到远程。</p><p>按照最直观的想法，在日志类里建立一个磁盘、数据库、udp三个媒介类，根据传入参数的不同选用不同的类进行调用。</p><p>这样做使日志类依赖底层存储媒介的实现，如果底层增加了tcp媒介，那么要修改日志组件内的代码，造成了耦合，只要有修改，就有引入bug的风险，容易把已有的功能影响。</p><p>运用控制反转思想，把磁盘、数据库、udp三个媒介类在抽象出一层writer接口，每个类都按照接口的要求实现，在日志类里都和抽象的接口打交道，实现日志类时传入要实现的类的类型就可以了。</p><p>到这步就已经有了控制反转的思想了。</p><p>但怎么能更好地实现这种思想呢？</p><p>一种是日志的构造函数里new出每个媒体类，第二种是传递媒体类的引用，在外部new好后传进来。依赖注入说的就是第二种。以参数的形式传进来。</p><p>优点是新增类型不用修改构造函数；缺点是要做一些判空处理。</p><p>还有一种方法是依赖查找，就是在需要具体媒体类的时候，根据关键字找出一个类，实现的方法可以是在内部建立一个类的关键字和类实例的数据结构，通过关键字找到一个类的实例来执行。</p><p>容器可以是一个存储类的数据结构，可以用类的名字的字符串，来找到一个执行功能的类，来创建和执行。</p><p>反射是实现的一种方法，能够在程序运行过程中，根据程序运行中间的数据，灵活地产生出要执行的类，来实现依赖查找。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面的描述更多地是把几个概念分类，描述功能，要想应用自如，还要参考具体项目实现的代码，动手实践。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC</a></p><p><a href="https://segmentfault.com/a/1190000002424023">https://segmentfault.com/a/1190000002424023</a></p><p><a href="https://www.insp.top/learn-laravel-container">https://www.insp.top/learn-laravel-container</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;理解依赖注入和控制反转&quot;&gt;&lt;a href=&quot;#理解依赖注入和控制反转&quot; class=&quot;headerlink&quot; title=&quot;理解依赖注入和控制反转&quot;&gt;&lt;/a&gt;理解依赖注入和控制反转&lt;/h2&gt;&lt;p&gt;在了解lumen框架的时候有遇到这两个概念，当时看了觉得模模糊糊地明</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>php小细节之switch中的continue</title>
    <link href="https://yunpengzhang.github.io/2018/php%E5%B0%8F%E7%BB%86%E8%8A%82%E4%B9%8Bswitch%E4%B8%AD%E7%9A%84continue/"/>
    <id>https://yunpengzhang.github.io/2018/php%E5%B0%8F%E7%BB%86%E8%8A%82%E4%B9%8Bswitch%E4%B8%AD%E7%9A%84continue/</id>
    <published>2018-05-04T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>对于语言中的continue，大家都不陌生，是停止当前行的操作，继续下次循环。例如下面的C语言代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in case\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in case\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in default\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d over for \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果</p><pre><code> 1 in case1 over for  2 in case 3 in default3 over for </code></pre><p>在case 2里遇到continue后直接跳出switch进行下一个循环，和我们平时的理解是一样的。但是在php里的时间就比较诡异了， <strong>swicth里的continue和break是相同的</strong> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt; <span class="number">4</span>; ++<span class="variable">$i</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">switch</span> (<span class="variable">$i</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in case\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in case\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in default\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> over for \n&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><pre><code>1 in case1 over for 2 in case2 over for 3 in default3 over for</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在php里switch中continue和break的实现是一样的，不要用其他语言的思维来思考，要多注意，否则会触发bug。</p><p>估计是设计php的时候没有参照其他语言的标准来实现，在新版本也没有修改，可能会导致老代码运行异常。</p><p>这个细节增加了大家学习php语言的负担，虽然不大，要专门记住。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://stackoverflow.com/questions/12349826/should-i-ever-use-continue-inside-a-switch-statement">Should I ever use continue inside a switch statement?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于语言中的continue，大家都不陌生，是停止当前行的操作，继续下次循环。例如下面的C语言代码&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何计算在线时长</title>
    <link href="https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/"/>
    <id>https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/</id>
    <published>2017-12-06T12:36:11.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>员工会登录一个内部服务系统，登录后可以选择休息或工作状态，下班时选择离开。有一个页面要实时展示员工当天休息和工作的累计时长。</p><p>有两个数据库表存储员工的数据。</p><p>员工状态表：存储员工的当前状态。</p><p>员工状态流水表：每次员工状态切换，存储一条日志，记录切换发生的时间，切换前状态，切换后状态。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>先建立问题的模型，一个状态图，是员工状态切换的本质。</p><p>如下，员工有三种状态，在状态切换时才会有时长被计算进去。其中红色的表示计算为休息时长，蓝色表示工作时长。即从休息状态转出的记录为休息时长，工作状态转出的记录为工作时长。</p><img src="/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/11090-20240718161055125.png" class="" title="员工状态图"><p>建立一个新表，存储用户最近一次状态，和状态的获取时间点。还有用户当前的累计休息时长，累计工作时长。</p><p>用户请求到来时，通过员工状态表获取员工当前的状态，再根据新表最近的状态和时间点，计算出累计的市场，增加到累计“休息”或累计“工作”时长中。</p><p>如果中间有跨越每天切换的时间点，例如零点。那么先更新新表中最近一次状态为切换时间点的状态，清零累计时长，然后按状态机的方法计算累计时长。</p><p>计算在线时长如果每次都从日志里遍历，重复计算，是大错特错的。</p><p>这个问题要注意两点，已经计算过的，要存储累计数值，不要重复计算，否则后续数据增长会不可控，也消耗性能；清零时间点要做好判断，把清零时刻的状态推算出来然后再套用模型计算即可。</p><p>同理，计算游戏在线时长，IM隐身时长等都是一个原理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;员工会登录一个内部服务系统，登录后可以选择休息或工作状态，下班时选择离开。有一个页面要实时展示员工当天休息和工作的累计时长。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>说说我们的负载均衡武器</title>
    <link href="https://yunpengzhang.github.io/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/"/>
    <id>https://yunpengzhang.github.io/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/</id>
    <published>2017-12-04T11:06:10.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现，组内的小伙伴对负载均衡组件有哪些还不清楚，总结了下，希望对大家能有写用处。</p><p>当用户点击了一次页面，到后端server执行完返回，经过了好几次传递，每次上游调用下游，都要使用负载均衡组件。</p><p>使用负载均衡组件有什么好处？</p><ol><li>自动选择存活的服务器，剔除掉“死掉”的服务。</li><li>保证请求能够按照分配均匀地分给服务端。</li><li>服务端增减机器，修改配置，对客户端透明。</li></ol><p>以上几点最深的体会就是。</p><p>作为服务端，不必急急忙忙地恢复死掉的服务，只要有存活的节点存在即可。因为有时你可能正在吃饭或睡觉。</p><p>作为客户端，服务端更换你不必配合发布，减少工作量，代码不用做业务外的特殊逻辑。</p><p>下面我们从前到后一次看看都有哪些组件供我们使用。</p><img src="/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/10971-20240718184248954.jpeg" class="" title="image"><p>如图所示，用户发起请求时，先从dns获取域名的真实ip，然后用真实ip来访问web服务器。用到了<code>tgw</code>组件。tgw对外是一个外网ip，后端挂载了多个内网实体ip。tgw会定期检测后端真实ip的服务是否存活，通过负载算法，选择存活的ip来进行访问。用户的请求会经过tgw，但是对用户来说是透明的。tgw的好处是节约外网ip，一个ip可以把一个机房的机器都挂载上。增减web server速度快，正常dns刷新要几小时到几天才全更新。</p><p>请求到了web server后，需要使用后端server提供的接口服务。通过CMLB组件来拉取后端的所有ip和负载分配配置，调用sdk来选择出一个最合适的ip，然后web server使用这个ip来访问后端。要接入CMLB，需要使用CMLB的sdk，在请求之前获取一次ip。虽然多加了几行代码，但是这种方式简单直观，还是web sever直接链接的后端。组件只起到了更新配置的作用。</p><p>但是在链接数据库，redis这些场景中，有些时候ip是写到php配置文件，或者框架配置文件中的。没有办法“多加几行选择ip的代码”。这时LB组件出现了，和tgw类似，只是都是内网ip。对服务调用方来说就是一个ip，只是在调用的过程中经过了LB的服务器做代理，他来透明的把请求转到后端适合的数据库服务器上。<br>用LB还有个注意的地方，通常LB为了节约资源，定3小时如果链接不使用，那么会自动断掉链接，对于客户端和服务器都是没有感知的，只有在下次调用时发现链接不存在了。所以要监控链接的返回值，发现连不上要重连。</p><p>又有个问题，CMLB和LB功能类似，是否可以互相替代呢？</p><p>答案是可以互相替代。LB是后来腾讯云出品的，如果没有CMLB完全可以用LB来实现同样的功能。CMLB在内部已经使用很多，相应的组件和监控也非常成熟。对于能控制代码获取ip的地方，使用CMLB。对于在配置中等写死ip的场景，使用LB。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>组件名称</th><th>使用场景和方法</th></tr></thead><tbody><tr><td>tgw</td><td>服务外网域名服务使用，同一个机房的服务器挂载到一个tgw的虚ip上。如果有提供https服务，需要把证书上传到tgw配置网页。在nginx上只提供http服务就可以。tgw会帮助做ssl校验和转换成http服务给后端。</td></tr><tr><td>CMLB</td><td>使用agent拉取远端配置ip列表，本地调用sdk获取最适合的ip和程序。</td></tr><tr><td>LB</td><td>和tgw类似，是内网版。可以给数据库、队列挂载LB的虚ip。要监控链接断开。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近发现，组内的小伙伴对负载均衡组件有哪些还不清楚，总结了下，希望对大家能有写用处。&lt;/p&gt;
&lt;p&gt;当用户点击了一次页面，到后端server执行完返回，经过了好几次传递，每次上游调用下游，都要使用负载均衡组件。&lt;/p&gt;
&lt;p&gt;使用负载均衡组件有什么好处？&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>CORS（跨站资源共享）介绍</title>
    <link href="https://yunpengzhang.github.io/2017/CORS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E4%BB%8B%E7%BB%8D/"/>
    <id>https://yunpengzhang.github.io/2017/CORS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E4%BB%8B%E7%BB%8D/</id>
    <published>2017-12-03T08:14:36.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>有同学在nginx站点配置中加了一行<code>Access-Control-Allow-Origin *</code>,导致微信中业务数据异常，抓包看http头有两个Access-Control-Allow-Origin字段，一个是站点自己的域名，一个是*。 为了实现跨域资源访问，在代码和nginx配置中都加了Access-Control-Allow-Origin字段，但是浏览器有个原则，如果有两个Access-Control-Allow-Origin字段，那么都失效，哪个都不信。最终导致了微信中打开异常。 也引出了CORS。</p><h2 id="定义和原理"><a href="#定义和原理" class="headerlink" title="定义和原理"></a>定义和原理</h2><p>什么是CORS跨站资源共享？</p><blockquote><p>跨站源资源共享（CORS）是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略[1]，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS[2]。</p></blockquote><p>简单说，就是为了实现跨站访问资源的遍历，同时保护浏览器使用者的安全，提出的一种规范。如何保护的安全，在下一结做介绍。 在html中的图片、css、js等静态引用，和ajax发起的动态请求，都受同源策略影响。如果有跨域，都可以用CORS来实现(也有其他方法，CORS是标准)。 跨域请求主要用于： - 调用XMLHttpRequest或fetchAPI通过跨站点方式访问资源 - 网络字体，例如Bootstrap（通过CSS使用@font-face 跨域调用字体） - 通过canvas标签，绘制图表和视频。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><h3 id="CORS怎么保护安全"><a href="#CORS怎么保护安全" class="headerlink" title="CORS怎么保护安全"></a>CORS怎么保护安全</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>保护用户访问网站的安全。防止用户在A站登录授权后，在访问恶意网站B时，B站在ajax中请求A站，获取A站的信息。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>保护服务器的静态资源、接口数据等，都被自己信任的域名访问，不被其他未授权的网站拉走数据。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>在header中带上Origin字段，标明是跨域请求。如果需要发送带凭证的数据（cookie、Http认证和客户端SSL证明等），将WithCredentials设为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure><p>如果请求服务器是非简单请求，浏览器会发出一个OPTION请求，和服务器协商信息。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器处理流程： 1 http头部是否有origin字段 2 没有，当成普通请求处理。 3 有，是否method是OPTIONS（preflight） 4 不是OPTIONS（简单请求），返Allow-Origin、Allow-Credentials等，并返回正常内容。 5 是，返回Allow-Headers、Allow-Methods等，内容为空。 nginx参考配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;xxxx&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, DELETE, PUT, OPTIONS&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Accept, Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;</span><br><span class="line">if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;xxxx&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, DELETE, PUT, OPTIONS&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Accept, Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;</span><br><span class="line">  add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;</span><br><span class="line">  add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line">  return 204;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、在代码或nginx一个地方修改，不要在一个http头中有多个Access-Control-Allow-Origin字段，否则会触发“起因”中的问题。 2、修改配置最好在nginx配置中修改，其次在代码中修改，但是一定不要两侧都改，容易造成两侧混乱不容易维护。 3、业务站点不要为了省事给Access-Control-Allow-Origin设置为*，权限太开会有安全隐患。 4、按规范实现的浏览器，会做拦截。如果没有填写Access-Control字段或填写错误，即使服务端返回了全部数据，浏览器也会拦截不给页面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yq.aliyun.com/articles/69313">CORS——跨域请求那些事儿</a> <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a> <a href="https://segmentfault.com/a/1190000003710973#articleHeader0">浏览器和服务器实现跨域（CORS）判定的原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;有同学在nginx站点配置中加了一行&lt;code&gt;Access-Control-Allow-Origin *&lt;/code&gt;,导致微信中业务数据</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>jump Consistent hash介绍</title>
    <link href="https://yunpengzhang.github.io/2017/jump%20Consistent%20hash%E4%BB%8B%E7%BB%8D/"/>
    <id>https://yunpengzhang.github.io/2017/jump%20Consistent%20hash%E4%BB%8B%E7%BB%8D/</id>
    <published>2017-10-24T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jump-Consistent-hash"><a href="#jump-Consistent-hash" class="headerlink" title="jump Consistent hash"></a>jump Consistent hash</h3><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>是一个hash分配算法，在增加或减少hash桶个数时，是有1&#x2F;n的节点被移动到新桶内，其他key所在的桶序号不变。</p><p>要求桶是按顺序编号的，相对于web缓存，更适合存储的场景。</p><h2 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h2><p>用于分布式存储产品中，而不用在缓存类型的产品。因为有节点不可用时，jumphash用存活节点分担不可用节点的能力不强，会导致分布不均。但是在存储类中，节点都会有主备，主节点不可用路由到备节点，key的分布不会有变化。</p><p>适合在<strong>分布式系统中</strong>，根据key来选择被分配到的服务场景。每次新增新的服务节点，只有1&#x2F;n的key会变动，不会因为扩容或缩容瞬间<br>造成大部分缓存失效。</p><p>但是也有局限，和其他的一致性hash相比。如果有中间的桶失效，是不能够像割环hash一样，均匀分配到其他节点的，只能找个新替换<br>节点来取代。但是优点是不用存储，计算量也不大。代码短，易于实现。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>利用线性同余计算的固定性，每次输入参数固定，输出就固定的特性，来替代用存储。利用运算，减少存储空间。</p><p>由于运算量的优化，比查找存储空间速度更快，所以从时间、空间上算法更优。</p><p>引申：有时用运算生成的数字串，映射要存储的空间，会使算法有意想不到的效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="type">uint64_t</span> key, <span class="type">int32_t</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        key = key * <span class="number">2862933555777941757ULL</span> + <span class="number">1</span>;</span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="built_in">double</span>(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>) / <span class="built_in">double</span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的全部代码，输入是64位的key，桶的数量（一般对应服务器的数量），输出是一个桶的编号（从0开始）。</p><p>jump consistent hash的设计目标是：</p><p>平衡性，把对象均匀地分布在所有桶中。</p><p>单调性，当桶的数量变化时，只需要把一些对象从旧桶移动到新桶，不需要做其它移动。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么上面的代码能够实现一致性hash的功能，我们一步一步来看。要实现的功能就是多加一个节点，节点数变为n，只有1&#x2F;n的key会变动。</p><p>我们先构造一个函数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch(key, num_buckets) </span><br><span class="line"></span><br><span class="line">表示有num_buckets个桶，一个key的值会分配到的bucket编号[0, num_buckets)。</span><br></pre></td></tr></table></figure><p>所以对于任意key，k，ch(k,1)&#x3D;0,因为只有一个桶。为了让算法平衡，ch(k,2)讲有一半的key留在0号桶中，一半的移到1号桶中。</p><p>总结的规律是，ch(k,n+1)和ch(k,n)相比，n&#x2F;(n+1)的key是不动的，1&#x2F;(n+1)的key移动到第n号桶。</p><p>对于每次新增桶的个数时，计算每个key的新位置，确定是否要移动到新的桶中。</p><p>通过随机数生成器，来判定key是否要移动到新的桶中，概率是1&#x2F;(n+1)要移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    int b = 0; // This will track ch(key, j +1) .</span><br><span class="line">    for (int j = 1; j &lt; num_buckets; j ++) &#123;</span><br><span class="line">        if (random.next() &lt; 1.0/(j+1) ) b = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代码中的random.next()产生[0,1)的随机数，随机数序列只和key有关，key为随机种子。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码是满足算法的平衡性和单调性的，算法复杂度是O(N)。满足了正确性，接下来优化性能。</p><p>从算法代码可以看出，大多数情况下<code>random.next() &lt; 1.0/(j+1)</code>是不被执行的。</p><p>对于一个key来说，ch(key,j+1)的值，很少会随着j增长而变化的。当ch(key,j+1)!&#x3D;ch(key,j)时，<br>ch(key,j+1)&#x3D;j。</p><p>&#x2F;&#x2F;我们假设ch(key,j)是一个随机变量，通过伪随机数，来确定一个数值b，当j增长到b时，ch(key,b)!&#x3D;ch(key,b-1),<br>并且ch(key,j)&#x3D;ch(key,b-1)。</p><p>假设一个key的值为k，b为一个跳变的桶数量。则ch(k,b)!&#x3D;ch(k,b+1),并且ch(k,b+1)&#x3D;b.</p><p>下面寻找下一个比b大的跳变的桶数量j。则ch(k,j+1)！&#x3D;ch(k,j),ch(k,j)&#x3D;b,ch(k,j+1)&#x3D;j。<br>有</p><p>ch(k,b+1)&#x3D;b</p><p>ch(k,j)&#x3D;b,</p><p>ch(k,j)&#x3D;ch(k,b+1)</p><p>ch(k,j+1)&#x3D;j</p><p>ch(k,b)!&#x3D;ch(k,b+1)</p><p>ch(k,j+1)！&#x3D;ch(k,j)</p><p>所以，我们已知k，b时，要找到j，对于(b,j]区间的变量i，如果不发生跳变，必须满足<br>ch(k,i)&#x3D;ch(k,b+1)。</p><p>所以有概率</p><p>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先举几个例子P(ch(k,10)=ch(k,11))的概率是10/11,</span><br><span class="line"></span><br><span class="line">P(ch(k,11)=ch(k,12))的概率是11/12,</span><br><span class="line"></span><br><span class="line">所以P(ch(k,10)=ch(k,12))的概率是P(ch(k,10)=ch(k,11))*P(ch(k,11)=ch(k,12))=(10/11)*(11/12)=10/12</span><br><span class="line"></span><br><span class="line">对于任意的n&gt;=m,P(ch(k,n)=ch(k,m))=m/n。</span><br></pre></td></tr></table></figure><p>所以对于上面的等式，<br>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))&#x3D;(b+1)&#x2F;i。</p><p>假设一个随机数r在(0,1)区间，由k和j确定。</p><p>如果r&lt;&#x3D;(b+1)&#x2F;i,那么P(j&gt;&#x3D;i)&#x3D;（b+1)&#x2F;i为不跳变。<br>那么产生随机数r后，就能确定i的最小值为(b+1)&#x2F;r。<br>因为r&lt;&#x3D;(b+1)&#x2F;i   &#x3D;&gt;    i&lt;&#x3D;(b+1)&#x2F;r.</p><p>又因为i是整数，所以有<br>r！&#x3D;0</p><p>i&#x3D;floor((b+1)&#x2F;r)</p><p>代码可改写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">random.seed(key);</span><br><span class="line">int b = -1; // bucket number before the previous jump</span><br><span class="line">int j = 0; // bucket number before the current jump</span><br><span class="line">while (j &lt; num_buckets) &#123;</span><br><span class="line">b = j;</span><br><span class="line">r = random.next();</span><br><span class="line">j = floor((b + 1) / r);</span><br><span class="line">&#125;</span><br><span class="line">return = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设r的期望为0.5，时间复杂度为Olg(N)。<br>这个算法有点绕，通过随机数的产生来判定下一跳的j，优化算法，保证在整体key的跳变满足增加桶数为n+1时，只有1&#x2F;(n+1)的数据移动。</p><p>我们再看</p><p>key &#x3D; key * 2862933555777941757ULL + 1;<br>j &#x3D; (b + 1) * (double(1LL &lt;&lt; 31) &#x2F; double((key &gt;&gt; 33) + 1));</p><p>和<br>r &#x3D; random.next();<br>j &#x3D; floor((b + 1) &#x2F; r);</p><p>有什么关系。</p><p>利用线性同余算法产生一个64位的整数，然后通过映射到（0，1]区间的小数。</p><p>(key&gt;&gt;33)+1是取key值的高31位的值再加1，范围为(1,2^31+1)<br>1LL&lt;&lt;31的值为2^31。</p><p>所以<br>[(key&gt;&gt;33)+1]&#x2F;1LL&lt;&lt;31 的取值范围是(0,1],如果(key&gt;&gt;33)&#x3D;2^31那么会大于1，由于是c的整数运算，大于1也会取证忽略掉小数部分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该算法的精髓：通过随机种子产生随机数，减少存储；利用概率和随机数，确定key在bucket_num范围内落在的桶序号。</p><p>既减少了运算量，也易于实现，对于存储类路由非常适合，而且key的分散性不依赖key本身，只依赖随即生成器，对key的要求不高，不用做转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://blog.helong.info/blog/2015/03/13/jump_consistent_hash/</span><br><span class="line">https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;jump-Consistent-hash&quot;&gt;&lt;a href=&quot;#jump-Consistent-hash&quot; class=&quot;headerlink&quot; title=&quot;jump Consistent hash&quot;&gt;&lt;/a&gt;jump Consistent hash&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>快速了解一致性hash算法</title>
    <link href="https://yunpengzhang.github.io/2017/[%E9%80%9F%E6%88%90]%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>https://yunpengzhang.github.io/2017/[%E9%80%9F%E6%88%90]%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2017-07-17T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一致性hash算法，在维基百科的定义是：</p><blockquote><p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where  K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p></blockquote><p>翻译过来的意思就是当hash表更新节点的数量时，只有k&#x2F;n的关键字位置有变化，其他关键字的位置映射关系不变。与其他的hash算法比，其他的算法节点个数n变化后，更多的key关键字和节点的映射会发生变化。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一致性hash主要用在路由中，对有状态的服务，根据key进行转发到对应的服务中。保证相同的key一直落到同一个服务器，当有服务节点增减时，只有少量(k&#x2F;n)的请求位置是变化的。减少重新建立缓存或存储的成本。</p><h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>前提：</p><ul><li>每个请求的key范围[0,2^32)，一共有k个key;</li><li>一共有N个节点，结点和服务器对应。</li></ul><h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><p>取key所映射的所有值最大空间（2^32）个，组成一个环，然后随机在这个环上落N个点，相邻的两个点形成一个左闭右开（关于左闭右开参考《聊聊左闭右开区间》)区间。共有N个区间。</p><p>对于每个key，一定只落在N个区间中的一个，它属于该区间所分配的节点。</p><p>当有服务节点增减时，会有区间新增或消失，平均只有k&#x2F;N个key会受影响，变更属于的节点。</p><p>如下图，在插入nodeC之前，2、3、8key都属于nodeA，当插入nodeC后2、3归属C，属于B的节点不会改变。</p><p>[</p><h4 id="改进：增加虚节点"><a href="#改进：增加虚节点" class="headerlink" title="改进：增加虚节点"></a>改进：增加虚节点</h4><p>常规实现在实际应用中会遇到问题。当N的数量太少时，会导致N个节点所管辖的区间并不均匀。</p><p>既然是N的数量太少，那增加N的数量不就行了?正解，可以成倍地增加N的数量，一个实际的节点扩充为100倍的虚节点，每个key先查找属于哪个虚节点，再查看该虚节点属于那个实节点。</p><p>由于众多虚节点的引入，使每个实节点被分配到的key数量的差距变少。</p><img src="/2017/%5B%E9%80%9F%E6%88%90%5D%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7335-20240718184029676-1299231-1299232.png" class="" title="image vnode common"><p>从图中可见，增加了nodeA和nodeD的虚节点后，把区间分得更细小，会使分布更均匀。还可以通过设置权值，让不同处理能力的实节点，处理不同量级的key。</p><h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>通过上面的讲解，可以熟悉一致性hash的算法，但是在实际使用中，还是有很多需要注意的地方。</p><h4 id="如何加入虚节点"><a href="#如何加入虚节点" class="headerlink" title="如何加入虚节点"></a>如何加入虚节点</h4><p>加入虚节点能够解决分布不均的问题，但是如何加入也是有技巧的。如果完全随机，就是撞大运编程。要利用搜索算法，加入节点时要检测，保证每个实节点的区间不能差异太大。必要时要回溯，剪枝，或者用启发性搜索。</p><h4 id="节点配置同步"><a href="#节点配置同步" class="headerlink" title="节点配置同步"></a>节点配置同步</h4><p>一个大系统，每个真实节点有1000个虚节点，一共1000个实节点，有1M条目数据。每当更新节点信息时，要保证快速更换、传递更新数据，而且要有检查功能。节点配置的同步、检测也会有很多细节问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;一致性hash算法，在维基百科的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Consistent hashing is a speci</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>【思考】一致性hash切分环的问题</title>
    <link href="https://yunpengzhang.github.io/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yunpengzhang.github.io/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2017-07-17T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>在《了解一致性hash算法》中介绍了一致性hash ring的实现算法。</p><p>但是切割hash环的时候，遇到一个思考题：</p><blockquote><p>在数字环上随机落N个点，把环切分成N个区间，原点要算一个切分点吗？如果算，就只产生N-1个随机数就可以了，如果不算，要产生N个随机点。</p></blockquote><img src="/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/7545-20240718184048481.jpeg" class="" title="image"><p>为什么会产生这个疑问？如上图，把hash用三个绿色点分割了三段。如果把环从蓝色的0点打开，变成右边的直线。直线被分成了四段。随机分割直线四段，肯定用右边的方法，为啥切割hash环就用左边的方法呢？</p><p>最终owen认为，还是要把0点当作一个已经切分过的node来处理，因为每次产生的随机数，都是按照右边展开的直线的空间来落点，分割直线的。环只是一个让人容易理解的模型，真正实现时还是按照一维来生成随机点的。否则，跨过0点的区间段，会是其他区间的二倍。</p><p>在工程实践中，为什么也没发生不均匀的问题，用的好好的呢？</p><p>有两个原因：</p><p>一、引入了虚节点，分割的区间太多，即使跨0点有两个区间段，也在程序接受的误差范围内。</p><p>二、由于是随机落点，分割的区间段大小不一，检测程序也会控制各实节点间的误差符合项目要求。</p><p>顺便说一下，把0点作为一个已切分的点还有个好处：不用特别考虑跨0区间key的归属情况，程序容易写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把零点算作一个node，产生N-1个节点切分hash环；</p><p>实际切分的区间是否均匀，要靠检测程序来检查，不能只依赖理论推断。</p><hr><blockquote><p>在数字环上随机落N个点后，发现0点所在的区间长度，要比其他段长，是其他段的两倍。<br>随机落点的算法是：在环的区间范围[0,n)的区间随机产生N个整数，然后落点。</p></blockquote><p>该问题导致随机的N个点并不均衡，实际上0所在的服务器会有更大的负载。如果虚拟节点多过多，会掩盖这个问题，也不会造成太大的麻烦。</p><p>如何解决？</p><p>在0点也插入一个节点，分为N+1个区间，每个区间就都均衡了。</p><p>为什么？</p><p>把hash ring想象成为一条线段，在线段上随机落N-1个点，那么这N-1个点给线段分割为N段左闭右开的区间，本质上和hash ring的算法是一样的。如果落得点多，每段线段长度的期望相同，都是n&#x2F;N。在hash ring算法中，0所在的点被包含在了首位两个段中，所以期望是其他段的两倍。</p><p>如果以其他的点为起始点，以随机数偏移落点，和上面的情况类似，只是把圆按照偏移转了个相应的角度，不影响算法的结果。起始点所在的区间也是其他区间的二倍。</p><p>原因是和落点的随机算法有关，因为每次落点的随机数，都是以起始点开始，到终点结束的范围内产生随机数。在这个一维空间内产生随机点的均匀程度，是相对于起止点两点的范围产生，在0点和环上对应，相当于已经落了一次点。</p><p>以上只是由想法退出，并没有严格的推论，如果有人知晓，烦请指正。</p><p>附模拟程序和实验结果，在[0,1000000)的hash环上，随机落10,000个点，每次落点的位置都是[0,1000000)区间产生的随机整数所在点的坐标，分为10,000个段，平均每段长度100，执行100次，发现最大长度分布都在200左右，最小长度都在100左右。</p><p><a href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/">http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</a></p><p>import random<br>from bisect import bisect_left</p><p>ITEMS &#x3D;  1000000<br>NODES &#x3D; 100<br>node_stat &#x3D; [0 for i in range(NODES)]</p><p>ring &#x3D; []<br>hash2node &#x3D; {}</p><p>for n in range(NODES):<br>    h &#x3D; random.randint(0, 10000)<br>    ring.append(h)<br>    hash2node[h] &#x3D; n</p><p>ring.sort()</p><p>print len(ring)</p><p>for item in range(ITEMS):<br>    h &#x3D; random.randint(0, 10000)<br>    n &#x3D; bisect_left(ring, h) % (NODES)<br>    node_stat[hash2node[ring[n]]] +&#x3D; 1</p><p>print sum(node_stat), node_stat, len(node_stat)</p><p>_ave &#x3D; ITEMS &#x2F; NODES<br>_max &#x3D; max(node_stat)<br>_min &#x3D; min(node_stat)</p><p>print(“node_stat[0]: %d” % node_stat[0])<br>print(“node_stat[-1]: %d” % node_stat[-1])<br>print(“Ave: %d” % _ave)<br>print(“Max: %d\t(%0.2f%%)” % (_max, (_max - _ave) * 100.0 &#x2F; _ave))<br>print(“Min: %d\t(%0.2f%%)” % (_min, (_ave - _min) * 100.0 &#x2F; _ave))</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《了解一致性hash算法》中介绍了一致性hash ring的实现算法。&lt;/p&gt;
&lt;p&gt;但是切割hash环的时候，遇到一个思考题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数字环上随机落N个点，把环切分成N个区间，原点要算一个切分点吗？如果算，就只产生N-1个随机数就可以</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>聊聊左闭右开区间</title>
    <link href="https://yunpengzhang.github.io/2017/%E8%81%8A%E8%81%8A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4/"/>
    <id>https://yunpengzhang.github.io/2017/%E8%81%8A%E8%81%8A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4/</id>
    <published>2017-05-21T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《编程珠玑》里说过：大约10%的专业程序员，才能够正确地写出二分查找。尽管第一个二分查找程序于1946年就公布了，但是第一个没有bug的程序在1962年才出现。</p></blockquote><p>二分查找易错的主要原因：缩小查找范围的区间切分不对。如果使用左闭右开区间划分，就很难出错了。</p><p>左闭右开区间在STL数据结构的构造参数，一些api的返回值范围等场景，也都广泛应用。仔细思考，是有些规律在里面的。</p><p>先来看三个使用的场景。</p><h3 id="一、javascript随机数返回值"><a href="#一、javascript随机数返回值" class="headerlink" title="一、javascript随机数返回值"></a>一、javascript随机数返回值</h3><p>在js中，产生随机数函数 <code>Math.random()</code> 返回值是<code>[0,1)</code>间的实数。</p><p>通过偏移和缩放返回值，能映射到任意实数区间。再通过取下界，随机产生任意整数，从而满足生成各种随机数的场景。</p><p>如果返回范围是全封闭，全开，或者左开右闭可以吗？<br>答案是不可以。</p><p><strong>全封闭</strong>：包含了上界的1，会造成产生整数的随机数概率不均匀。</p><p>例如要随机产生0-9十个整数，做法是<code>Math.floor(Math.random()*10)</code>,产生的数是均匀随机，满足需求。如果包含了上界的1，那么产生10是超出范围的。只有随机出1时才产生10，概率要比其他整数小很多，随机的概率就不均匀了。</p><p><strong>全开区间</strong>：没有了0点，映射生成整数的时候，产生0的概率要比其他整数的概率要低，生成的随机数概率不均。</p><p><strong>左开右闭</strong>：左开右闭和左闭右开是对称的，也可以。只是左闭右开更习惯些。</p><h3 id="二、迭代器遍历"><a href="#二、迭代器遍历" class="headerlink" title="二、迭代器遍历"></a>二、迭代器遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，数组的个数是count，遍历的循环下标的区间也是左闭右开[0,count)。因为数组是从0开始计数，所以不能包含上界。</p><p>A、要写为左右都是闭区间，[0,count-1]也是可以的。但是有个减一比较别扭。</p><p>B、有些迭代器，例如链表或数的子节点指针，就要设计个哨兵节点表示结束，判断结束时直接判断迭代器是否不等于end，不用右开区间，要判断next是否是null，会多出一些额外的判断，对一些边界要用特殊逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(iterator it=a.<span class="built_in">start</span>();it!=a.<span class="built_in">end</span>();++it)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、在算法和api中的左闭右开区间"><a href="#三、在算法和api中的左闭右开区间" class="headerlink" title="三、在算法和api中的左闭右开区间"></a>三、在算法和api中的左闭右开区间</h3><p>在C语言标准库的二分查找bsearch，快速排序qsort的函数里，无论是函数内部实现，还是参数，都传的左闭右开区间；</p><p>在STL容器的构造函数，算法操作，也都是左闭右开区间。</p><p>一方面是为了容易迭代，更通用。</p><p>另一方面是像二分、快排，都是分治算法，一个左闭右开区间<code>[x,y)</code>，子区间可以分解为<code>[x,y0),[y0,y1),[y1,y2)...[yn,y)</code>，父子同构，天然适合分治实现。</p><p>在整数范围内，如果非要写为左闭右闭区间，也是可以的。<code>[x,y]</code>分解的子区间为<code>[x,y0-1],[y0,y1-1],[y1,y2-1]...[yn,y]</code>。但是无论怎么分，总有一个区间和其他不同，划分偏左或偏右一个元素，划分是不<strong>整齐</strong>的。要打各种边界处理补丁来弥补。</p><p>在实数范围来进行计算，就用左闭右闭区间就不能实现了。</p><p>例如利用二分在单调递增的函数上逼近计算，每次都是分为[x,(x+y)&#x2F;2),和[(x+y)&#x2F;2,y)两个区间，如果左右封闭，要么进行一次重复判断计算，要么表示不出来。在实数范围内，给定一个实数x0，是给不出和他距离最小的x1的确切值的，更别说用计算机表示了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>左闭右开区间划分的子区间，也符合左闭右开的性质，划分前后同构；</p><p>按比例划分子区间后，映射到边界节点上的概率互成比例；</p><p>全闭区间要处理边界情况，边界点需特殊处理，对程序设计和算法理解造成障碍。</p><p>综上，<strong>在应用数字范围的场景中，抽象成左闭右开区间，是一个好方法。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《编程珠玑》里说过：大约10%的专业程序员，才能够正确地写出二分查找。尽管第一个二分查找程序于1946年就公布了，但是第一个没有bug的程序在1962年才出现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二分查找易错的主要原因：缩小查找范围的区间切</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何看待优化</title>
    <link href="https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BC%98%E5%8C%96/"/>
    <id>https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BC%98%E5%8C%96/</id>
    <published>2017-02-19T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.363Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯曾经有句很经典的话——先抗住再优化。</p><p>优化和需求相比，永远都是排在第二位的，唯快不破，首先是要业务生存下来，然后才是如何稳定运营业务。</p><p>见到一些技术人员，包括刚工作是的自己，恨不得把架构代码打磨得无可挑剔，用当下最流行最“高效”的技术。而且还会说“要有技术追求；不能等到撑不住的时候再优化，那就来不及了……”</p><p>到底应该如何优化，什么时候优化，要遵守以下几个原则。</p><h2 id="先弄清极限容量，自己能撑多少"><a href="#先弄清极限容量，自己能撑多少" class="headerlink" title="先弄清极限容量，自己能撑多少"></a>先弄清极限容量，自己能撑多少</h2><p>先弄清楚现在系统的容量，什么地方是瓶颈，到多少访问量、用户的时候才会有问题。如果说目前用户1万，到100万时有问题，公司要5年后到达这个量级。那么可以停下了，先做其他需求去，在这五年内有好多事可以做。</p><p>如果马上就要撑不住了，那么就是最重要的问题了，要着手处理。优化的原则是不影响当下的体验，有时即使发现从前的地方有问题，也要先保证功能不变，完成优化后再进行修改。</p><p>有些人会以语言性能不行，换框架、或语言，说新的更优，速度更快。但是你的用户量到达拼最底层速度的时候了吗，是不是中间的逻辑没写好，真正的瓶颈在哪？你弄清楚了吗？</p><h2 id="突破业务瓶颈后，都有哪些地方要优化修改"><a href="#突破业务瓶颈后，都有哪些地方要优化修改" class="headerlink" title="突破业务瓶颈后，都有哪些地方要优化修改"></a>突破业务瓶颈后，都有哪些地方要优化修改</h2><p>先弄清容量后，要处理预案。万一哪天到达瓶颈，是不是扩充机器，或者用什么其他资源置换的方法，能够撑过去，保证业务稳定前行。然后用计划的优化方法慢慢处理。要先有预案，但不用马上执行，真到来的时候，按部就班就能够应对了。</p><h2 id="评估优化的方案，真的有所提升吗"><a href="#评估优化的方案，真的有所提升吗" class="headerlink" title="评估优化的方案，真的有所提升吗"></a>评估优化的方案，真的有所提升吗</h2><p>有些人说c比php快，要早换语言，能够让性能提升。这是“政治正确”的，但是有没有想过，真的用户量大了以后，代码的设计架构都要修改了，用c就能解决一切问题？</p><p>总之，是否优化要心里有数。在开发设计之处，就要考虑到扩展性，把一些不容易改变的（协议、架构）先确定，有些就是要牺牲和不同时间不一样的。一万用户时的投入量和百万用户时的投入量肯定是不一样的，很多过早优化都没有考虑全面，到后面还是避免不了优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;腾讯曾经有句很经典的话——先抗住再优化。&lt;/p&gt;
&lt;p&gt;优化和需求相比，永远都是排在第二位的，唯快不破，首先是要业务生存下来，然后才是如何稳定运营业务。&lt;/p&gt;
&lt;p&gt;见到一些技术人员，包括刚工作是的自己，恨不得把架构代码打磨得无可挑剔，用当下最流行最“高效”的技术。而且还</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>如何处理运营事故</title>
    <link href="https://yunpengzhang.github.io/2016/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85/"/>
    <id>https://yunpengzhang.github.io/2016/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85/</id>
    <published>2016-12-06T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>事故发生时的情景。</p><p>处理步骤：1.告知leader 2.恢复业务保留现场信息 3.复盘修复bug，继续发布验证</p><p>其他：验证方法，黑盒法，只看结果，用abtest，新老或异构两套对比；白盒法，在关键节点，异常部分加上报，统计，在程序围观层面查看。排查问题可以用二分法，排除法。</p><p>心态：要有颗强大包容的心，每一次事故都是对自己的一次提升，吃一堑长一智。<br>变被动为主动，主动发现，预防事故，积累经验，提高意识。</p><hr><blockquote><p>终于发布完成了，还没等休息，收到一堆告警短信，收件箱都快炸了；</p><p>刚发完特性不到一天，客服群里用户反馈，数据错了，多扣钱了；</p><p>半夜睡觉，突然被短信吵醒，业务崩溃了……</p></blockquote><p>以上这些场景，对于做过后台大系统的人来说，都应该有遇到过。每次线上事故都会让人刻骨铭心，都会扰乱你的日常。</p><p>事故是不可避免的，只要有人写的程序，就会有bug，就会酿成事故。遇到事故，我们应该怎么办呢？</p><h3 id="告知leader和相关人"><a href="#告知leader和相关人" class="headerlink" title="告知leader和相关人"></a>告知leader和相关人</h3><p>事故会影响业务，千万别想隐瞒，自己偷偷修改。遇到问题要先抛出来，把影响情况如实地告诉leader和相关人。然后就不是你一个人在战斗，会有人帮你想办法，check你修复的方法。帮助你尽快地度过危机。如果一个人捂着，默默地修改，会头脑不清醒，可能会一根筋。曾经就有人直接到数据库修复用户数据，没备份，结果都改乱了，越忙事情越多。如果事故影响很大，要通知公关，和更高层的leader。你的leader会帮你做这些事，帮你处理。让你专心处理线上问题。事故发生时一般人都是很紧张的，有些人改问题手都是抖得，想想几百万用户都登录不上，是多么可怕。尽快告知上级，会有经验更丰富的人帮你，挺你，所以这才是第一要做的。</p><h3 id="尽快恢复业务"><a href="#尽快恢复业务" class="headerlink" title="尽快恢复业务"></a>尽快恢复业务</h3><p>来不及了，快上车。事故来时如排山倒海，例如用户都登录不上，页面打不开，游戏掉线。查看是哪行代码导致意义不大。一般事故都是更改发布导致，变化导致问题。所以确定是发布问题，马上回滚，让业务恢复到正常水平。中间如果有操作，详细地记录下来，方便日后复盘。有些单机的日志，也要拷贝，防止时间长了日志被滚掉。</p><p>因为架构，或访问量突增导致的事故，马上扩容，恢复业务。真的到山穷水尽，不能马上恢复，发条微博，安民告示，告诉你的用户，你正在努力恢复中也好，一般都是由公关来发，开发给出评估的结论。</p><h3 id="用测试系统复盘，修复问题，重新起航"><a href="#用测试系统复盘，修复问题，重新起航" class="headerlink" title="用测试系统复盘，修复问题，重新起航"></a>用测试系统复盘，修复问题，重新起航</h3><p>线上的问题已经修复了，但是程序的bug还没找到。这时才是慢慢地找问题，仔细修复。在测试环境构造出问题的场景，修复后再验证，是否不再发生。经过详细的测试，没有问题，再次发布起航，把新特性发出去。</p><h3 id="总结事故，防微杜渐"><a href="#总结事故，防微杜渐" class="headerlink" title="总结事故，防微杜渐"></a>总结事故，防微杜渐</h3><p>人不应该被同一块石头绊倒两次，每次事故也是一次财富。认真总结，积累经验，认真总结，防止下次再犯。成本最低的是吸取别人的教训，以后哪些地方要测试，哪些地方要小心。每一次总结都是一次进步。不要因为事故被打到，增强心态，提高遇事不乱的能力。变被动为主动，主动发现，预防事故，积累经验，提高意识。</p><p>最后，祝大家都少发生事故，业务越来越稳定！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事故发生时的情景。&lt;/p&gt;
&lt;p&gt;处理步骤：1.告知leader 2.恢复业务保留现场信息 3.复盘修复bug，继续发布验证&lt;/p&gt;
&lt;p&gt;其他：验证方法，黑盒法，只看结果，用abtest，新老或异构两套对比；白盒法，在关键节点，异常部分加上报，统计，在程序围观层面查看。排</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>创业公司如何选择编程语言</title>
    <link href="https://yunpengzhang.github.io/2016/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>https://yunpengzhang.github.io/2016/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</id>
    <published>2016-12-02T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>写作目的：说明如何选择编程语言，对不同语言的认识。</p><p>结构：</p><p>说明问题：语言太多，对于初创公司，选择是一个问题。</p><p>结论：看菜吃饭。根据公司的目标，能够快速出产品为主。当前团队对语言的熟悉程度，已有资源对语言的支撑；还要兼顾可维护性，招人的难度，以及语言的学习难度。</p><p>结构：</p><ol><li>大家的知识背景，用最熟悉的语言和工具，能够快速出产品。</li><li>根据语言特性，不同语言应对不同的使用场景。例如：php适合网页开发；C++适合计算密集型、游戏引擎等的开发；python有很多数据分析的库；nodejs也很适合前端转后端。</li><li>市场上招人的难度和成本，php很多,C++的很少。</li><li>已有的成熟组件的语言代码。例如有个现成的其他语言，是不是可以改改。例如csdn还是asp，LOL也有用java写的部分，有大多数游戏用的都是erlang语言，因为留出代码是这个。</li><li>语言只是工具，不要被语言所累，能实现目标最好，没有高低之分。语言的功能之间是等价的，没有什么做不了、能做的，都可以做，只是难度问题。用php支持http协议很简单，如果用c自己写，就难度很大了，也很难和其他工具结合。</li></ol><hr><p>公司初创时，产品定下来了，就差程序员开发了。这时候又出现了新问题，用哪种语言来开发，也需要一些时间来讨论。</p><p>有些人建议用新的语言，缺陷最少的；有些建议用大家最熟的，到底用新的还是老的呢？</p><p>要明白团队的目标是什么，从团队的目标出发。</p><p><strong>如果有现成的代码或方案改装，那么就用现成的。</strong>   能够快速出产品，缩短开发周期，减少bug率。例如已经有开源的产品，只是在上面精简修改些特性就能运行了，那么直接用。如果团队对里面的语言不熟，只能通过学习解决。要是真的hold不住，那么可以用灵活一点的方法，核心功能用外部代码，扩展功能可以分到其他周边模块，用团队擅长的语言处理。像一些游戏引擎，都是window下的代码，和团队linux下开发经验不匹配。可以把引擎游戏部分用外部引擎实现，尽量少改动。周边系统通过网络通信和引擎衔接，用团队最擅长的语言来实现。有听说为什么广州的erlang开发游戏的很多，是因为最早有一套游戏代码留出，就是erlang的。大家为快速搭建和使用，肯定直接用erlang啊。</p><p><strong>语言有不同的特性，在选择的时候也要慎重。</strong> 每种语言都有自己擅长的场景，有众多的库和工具链作为依存。php对web类开发很擅长，有众多的工具和库，甚至现成的解决方案，如果用c来写web处理，就比较捉襟见肘了。对于计算密集型的业务，动态语言天生有速度弱势，应该避免。还有unity，对C#支持要比js更好些，即使团队都会js，也还是尽量用C#吧，否则产品质量堪忧。</p><p><strong>人的成本也很重要，要思考招人的难度。</strong> 否则团队扩大到一定规模，必定受人才数量限制。在不同地域，不同语言掌握的人的数量也不一样。如果是小众语言，找人的难度会大很多，例如ruby或者go，还没有那么多的人会。要培养出一个厉害的程序员，也很难。所以团队打算扩大规模的，不得不考虑技术人员的数量和质量问题。</p><p><strong>语言只是工具</strong> ，有些程序员有语言清洁，或者洁癖。排斥自己不喜欢的语言。其实这东西就是个工具，类似用刀叉吃饭还是筷子吃饭。看你熟悉哪个，哪个效率高，用适合的东西办适合的事。我们的目的不是语言测评和比赛，而是用工具做出产品，造福人类:)</p><p>归根结底，看菜吃饭，根据公司的目标，能够快速稳定出产品为主。当前团队对语言的熟悉程度，已有资源对语言的支撑；还要兼顾可维护性，招人的难度，以及语言的学习难度，来选择开发语言，已解决最重要的问题为重！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写作目的：说明如何选择编程语言，对不同语言的认识。&lt;/p&gt;
&lt;p&gt;结构：&lt;/p&gt;
&lt;p&gt;说明问题：语言太多，对于初创公司，选择是一个问题。&lt;/p&gt;
&lt;p&gt;结论：看菜吃饭。根据公司的目标，能够快速出产品为主。当前团队对语言的熟悉程度，已有资源对语言的支撑；还要兼顾可维护性，招</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>python参数</title>
    <link href="https://yunpengzhang.github.io/2016/python%E5%8F%82%E6%95%B0/"/>
    <id>https://yunpengzhang.github.io/2016/python%E5%8F%82%E6%95%B0/</id>
    <published>2016-07-15T10:00:03.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a = []</span>):</span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"> </span><br><span class="line">b = []</span><br><span class="line"> </span><br><span class="line">b = func()</span><br><span class="line"><span class="built_in">print</span> b</span><br><span class="line">b = []</span><br><span class="line">b = func()       </span><br><span class="line"><span class="built_in">print</span> b</span><br></pre></td></tr></table></figure><p>实际的打印结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 1]</span><br></pre></td></tr></table></figure><p>如果在C++ 里，两次打印的结果不应该有变化，而在python里，函数参数和变量赋值的规则和C++ 是不同的。</p><p>在C++中，每次调用函数时，参数是每次函数调用时在栈上重新生成赋值的，是把值放到变量所表示的地址里。</p><p>那么，在python中呢？python也是每次把值的地址赋值给变量，例如参数了的a&#x3D;[],里面的[]是一个对象，每次都是把这个对象的地址赋值给a，然后a实际操作的是[]，可以把[]想想为C++中的一个指针变量，每次都是把他赋值给a。同理，python中的每个变量都是表示一个唯一的对象，每次赋值都是把自身的地址传给另外一个变量。</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">a=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>1和2是两个对象，每次赋值是把a所指向的指针变了，1和2两个变量和存放的地址并没有改变。</p><p>再看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>]=a</span><br></pre></td></tr></table></figure><p>结果不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[1,[1,2,3],3]</span><br></pre></td></tr></table></figure><p>而是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[1,[...],3]</span><br></pre></td></tr></table></figure><p>无限循环了，为什么呢？因为让a[2]的这个元素指向了a自身，形成了一个有环的链表。</p><p>如果要达到正常赋值怎么办呢？使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[2]=a[:]</span><br></pre></td></tr></table></figure><p><code>a[:]</code>重新生成了一个对象的拷贝，而不是原来的那个对象了。</p><p>为了好理解，可以参考链接</p><p><a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables">http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables</a></p><p>把C++的变量赋值想象为是把值放到变量的盒子里，而python的赋值是把变量不变，在上面挂一个标签，这样是否好理解呢？</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/">http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/</a></p><p><a href="http://python-china.org/t/738">http://python-china.org/t/738</a></p><p><a href="http://my.oschina.net/leejun2005/blog/145911#OSC_h3_1">http://my.oschina.net/leejun2005/blog/145911#OSC_h3_1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>想要的总能找到</title>
    <link href="https://yunpengzhang.github.io/2013/2014-01-31-i_think_not_all_think/"/>
    <id>https://yunpengzhang.github.io/2013/2014-01-31-i_think_not_all_think/</id>
    <published>2014-01-30T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>最近在网上买东西，发现不管什么物品，在网站上都有好评和差评，而且有时评论的几乎都是一个特性。例如：同一款路由器，好评里说穿墙能力强，差评里说穿墙能力弱。<br>都振振有词，可能是不同的建筑，使用环境，或不同批次的货品的差异。但是发现个现象，最终还是心里想买哪款，最后就买哪款。寻找的过程只不过是增强下决心。因为<br>网络已经太大了，只要你心里有个想法，都能在网上找到相同的声音，而人也不自觉地过滤掉不同的声音，用相同的意见来巩固自己的观点。</p><p>买东西，主要看下产品属性，价格是否合适。查下是否有明显的缺点，剩下就follow your heart就可以了。</p><p>卖东西的，也有办法，只要能把产品的口碑做起来，加上宣传和竞品的差异，优势，还是会坚定买家的决心的。能把有力自己的都弄到百度的前几页，基本上就ok了。</p><p>还有机械键盘，网上有人说超级好用适合程序员写程序，有人说还是喜欢薄膜键盘，用xxx款觉得最好。最后，想买机械的人还是想买，不想买的最后也根据和自己想法相同<br>的观点来找了个不买的理由。这个很简单，自己体验下，从心里觉得到底是否好使。就像说牛肉是否好吃，有些人觉得好吃，但是有人天生爱吃素，都说得有道理。</p><p>好多东西还是要自己体验下比较好，听别人的都不准确。他觉得爽的不一定适合你。另外只有体验后，才能更有对比。苹果好还是安卓好，两种都用过，并且都用的程度<br>都很沉，才能写出区别。而且就这样，他用的场景和你用的也不一定相同。</p><p>春节期间，微信钱包推出，吸引了几百万张绑卡。有些人会觉得好厉害，我周围的人都在用。但是有的人觉得也没什么，我周围的人没人用。谁说的是真的呢，都是真的。<br>发红包抢红包的都是熟人之间，当然现实生活中也群分了。所以，如果要推出一款产品，不要你以为，你周围……要从客观的角度来看，很可能你被你周围的人给挡住了看不<br>清全世界。体会不到大环境的幸福和悲惨。</p><p>网络越来越发达了，每个个体的声音都能在网上公布并迅速检索到。你想要的想法，观点，在网上都能找到，你一定能找到你适合的群体。你的任何想法，能力，最终都会<br>变成一股力量，找到欣赏和能发挥的地方。如果把人的思维也当作一种商品的话，那么都能给他卖出去，总有个地方需要，虽然可能在大多数地方一文不值。</p><p>以后这种发现群体和提供自发组织平台的服务很重要，而从前那种bbs，圈定了喜好范围的产品，将会有一部分被分流走。新一代互联网，人和人之间自助寻找连接，形成<br>天然的去中心化的群体，从前定制发布和规范的产品的力量将被削弱，最后被取代。新的时代来了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在网上买东西，发现不管什么物品，在网站上都有好评和差评，而且有时评论的几乎都是一个特性。例如：同一款路由器，好评里说穿墙能力强，差评里说穿墙能力弱。&lt;br&gt;都振振有词，可能是不同的建筑，使用环境，或不同批次的货品的差异。但是发现个现象，最终还是心里想买哪款，最后就买哪款</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>一场分享中的感悟</title>
    <link href="https://yunpengzhang.github.io/2013/2013-12-12-impression_of_a_sharing/"/>
    <id>https://yunpengzhang.github.io/2013/2013-12-12-impression_of_a_sharing/</id>
    <published>2013-12-11T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>今天听了一次分享，是某游戏公司的老板分享的。通篇内容幽默诙谐，主要是事迹介绍，扯淡居多。但是从中还是学到很多东西。</p><p>##浪潮之巅<br>在端游还不错时选择做页游，在页游不错时选择做手游，最后成功！其中做了一些断臂的事情，有时人越想得到的多，越会失去的多。<br>因为你的精力不集中，注定会错失机会。</p><p>要找到当今的风向和浪潮。不是你擅长什么去做什么，而是时代需要什么去做什么，要做对的事，而不是会的时。都已经过时的东西就不要再耗精力<br>往里面去了，就像浪潮之巅里写的一样，要认准大势，逆流而上的最终结果都很悲惨。</p><p>有时以为自己很牛逼，什么都能干成，但是光有信心还是不够的，更多的还是要认清形式，顺势而上。也不是什么火就去做什么。一旦行业已经被巨头<br>所察觉，形成了几分天下之势，想再得到资源就难了。还是要先评估下，走弥补空白的路线，而不是和强大的对手去硬搏。</p><p>只有新奇的东西，有创新的东西，vc才会投钱，否则出于自己兴趣，还是用自己的钱来创业吧。<br>##情商!情商！情商！！！</p><p>发现改大牛虽然将话风格普通，也没什么妙语连珠，但是让人很爱听。一方面是内容有聊，还有就是情商很高。懂得调动场下情绪，及时互动，就像聊天一样。<br>不禁感慨很多人还是需要练习啊，虽然有的人一辈子也好不了了。但是能忍受住情商低的人的种种低水平行为，也是一种修行和提高。总不能狗朝你叫两声，你就<br>朝他叫两声吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天听了一次分享，是某游戏公司的老板分享的。通篇内容幽默诙谐，主要是事迹介绍，扯淡居多。但是从中还是学到很多东西。&lt;/p&gt;
&lt;p&gt;##浪潮之巅&lt;br&gt;在端游还不错时选择做页游，在页游不错时选择做手游，最后成功！其中做了一些断臂的事情，有时人越想得到的多，越会失去的多。&lt;br</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>几款app的体验报告</title>
    <link href="https://yunpengzhang.github.io/2013/2013-12-11-taste_some_apps/"/>
    <id>https://yunpengzhang.github.io/2013/2013-12-11-taste_some_apps/</id>
    <published>2013-12-10T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>最近几款app使用比较多，觉得还挺有意思的，虽然谈不上深度用户，但是作为一个普通用户，写下我的体验报告，作为纪念。</p><p>##知乎日报<br>知乎刚出来的时候，还是需要邀请才能注册，就弄了个号，之后就一直不登录了。因为上去后发现没什么好看的，一些专业的解答也不是我所<br>感兴趣的。当时觉得和百度知道差不多，应该答案原创性更强，有个性观点，而不是粘贴来粘贴去的。如果你不是有问题去寻找，你会上百度<br>知道吗，当时我上去就是这个感觉。</p><p>但是安装了知乎日报之后，上知乎的频率就高了。每天推送的问题和答案我都会仔细阅读几篇。这是为什么呢？知乎日报，顾名思义，变成了<br>一个日报，成了媒体。每天推送的内容都是经过精心筛选的。都是你看到问题就像知道都八卦，或者习以为常，但是不知道的问题。总之，就是<br>能抓住大多数人兴趣的问题。这就把一个解答的社区变成了推送的媒体，每个答案的回答者都变成了新闻的撰稿人。由于好内容会让用户增加点击<br>使答题者更权威，同时激励答题者的积极性，也能筛选出优秀的答案和答题人，可谓一举多得。有点像天涯社区的推送，用户自己找帖子很难找到<br>所有有意思的内容，还是推荐的作用比较大。</p><p>未来：加强推荐算法和筛选，根据用户喜好提供个性化推荐，从一个人阅读的数据中，可以观察到他的喜好，身份，甚至收入，接下来做什么相信你也<br>知道了吧。知乎还可以作成一个类似豆瓣的推荐和点评平台。因为有人会问xxx好不好，洗碗用那种牌子的洗发水好。。。一个权威人士的回答会让你也<br>想用的，现在已经发现了一些苗头。以后写软文可以在上面一问一答作推销。</p><p>知乎的用户名的资料真实性也很高。因为大多数人在上面回答问题是为了能够展示专业性，认识更多专业的人。宣传自己，即使是昵称，也要是江湖上<br>通用的昵称，所以这也是知乎的优势。</p><p>竞争：百度知道，豆瓣，QQ群……这些也都有着类似的功能。但我觉得百度知道对他的冲击最小。作为一个社区，最主要的还是社交，要让里面的人<br>有关系，起码物以类聚。所以豆瓣竞争大点，QQ群如果能找到方向更大。也许微信的朋友圈或者开放更多的接口后，也会出现颠覆的产品。</p><p>##天天酷跑<br>一款很简单的小游戏，但是真的让我玩了很久。</p><p>游戏介绍</p><p>类似于超级玛丽的小游戏，游戏内的人物要吃金币和躲避障碍。但是新颖的是加入了等级体系和宠物体系等多元素的东西，同事还设计了萌充，应该吸引了<br>很多女性玩家。最致命的是加入了社交关系链排名，使得本来一个单机游戏，在你和你的小伙伴之间变得你争我夺了。不停的玩的理由很简单，我的分数要<br>最高，在朋友里要最高。甚至很多年级大的人也乐此不疲，因为要证明自己不老。</p><p>为什么这么火？我觉得最重要的是加入社交；玩法简单易上手；加入宠物等增强体系，可以增加游戏收入。游戏时间短，符合手游的需要。</p><p>未来：最近又出了新版，加入了一些新的地图和宝贝，还可以通过游戏赚到钻石，增加了任务系统。都是巩固玩家的好方法，玩的人多了，当然人就爱玩了。不过作为月入几亿<br>的游戏，现在也是不能满足的。我觉得后面再加上挑战模式，全世界排行模式，宠物养成等元素，让玩家在多维度，多角度找到玩法就更好了。另外也可以把偷菜这类<br>放上来，吸引一些其他类型的玩家。不过我觉得还是稳住80，90之间的年轻玩家比较重要。可能有更多玩家上来，会有的受到影响而离开。</p><p>##微视<br>无意间安装的一款应用。表面上看就是腾讯微博的变化版。就是每条微博都要有一段8秒的视频，其他和微博一样，可以转发，收藏都和微博一样。</p><p>为什么会火？名人加入，可以把他们的粉丝拉进来，而且经常举办一些名人话题，让名人show下他们的生活，满足粉丝的欲望；旅游，美景，魔术，奇迹等<br>收视率高的视频吸引观众；只有八秒，下载快，看着没负担，比微博的观看要省时间，符合懒人的标准，真实消耗时间的利器。</p><p>未来：没什么可说的，千万不要和微博打通。未来要检查好情色视频的事情，千万不要让情色扰乱了秩序，但是这也是吸引观众的一点：）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近几款app使用比较多，觉得还挺有意思的，虽然谈不上深度用户，但是作为一个普通用户，写下我的体验报告，作为纪念。&lt;/p&gt;
&lt;p&gt;##知乎日报&lt;br&gt;知乎刚出来的时候，还是需要邀请才能注册，就弄了个号，之后就一直不登录了。因为上去后发现没什么好看的，一些专业的解答也不是我所</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>vim插件之vundle</title>
    <link href="https://yunpengzhang.github.io/2013/2013-11-12-vim_plugin_vundle/"/>
    <id>https://yunpengzhang.github.io/2013/2013-11-12-vim_plugin_vundle/</id>
    <published>2013-11-11T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>##前言<br><a href="http://www.yunpengzhang.com/blog/2013/11/10/vim_config_tips/">上一节</a>把vim配置得可以使用了，但是都是从别人那抄过来的，有些东西是什么并不知道,作为一个vim的“老“用户，<br>知其然还要知其所以然。从这节开始，将逐步学习遇到的插件，今天就学习管理插件的插件“vundle”。</p><p>##什么是vundle？<br>回顾最初使用vim的时候，从网上搜到插件的名字，然后下载安装插件到.vim目录。如果好用简直欣喜若狂，为了把插件保存<br>起来，经常会压缩备份，用日期当名字，然后存到邮箱或u盘里。</p><p>但是这样很不方便，依赖的模块太多，没有一个配置文件就能把配置都配好的清爽。一般折腾久了的人都是这个想法。</p><p>vundle是管理vim插件的一个插件。是模仿ruby语言的bundle来实现的。</p><p>有了vundle，您只需要把插件的名字写到vimrc文件中就可以了，运行vundle的命令，就自动联网下载安装。<br>如果删除，更新软件，也不用到vim文件夹中查找删除，直接运行命令就可以了。甚至还可以用插件名字查找插件，选择安装。</p><p>每次重装linux系统时也希望有这样的工具，把所有需要都软件都下载装好。</p><p>##如何安装，使用vundle？</p><p>1.安装git软件。</p><p>2.执行命令安装vundle。<br>    <code>git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</code></p><p>3.配置vimrc文件，记录要安装的插件名字</p><hr><pre><code>set nocompatible               &quot; be iMproved 确保是vim而不是vifiletype off                   &quot; required!   必需set rtp+=~/.vim/vundle.git/   &quot;保留call vundle#rc()              &quot;保留&quot; let Vundle manage VundleBundle &#39;gmarik/vundle&#39;        &quot;vundle安装vundle插件&quot; My Bundles here:             下面都是插件的配置，格式是 Bundle ‘插件名称’&quot;&quot; original repos on githubBundle &#39;tpope/vim-fugitive&#39;Bundle &#39;Lokaltog/vim-easymotion&#39;Bundle &#39;rstacruz/sparkup&#39;, &#123;&#39;rtp&#39;: &#39;vim/&#39;&#125;&quot; vim-scripts reposBundle &#39;L9&#39;Bundle &#39;FuzzyFinder&#39;Bundle &#39;rails.vim&#39;&quot; non github reposBundle &#39;git://git.wincent.com/command-t.git&#39;&quot; git repos on your local machine (ie. when working on your own plugin)Bundle &#39;file:///Users/gmarik/path/to/plugin&#39;&quot; ...filetype plugin indent on     &quot; required!&quot; or &quot; filetype plugin on          &quot; to not use the indentation settings set by plugins</code></pre><hr><p>4.在vim的normal状态下输入命令<br>    <code>:BundleInstall</code></p><p>从github上下载配置的插件。由于网络原因，下载的速度可能比较慢，第一次要耐心等待。而且下载完成后会有提示，可以从log中查看出来。</p><p>更新插件命令<br>    <code>:BundleInstall!</code></p><p>删除插件<br>    <code>:BundleClean</code><br>查找插件<br>   <code>:BundleSearch foo</code></p><p>更多使用vundle都方法可以参考·h vundle·来查看，不过主要是管理插件，平时用的几率不高，上面的这些就够用了。</p><p>##vundle的原理</p><p>vim的脚本都存储在<a href="http://vim-scripts.org/">http://vim-scripts.org/</a>这个网站，从前大家都是到这里下载安装的。<br>最近几年github的兴盛，使得用git来管理插件的版本更加方便。同时通过git来下载插件也成为理所应当的事。<br>在github上，把所有script上的插件都上传到了<a href="https://github.com/vim-scripts">https://github.com/vim-scripts</a>项目中,通过git clone来下载，然后<br>再配合脚本配置，就把插件管理做的很简单了。</p><p>由于vundle的脚本能够很好的描述插件安装这个过程，把一个复杂都问题抽象成为下载，配置两个简单的步骤，使得vundle被越来越多的vimer所使用。</p><p>计算机是机器，只要能用最简洁的方式描述清楚对机器的需求，那么计算机的操作对用户就是友好的。虽然把简洁的语言翻译成执行过程会比较复杂，<br>但是和用户使用简便比起来，都不是问题，而且越能简单描述的东西，越容易理解和维护。</p><p>所以vundle不仅仅是个vim插件，从中也可以领悟一些软件设计，程序设计的方法，甚至服务器程序的发布也可以采用这种方法，配置好发布脚本从中央服务器拉取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##前言&lt;br&gt;&lt;a href=&quot;http://www.yunpengzhang.com/blog/2013/11/10/vim_config_tips/&quot;&gt;上一节&lt;/a&gt;把vim配置得可以使用了，但是都是从别人那抄过来的，有些东西是什么并不知道,作为一个vim的“老“用户</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>github帐号获得ripple币</title>
    <link href="https://yunpengzhang.github.io/2013/2013-11-11-github_users_get_ripple/"/>
    <id>https://yunpengzhang.github.io/2013/2013-11-11-github_users_get_ripple/</id>
    <published>2013-11-10T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上在bbs上看到有人说用github帐号可以赚钱35元，大概看了一眼，不是很明白，没有免费都午餐，就没再搭理。没想到今天在公司都bbs上也发现有人<br>在收，转给他就可以给35元。午休没事，就搜了一下。原来是ripple给github开发者都福利，具体可点击<a href="https://ripple.com/blog/git-in-the-game-2020-xrp-giveaway-for-github-users/">https://ripple.com/blog/git-in-the-game-2020-xrp-giveaway-for-github-users/</a>。<br>由于ripple是虚拟货币，可以换成人民币或美元，着2k多大概折合人民币100元左右。</p><p>也不是有github帐号就能换的，有要求。</p><blockquote><p>Who Qualifies?</p><p>We’re giving away 2,020 XRP (as a tribute to tomorrow’s Ripple Developer Conference at Money2020) to GitHub account holders who have at least one public code-writing activity before May 1, 2013, 00:00:00 UTC.</p><p>Accounts that have watched or starred the ripple-client, ripple-lib, or rippled repositories as of October 3, 2013, 21:15:00 UTC are eligible for 4,040 XRP.</p><p>Please note that these rules are subject to change without notice.</p></blockquote><p>在2013年5月1日前注册，且提交过公开代码的有资格，二者缺一不可。我的一个同事是11年注册的，但是没提交过代码，也领不成。<br>领取都方法还是比较简单的，大概十分钟就完成了，具体可以参考上面都链接。如果读不懂英文，已经有好心的人给了教程。<a href="http://biaobiaoqi.me/blog/2013/10/28/get-ripple-from-github-account/">用Github账号领Ripple币</a>。注册提现的方法都有。</p><p>不禁觉得，这个世界上，很多财富的获得是通过信息不对称都投机来实现的，无孔不入。这种倒卖的行为也没什么谴责他的，只能说“世界上没有免费都午餐“。<br>人还是不要太懒，动动鼠标，就会挖掘的更多。很多时候还是要有种弄清事情本质的精神，要懂得越多，才能被骗的机会越少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上在bbs上看到有人说用github帐号可以赚钱35元，大概看了一眼，不是很明白，没有免费都午餐，就没再搭理。没想到今天在公司都bbs上也发现有人&lt;br&gt;在收，转给他就可以给35元。午休没事，就搜了一下。原来是ripple给github开发者都福利，具体可点击&lt;a h</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>vim的IDE配置和vim tips</title>
    <link href="https://yunpengzhang.github.io/2019/2013-11-10-vim_config_tips/"/>
    <id>https://yunpengzhang.github.io/2019/2013-11-10-vim_config_tips/</id>
    <published>2013-11-09T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>用vim时间也很久了，但是发现最初从网上cp了一份vimrc和插件后就没怎么大修改过，而且每次备份都是一堆的插件，删除都不知道怎么删。<br>最近知道了有vundle这个插件，重新配置了一下vim，发现vim有了足够都vimrc和插件后，功能大幅增长。自己平时也爱折腾，立下此文，以后都修改都列到这里。</p><h2 id="VIM-配置"><a href="#VIM-配置" class="headerlink" title="VIM 配置"></a>VIM 配置</h2><p>把从前的配置移植过来，用vundle配置了vimrc文件，见最后都附。</p><h2 id="VIM-tips"><a href="#VIM-tips" class="headerlink" title="VIM tips"></a>VIM tips</h2><h3 id="vim补全时发现候选菜单的上下选择ctrl-p-ctrl-n相反"><a href="#vim补全时发现候选菜单的上下选择ctrl-p-ctrl-n相反" class="headerlink" title="vim补全时发现候选菜单的上下选择ctrl-p, ctrl-n相反"></a>vim补全时发现候选菜单的上下选择ctrl-p, ctrl-n相反</h3><p>原因:使用<code>verbose imap &lt;c-n&gt;</code> 查看是由于什么设置所致，发现是supertab插件导致，删除解决。</p><pre><code>#include&lt;iostream&gt;int main</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/fbfsber008/article/details/7055842">把vim打造成IDE</a></p><h3 id="附：vimrc文件"><a href="#附：vimrc文件" class="headerlink" title="附：vimrc文件"></a>附：vimrc文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line">&quot; For vundle</span><br><span class="line">set nocompatible               &quot; be iMproved</span><br><span class="line">filetype off                   &quot; required!</span><br><span class="line"></span><br><span class="line">set rtp+=~/.vim/bundle/vundle/</span><br><span class="line">call vundle#rc()</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle</span><br><span class="line">&quot; required! </span><br><span class="line">Bundle &#x27;gmarik/vundle&#x27;</span><br><span class="line"></span><br><span class="line">&quot; original repos on github</span><br><span class="line">&quot;Bundle &#x27;mattn/zencoding-vim&#x27;</span><br><span class="line">Bundle &#x27;drmingdrmer/xptemplate&#x27;</span><br><span class="line"></span><br><span class="line">&quot; vim-scripts repos</span><br><span class="line">Bundle &#x27;EnhCommentify.vim&#x27;</span><br><span class="line">Bundle &#x27;a.vim&#x27;</span><br><span class="line">Bundle &#x27;omnicppcomplete.vim&#x27;</span><br><span class="line">Bundle &#x27;DoxygenToolkit.vim&#x27;</span><br><span class="line">Bundle &#x27;minibufexpl.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;NERD_commenter.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;The-NERD-Commenter&#x27;</span><br><span class="line">Bundle &#x27;bufexplorer.zip&#x27;</span><br><span class="line">Bundle &#x27;taglist.vim&#x27;</span><br><span class="line">Bundle &#x27;The-NERD-tree&#x27;</span><br><span class="line">Bundle &#x27;taglist.vim&#x27;</span><br><span class="line">Bundle &#x27;winmanager&#x27;</span><br><span class="line">&quot;Bundle &#x27;SuperTab&#x27;</span><br><span class="line">Bundle &#x27;minibufexpl.vim&#x27;</span><br><span class="line">Bundle &#x27;Markdown&#x27;</span><br><span class="line">Bundle &#x27;c.vim&#x27;</span><br><span class="line">Bundle &#x27;snipMate&#x27;</span><br><span class="line">Bundle &#x27;bash-support.vim&#x27;</span><br><span class="line">Bundle &#x27;perl-support.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot;Bundle &#x27;Lokaltog/vim-powerline&#x27;</span><br><span class="line">&quot;Bundle &#x27;L9&#x27;</span><br><span class="line">&quot;Bundle &#x27;FuzzyFinder&#x27;</span><br><span class="line">&quot;Bundle &#x27;Mark&#x27;</span><br><span class="line">&quot;Bundle &#x27;matrix.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;closetag.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;matchit.zip&#x27;</span><br><span class="line">&quot;Bundle &#x27;AutoComplPop&#x27;</span><br><span class="line">&quot;Bundle &#x27;jsbeautify&#x27;</span><br><span class="line">&quot;Bundle &#x27;YankRing.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;vimwiki&#x27;</span><br><span class="line">&quot;Bundle &#x27;matrix.vim--Yang&#x27;</span><br><span class="line">&quot;Bundle &#x27;FencView.vim&#x27;</span><br><span class="line">&quot;Bundle &#x27;Conque-Shell&#x27;</span><br><span class="line"></span><br><span class="line">&quot; non github reposo</span><br><span class="line">&quot; 非github的插件，可以直接使用其git地址</span><br><span class="line">&quot; Bundle &#x27;git://git.wincent.com/command-t.git&#x27;</span><br><span class="line">&quot; ...</span><br><span class="line"></span><br><span class="line">&quot;Bundle 支持的格式有三种：</span><br><span class="line">&quot;第一种是一个普通的字符串，就是 vim 插件页面里左上角的插件名字，如果插件名有空格，使用 - 替换。</span><br><span class="line">&quot;第二种是github帐号/项目名。</span><br><span class="line">&quot;第三种就是git repository</span><br><span class="line">&quot;现在大家就可以使用 :BundleInstall ，:BundleInstall!  来下载插件和更新插件了，是不是很方便。</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :BundleList          - list configured bundles</span><br><span class="line">&quot; :BundleInstall(!)    - install(update) bundles</span><br><span class="line">&quot; :BundleSearch(!) foo - search(or refresh cache first) for foo</span><br><span class="line">&quot; :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles</span><br><span class="line">&quot; vundle主要就是上面这个四个命令，例如BundleInstall是全部重新安装，BundleInstall!则是更新</span><br><span class="line">&quot; 一般安装插件的流程为，先BundleSearch一个插件，然后在列表中选中，按i安装</span><br><span class="line">&quot; 安装完之后，在vimrc中，添加Bundle &#x27;XXX&#x27;，使得bundle能够加载，这个插件，同时如果</span><br><span class="line">&quot; 需要配置这个插件，也是在vimrc中设置即可</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; NOTE: comments after Bundle command are not allowed..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syn on                      &quot;语法支持</span><br><span class="line">&quot;common conf &#123;&#123;             通用配置</span><br><span class="line">set ai                      &quot;自动缩进</span><br><span class="line">set bs=2                    &quot;在insert模式下用退格键删除</span><br><span class="line">set showmatch               &quot;代码匹配</span><br><span class="line">set laststatus=2            &quot;总是显示状态行</span><br><span class="line">set expandtab               &quot;以下三个配置配合使用，设置tab和缩进空格数</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set tabstop=4</span><br><span class="line">set cursorline              &quot;为光标所在行加下划线</span><br><span class="line">set number                  &quot;显示行号</span><br><span class="line">set autoread                &quot;文件在Vim之外修改过，自动重新读入</span><br><span class="line">set ignorecase              &quot;检索时忽略大小写</span><br><span class="line">set hls                     &quot;检索时高亮显示匹配项</span><br><span class="line">set helplang=cn             &quot;帮助系统设置为中文</span><br><span class="line">&quot;set foldmethod=syntax       &quot;代码折叠</span><br><span class="line">&quot;检测文件类型，对于依赖文件类型功能有用</span><br><span class="line">set history=1000</span><br><span class="line">set vb t_vb= </span><br><span class="line">&quot;set nohls </span><br><span class="line">set mouse=a </span><br><span class="line">set cindent </span><br><span class="line">set incsearch </span><br><span class="line">set cursorline</span><br><span class="line">set nobackup &quot; make backup file</span><br><span class="line">set autowrite &quot; auto writefile when sth happened such as :make or :last or others.See the help</span><br><span class="line">set makeef=error.err &quot; When using make, where should it dump the file</span><br><span class="line">set wildmenu &quot; turn on wild menu</span><br><span class="line">set ruler &quot; Always show current positions along the bottom</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">set so=7 &quot;距下面的行数为7</span><br><span class="line">colorscheme desert</span><br><span class="line">set tabstop=4 &quot; tab spacing (settings below are just to unify it)</span><br><span class="line">set softtabstop=4 &quot; unify</span><br><span class="line">set shiftwidth=4 &quot; unify</span><br><span class="line">set nowrap &quot; do not wrap lines</span><br><span class="line">set smarttab &quot; use tabs at the start of a line, spaces elsewhere</span><br><span class="line">&quot;解决乱码</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set fileencodings=ucs-bom,utf-8,gb18030,big5,gbk,gb2312,cp936</span><br><span class="line">set viminfo+=! &quot; make sure it can save viminfo</span><br><span class="line">set isk+=_,$,@,%,#,- &quot; none of these should be word dividers, so make them not be</span><br><span class="line">&quot;keep the last close cursor position</span><br><span class="line">if has(&quot;autocmd&quot;)</span><br><span class="line">autocmd BufReadPost *</span><br><span class="line">\ if line(&quot;&#x27;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&#x27;\&quot;&quot;) &lt;= line(&quot;$&quot;) |</span><br><span class="line">\   exe &quot;normal g`\&quot;&quot; |</span><br><span class="line">\ endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&quot;conf for tabs, 为标签页进行的配置，通过ctrl h/l切换标签等</span><br><span class="line">&quot;let mapleader = &#x27;,&#x27;</span><br><span class="line">nnoremap <span class="tag">&lt;<span class="name">C-l</span>&gt;</span> gt</span><br><span class="line">nnoremap <span class="tag">&lt;<span class="name">C-h</span>&gt;</span> gT</span><br><span class="line">nnoremap <span class="tag">&lt;<span class="name">leader</span>&gt;</span>t : tabe<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&quot;conf for plugins &#123;&#123; 插件相关的配置</span><br><span class="line">&quot;&quot;进行Tlist的设置</span><br><span class="line">&quot;&quot;&quot;TlistUpdate可以更新tags</span><br><span class="line">&quot;map <span class="tag">&lt;<span class="name">F3</span>&gt;</span> :silent! Tlist<span class="tag">&lt;<span class="name">CR</span>&gt;</span> &quot;按下F3就可以呼出了</span><br><span class="line">&quot;let Tlist_Ctags_Cmd=&#x27;ctags&#x27; &quot;因为我们放在环境变量里，所以可以直接执行</span><br><span class="line">&quot;let Tlist_Use_Right_Window=1 &quot;让窗口显示在右边，0的话就是显示在左边</span><br><span class="line">let Tlist_Show_One_File=1 &quot;让taglist可以同时展示多个文件的函数列表，如果想只有1个，设置为1</span><br><span class="line">&quot;let Tlist_File_Fold_Auto_Close=1 &quot;非当前文件，函数列表折叠隐藏</span><br><span class="line">let Tlist_Exit_OnlyWindow=1 &quot;当taglist是最后一个分割窗口时，自动推出vim</span><br><span class="line">&quot;&quot;是否一直处理tags.1:处理;0:不处理</span><br><span class="line">&quot;&quot;let Tlist_Process_File_Always=0 &quot;不是一直实时更新tags，因为没有必要</span><br><span class="line">&quot;&quot;let Tlist_Inc_Winwidth=0</span><br><span class="line">map <span class="tag">&lt;<span class="name">F3</span>&gt;</span> :silent! Tlist<span class="tag">&lt;<span class="name">CR</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">let g:winManagerWindowLayout=&#x27;TagList|FileExplorer&#x27;</span><br><span class="line">nmap wm :WMToggle<span class="tag">&lt;<span class="name">cr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line"></span><br><span class="line">&quot;xptemplate</span><br><span class="line">let g:xptemplate_brace_complete=0</span><br><span class="line">let g:xptemplate_key = &#x27;<span class="tag">&lt;<span class="name">Tab</span>&gt;</span>&#x27;</span><br><span class="line">let g:xptemplate_nav_prev = &#x27;<span class="tag">&lt;<span class="name">C-k</span>&gt;</span>&#x27;</span><br><span class="line"></span><br><span class="line">&quot; -- MiniBufferExplorer -- &quot;</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1</span><br><span class="line">let g:miniBufExplModSelTarget = 1 </span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1 &quot;&lt;C-h,j,k,l&gt;</span><br><span class="line">&quot;DoxygenToolkit</span><br><span class="line">map fg : Dox<span class="tag">&lt;<span class="name">cr</span>&gt;</span></span><br><span class="line">let g:DoxygenToolkit_authorName=&quot;owenzhang, owenzhang2010@qq.com&quot;</span><br><span class="line">let s:licenseTag = &quot;Tencent.Co.Ltd\<span class="tag">&lt;<span class="name">enter</span>&gt;</span>&quot;</span><br><span class="line">let s:licenseTag = s:licenseTag . &quot;All right reserved\<span class="tag">&lt;<span class="name">enter</span>&gt;</span>&quot;</span><br><span class="line">let g:DoxygenToolkit_licenseTag = s:licenseTag</span><br><span class="line">let g:DoxygenToolkit_briefTag_funcName=&quot;yes&quot;</span><br><span class="line">let g:doxygen_enhanced_color=1</span><br><span class="line"></span><br><span class="line">&quot; --- OmniCppComplete ---</span><br><span class="line"></span><br><span class="line">&quot;set completeopt=menu</span><br><span class="line">&quot; -- ctags --</span><br><span class="line">&quot;  &quot; map <span class="tag">&lt;<span class="name">ctrl</span>&gt;</span>+F12 to generate ctags for current folder:</span><br><span class="line">&quot;  map <span class="tag">&lt;<span class="name">C-F12</span>&gt;</span> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;map <span class="tag">&lt;<span class="name">F12</span>&gt;</span> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q . ~/code/commlib32_proj/trunk/baselib/<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;  &quot; add current directory&#x27;s generated tags file to available tags</span><br><span class="line">&quot;set tags+=./tags</span><br><span class="line">&quot;map <span class="tag">&lt;<span class="name">F12</span>&gt;</span> :!ctags -R *<span class="tag">&lt;<span class="name">CR</span>&gt;</span> </span><br><span class="line">&quot;map <span class="tag">&lt;<span class="name">F12</span>&gt;</span> :!ctags -R . ~/code/commlib32_proj/trunk/baselib/ <span class="tag">&lt;<span class="name">CR</span>&gt;</span> </span><br><span class="line">&quot;nnoremap ,t :sil !find -maxdepth 1 -name &#x27;*.[ch]&#x27; -print0 -o</span><br><span class="line">&quot;         \ -name &#x27;*.cpp&#x27; -print0 \| xargs -0 ctags --c++-kinds=+p --fields=+iaS --extra=+q <span class="tag">&lt;<span class="name">cr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">set cscopequickfix=s-,c-,d-,i-,t-,e-</span><br><span class="line">if(has(&quot;win32&quot;) || has(&quot;win95&quot;) || has(&quot;win64&quot;) || has(&quot;win16&quot;))</span><br><span class="line">    let g:iswindows=1</span><br><span class="line">else</span><br><span class="line">    let g:iswindows=0</span><br><span class="line">endif</span><br><span class="line">autocmd BufEnter * lcd %:p:h </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map <span class="tag">&lt;<span class="name">F12</span>&gt;</span> :call Do_CsTag()<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>s :cs find s <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>g :cs find g <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>c :cs find c <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>t :cs find t <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>e :cs find e <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>f :cs find f <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cfile</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>i :cs find i ^<span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cfile</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span>$<span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>i :cs find i <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cfile</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">nmap <span class="tag">&lt;<span class="name">C-_</span>&gt;</span>d :cs find d <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span>:copen<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">function Do_CsTag()</span><br><span class="line">    let dir = getcwd()</span><br><span class="line">    if filereadable(&quot;tags&quot;)</span><br><span class="line">        if(g:iswindows==1)</span><br><span class="line">            let tagsdeleted=delete(dir.&quot;\\&quot;.&quot;tags&quot;)</span><br><span class="line">        else</span><br><span class="line">            let tagsdeleted=delete(&quot;./&quot;.&quot;tags&quot;)</span><br><span class="line">        endif</span><br><span class="line">        if(tagsdeleted!=0)</span><br><span class="line">            echohl WarningMsg | echo &quot;Fail to do tags! I cannot delete the tags&quot; | echohl None</span><br><span class="line">            return</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">    if has(&quot;cscope&quot;)</span><br><span class="line">        silent! execute &quot;cs kill -1&quot;</span><br><span class="line">    endif</span><br><span class="line">    if filereadable(&quot;cscope.files&quot;)</span><br><span class="line">        if(g:iswindows==1)</span><br><span class="line">            let csfilesdeleted=delete(dir.&quot;\\&quot;.&quot;cscope.files&quot;)</span><br><span class="line">        else</span><br><span class="line">            let csfilesdeleted=delete(&quot;./&quot;.&quot;cscope.files&quot;)</span><br><span class="line">        endif</span><br><span class="line">        if(csfilesdeleted!=0)</span><br><span class="line">            echohl WarningMsg | echo &quot;Fail to do cscope! I cannot delete the cscope.files&quot; | echohl None</span><br><span class="line">            return</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">    if filereadable(&quot;cscope.out&quot;)</span><br><span class="line">        if(g:iswindows==1)</span><br><span class="line">            let csoutdeleted=delete(dir.&quot;\\&quot;.&quot;cscope.out&quot;)</span><br><span class="line">        else</span><br><span class="line">            let csoutdeleted=delete(&quot;./&quot;.&quot;cscope.out&quot;)</span><br><span class="line">        endif</span><br><span class="line">        if(csoutdeleted!=0)</span><br><span class="line">            echohl WarningMsg | echo &quot;Fail to do cscope! I cannot delete the cscope.out&quot; | echohl None</span><br><span class="line">            return</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">    if(executable(&#x27;ctags&#x27;))</span><br><span class="line">        &quot;silent! execute &quot;!ctags -R --c-types=+p --fields=+S *&quot;</span><br><span class="line">        silent! execute &quot;!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&quot;</span><br><span class="line">    endif</span><br><span class="line">    if(executable(&#x27;cscope&#x27;) &amp;&amp; has(&quot;cscope&quot;) )</span><br><span class="line">        if(g:iswindows!=1)</span><br><span class="line">            silent! execute &quot;!find . -name &#x27;*.h&#x27; -o -name &#x27;*.c&#x27; -o -name &#x27;*.cpp&#x27; -o -name &#x27;*.java&#x27; -o -name &#x27;*.cs&#x27; &gt; cscope.files&quot;</span><br><span class="line">        else</span><br><span class="line">            silent! execute &quot;!dir /s/b *.c,*.cpp,*.h,*.java,*.cs &gt;&gt; cscope.files&quot;</span><br><span class="line">        endif</span><br><span class="line">        silent! execute &quot;!cscope -b&quot;</span><br><span class="line">        execute &quot;normal :&quot;</span><br><span class="line">        if filereadable(&quot;cscope.out&quot;)</span><br><span class="line">            execute &quot;cs add cscope.out&quot;</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunction </span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; cscope setting</span><br><span class="line">&quot; &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot;if has(&quot;cscope&quot;)</span><br><span class="line">&quot;    set csprg=/usr/bin/cscope</span><br><span class="line">&quot;    set csto=1</span><br><span class="line">&quot;    set cst</span><br><span class="line">&quot;    set nocsverb</span><br><span class="line">&quot;&quot;     add any database in current directory</span><br><span class="line">&quot;    if filereadable(&quot;cscope.out&quot;)</span><br><span class="line">&quot;        cs add cscope.out</span><br><span class="line">&quot;    endif</span><br><span class="line">&quot;    set csverb</span><br><span class="line">&quot;endif</span><br><span class="line"></span><br><span class="line">&quot;nmap &lt;C-@&gt;s :cs find s <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;g :cs find g <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;c :cs find c <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;t :cs find t <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;e :cs find e <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;f :cs find f <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cfile</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;i :cs find i ^<span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cfile</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span>$<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">&quot;nmap &lt;C-@&gt;d :cs find d <span class="tag">&lt;<span class="name">C-R</span>&gt;</span>=expand(&quot;<span class="tag">&lt;<span class="name">cword</span>&gt;</span>&quot;)<span class="tag">&lt;<span class="name">CR</span>&gt;</span><span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;if filereadable(&quot;feed.vim&quot;)</span><br><span class="line">&quot;    source feed.vim</span><br><span class="line">&quot;endif</span><br><span class="line">&quot;set tags+=/data/home/owenzhang/feedcenter_proj/trunk/tags,/data/home/owenzhang/code/commlib32_proj/trunk/tags</span><br><span class="line"></span><br><span class="line">&quot;:cs add /data/home/owenzhang/feedcenter_proj/trunk/cscope.out /data/home/owenzhang/feedcenter_proj/trunk/</span><br><span class="line"></span><br><span class="line">&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">func! CompileGcc()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">let compilecmd=&quot;!gcc &quot;</span><br><span class="line">let compileflag=&quot;-o %&lt; &quot;</span><br><span class="line">if search(&quot;mpi\.h&quot;) != 0</span><br><span class="line">let compilecmd = &quot;!mpicc &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;glut\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lglut -lGLU -lGL &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;cv\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lcv -lhighgui -lcvaux &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;omp\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -fopenmp &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;math\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lm &quot;</span><br><span class="line">endif</span><br><span class="line">exec compilecmd.&quot; % &quot;.compileflag</span><br><span class="line">endfunc</span><br><span class="line">func! CompileGpp()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">let compilecmd=&quot;!g++ &quot;</span><br><span class="line">let compileflag=&quot;-o %&lt; &quot;</span><br><span class="line">if search(&quot;mpi\.h&quot;) != 0</span><br><span class="line">let compilecmd = &quot;!mpic++ &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;glut\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lglut -lGLU -lGL &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;cv\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lcv -lhighgui -lcvaux &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;omp\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -fopenmp &quot;</span><br><span class="line">endif</span><br><span class="line">if search(&quot;math\.h&quot;) != 0</span><br><span class="line">let compileflag .= &quot; -lm &quot;</span><br><span class="line">endif</span><br><span class="line">exec compilecmd.&quot; % &quot;.compileflag</span><br><span class="line">endfunc</span><br><span class="line">func! CompileCode()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">if &amp;filetype == &quot;cpp&quot;</span><br><span class="line">exec &quot;call CompileGpp()&quot; elseif &amp;filetype == &quot;c&quot;</span><br><span class="line">exec &quot;call CompileGcc()&quot;</span><br><span class="line">endif</span><br><span class="line">endfunc</span><br><span class="line">func! RunResult()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">if search(&quot;mpi\.h&quot;) != 0</span><br><span class="line">exec &quot;!mpirun -np 4 ./%&lt;&quot;</span><br><span class="line">elseif &amp;filetype == &quot;cpp&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">elseif &amp;filetype == &quot;c&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">elseif &amp;filetype == &quot;python&quot;</span><br><span class="line">exec &quot;call RunPython&quot;</span><br><span class="line">elseif &amp;filetype == &quot;java&quot;</span><br><span class="line">exec &quot;!java %&lt;&quot;</span><br><span class="line">endif</span><br><span class="line">endfunc</span><br><span class="line">map <span class="tag">&lt;<span class="name">F5</span>&gt;</span> :call CompileCode()<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">imap <span class="tag">&lt;<span class="name">F5</span>&gt;</span> <span class="tag">&lt;<span class="name">ESC</span>&gt;</span>:call CompileCode()<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">vmap <span class="tag">&lt;<span class="name">F5</span>&gt;</span> <span class="tag">&lt;<span class="name">ESC</span>&gt;</span>:call CompileCode()<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line">map <span class="tag">&lt;<span class="name">F6</span>&gt;</span> :call RunResult()<span class="tag">&lt;<span class="name">CR</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function! s:insert_gates()</span><br><span class="line">  let gatename = substitute(toupper(expand(&quot;%:t&quot;)), &quot;\\.&quot;, &quot;_&quot;, &quot;g&quot;)</span><br><span class="line">  execute &quot;normal! i#ifndef &quot; . gatename</span><br><span class="line">  execute &quot;normal! o#define &quot; . gatename . &quot; &quot;</span><br><span class="line">  execute &quot;normal! Go#endif /* &quot; . gatename . &quot; */&quot;</span><br><span class="line">  normal! kk</span><br><span class="line">endfunction</span><br><span class="line">autocmd BufNewFile *.&#123;h,hpp&#125; call <span class="tag">&lt;<span class="name">SID</span>&gt;</span>insert_gates()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;用vim时间也很久了，但是发现最初从网上cp了一份vimrc和插件后就没怎么大修改过，而且每次备份都是一堆的插件，删除都不知</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读心得</title>
    <link href="https://yunpengzhang.github.io/2017/2013-11-03-reading/"/>
    <id>https://yunpengzhang.github.io/2017/2013-11-03-reading/</id>
    <published>2013-11-02T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>最近闲暇的时间用阅读取代了视频、微博，调一两本好书，占据了整个的课余时间。虽然目前读的不多，但是感觉阅读真是个美妙的东西，恨自己没有在早年间养成这个习惯，希望现在抓紧机会，多读书读好书。</p><p>相比微博和影视，阅读以下几种好处。</p><p>书籍是完整的，有着缜密的构思和结构。</p><p>通过对书籍的阅读，理清里面的脉络，可以完整地了解一段故事，解读出自己的理解。相比微博，内容更丰富，更有理有据，更能通过深层的道理得以启发。微博更像是新闻媒体，只是知道有个新鲜事，然后就过去了。但书籍经过多年的沉淀和大家的筛选，都是货真价实的，从中可以借鉴做事方法，了解时代背景。对事物有深层次的认识。</p><p>书籍可以反复咀嚼，挖掘出深层含义。但是影视更多地是快，可能你没有体会到，就播过去了，后面也不会重看。另外为了票房和吸引观众，把故事修改的和原著已经面目全非了。</p><p>为什么要读书呢？</p><p>读书可以让心情平静，阅读的时候沉浸其中，仿佛到了另外一个世界，和作者隔着时间空间在对话。克服内心的孤独。</p><p>读书了解的更多，说话更有理有据。通过阅读，去伪存真，建立自己的知识体系。讲道理、评判事务的时候，自然而然地套到一些理论知识之中，而不是“我认为”或者从网络、微博之中寻找那些主观和自己观点相同，但没有出处的文字。但是，尽信书不如无书。要用辩证的观点，书也不都是对的，这就要求要多阅读，并且养成独立思考的能力。每每阅读完一本书，要问下自己，这本书讲的什么，作者着重要传达什么，他说的有道理吗，这对我有什么关系呢？</p><p>读完后有读书笔记，有沉淀，可以给下次复读的时候提供材料，另外也可以给没读过数的人以介绍。</p><p>如何选择图书呢？</p><p>你需要什么样的书就选择什么书。现在还有豆瓣这类网站，每一本书，在上面都有大家的书评，不会让读完后大喊坑爹。很多优秀的读者，写的书评也很有深度，读后也会另有启发，知道自己的差距。</p><p>如何阅读？</p><p>我觉得纸质书很长时间不会淘汰，那种阅读的感觉，是现代的电子产品所不能替代的。因为从小养成的阅读习惯已经认定纸才是书。所以最好的阅读体验还是有个独立的桌子，放上纸质的书一页一页的翻看。发现需要记笔记的地方直接用笔在书边上标注。</p><p>不是什么书都有纸版的，更多还是看电子书。由于工作已经对着电脑很久了，更多时间是看手机。我比较推荐 ·静读天下· 这个app，苹果系统好像没有，无论翻页、统计、格式支持、用户体验，还没有找到一个比它好的。目前来说对我够用了。还有kindle听说也不错，不过没体验过。主要是书的内容，剩下的都是工具，是辅助的。</p><p>阅读是让人进步的阶梯，活到老，学到老，希望可以把这个习惯坚持下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近闲暇的时间用阅读取代了视频、微博，调一两本好书，占据了整个的课余时间。虽然目前读的不多，但是感觉阅读真是个美妙的东西，恨自己没有在早年间养成这个习惯，希望现在抓紧机会，多读书读好书。&lt;/p&gt;
&lt;p&gt;相比微博和影视，阅读以下几种好处。&lt;/p&gt;
&lt;p&gt;书籍是完整的，有着缜密</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>谈一谈代码重构</title>
    <link href="https://yunpengzhang.github.io/2013/2013-10-27-code_refactoring/"/>
    <id>https://yunpengzhang.github.io/2013/2013-10-27-code_refactoring/</id>
    <published>2013-10-26T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>上周进行小组分享的时候讲的代码重构，从《代码大全》《clean code》《重构》三本书中摘抄了一些观点，结合日常开发的例子讲解了以下。发现重构不像工具学习，听了一节课马上就有效果，能解决一个问题，更多的还是要培养一种意识。在开发代码的时候不引入错误不健康的习惯，在维护代码的时候能够收住有味道的代码，不让项目变得更糟。</p><p>当然，做这种事不会有直接利益，不像查找个内存泄漏更容易让人佩服。但是好的编码习惯是自己终身的财富，就像一个彬彬有礼的人，平时可能会“吃亏”，但是最终会受益的。</p><p>##不要抱怨</p><blockquote><p>这段代码真烂！</p></blockquote><p>通常新维护别人的代码时都会发出感慨，然后加500字的嘲笑，或者和其他人讲述那个模块如何地令人恶心……<br>可是有用吗，代码还是那样，依旧在那里，该脏还是脏。</p><p>更好的方式应该是想“如何优化这段代码”，或者和另外一个小伙伴商量医治这段代码的手段。解决问题才是真，不要抱怨。<br>##什么是重构<br>重构不是重写！</p><p>重构还是要保持代码最开始的框架和功能，对外来说，黑盒的接口没有变化。对内来说，框架还是最初的框架。目的还是让代码更容易维护。</p><p>不要把重构当作重写的接口，不要在刚写软件的时候就想以后会重构。修改软件的最好时机就是在他被初创的时候，一旦对外发布，在想改变，就要测试、评估，代价越往后越高。而且“do it later &#x3D; do it never”<br>##重构的优先级<br>从简单到复杂。先修改简单的，对主逻辑影响小或干脆没影响的，测试压力会小一些；然后修改逻辑重的部分，最后再修改核心算法。一次只修改一个地方，方便观察和回溯。<br>##重构的理由</p><ul><li>代码重复</li><li>代码冗长</li><li>参数太多</li><li>使用全局变量</li><li>过渡设计</li><li>……</li></ul><p>见过最多的就是代码重复，冗长。一个文件上万行，代码逻辑比较简单，增加逻辑就添加个if分支，表面上是省事了，但是给扩展性增加了困难。</p><p>总之就是代码有味道。发现可以精简，做得更好的地方，在修复bug，增加子程序时顺手给处理掉。“让营地比来的时候更干净”。<br>##具体的重构方法</p><ul><li>用具名常量代替魔数。</li><li>将一组类型码转换为类或枚举</li></ul><p>经常见到的就是返回值，都是用return 1，2。第一个人写的时候知道意思，后面的人写的时候就不知道了，然后自己往上填，造成返回值冲突，判断错误。最好的是有一个枚举类型的返回值，返回的时候开发也不能随意填写，要按照枚举的类型进行返回。</p><ul><li>使用break和return而不是循环控制变量</li><li>将条件语句中不同部分中的重复代码合并</li><li>在嵌套的if语句中一旦知道结果就马上退出</li></ul><p>可以防止后面增加其他的分支或修改时，无意间破坏原有的返回值逻辑，造成返回值被意外篡改，而且对于阅读代码的人，可以很清晰的知道到这就结束了，而不用再跳来跳去，检查是否还有别的东西。</p><ul><li>去掉不用的参数</li><li>增加参数，而不是一个struct把参数都包括了</li><li>合并功能相似的子程序，用参数区分</li></ul><p>曾经也很纠结，到底如何处理类似的程序，用参数还是不同的函数名。用参数更有扩展性，而且新增功能时可以方便的进行测试。用老的测试例子就可以完成。</p><p>某些参数不用了，最好去掉，否则会干扰调用。一个不用的东西摆在那里，总会有人去想看看到底有没有用，浪费时间。</p><p>经常遇到的情况是在一个程序里有个CONFIG类参数，里面包括了要用的大部分参数。后面想把这个函数用到另外一个程序里，发现很难移植，因为要编写一个相同的类，类的成员名字也要相同，真是类死个人。最好的方法是尽量用基本的数据类型，如果类需要调用，那么把类成员展开调用就可以了。</p><p>我觉得，让代码好维护，就是尽量复用，不要重复。让各个逻辑模块间逻辑清晰，减少耦合。维护的时候才能只关心修改部分，不会节外生枝。</p><p>##安全地重构<br>留好后路，有svn、git等版本控制工具。步伐尽量小，有检测代码重构后是否逻辑有影响的监控机制。更多地测试和监控。</p><p>##总结</p><p>有些人觉得做了这些也没人看得到，而且还很麻烦，很多人也都不这么做。有句话“佛会知道”，多行善会有善报的，出来混迟早是要还的。再说了，大家都不这么做，而你这么做，不是很有优势吗？！</p><p>##补充<br>2013-11-11<br>上个星期主要工作是在重写一个模块，虽然我们都叫重构。由于从前都是采用同步方式进行写操作，效率不高。这次打算都作成异步的。<br>开始以为会很简单，但是工期大大超期。原因如下：</p><ol><li>从前逻辑太过于复杂，函数封装不好，重用性差。</li><li>边写代码边了解逻辑，没有文档。</li><li>迁移都协议都比较重要，但是并不是性能瓶颈，访问量不大，但迁移的风险比较大。</li></ol><p>如果时间允许的情况下，我觉得应该这样做。</p><ol><li>先在老代码上修改，封装集成函数。让开发充分了解代码逻辑，把函数抽象。</li><li>持续发布，利用老框架测试新代码。</li><li>如果没有达到瓶颈就不迁移到异步命令，保持代码整洁封装性强即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上周进行小组分享的时候讲的代码重构，从《代码大全》《clean code》《重构》三本书中摘抄了一些观点，结合日常开发的例子讲解了以下。发现重构不像工具学习，听了一节课马上就有效果，能解决一个问题，更多的还是要培养一种意识。在开发代码的时候不引入错误不健康的习惯，在维护代码</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一些想法</title>
    <link href="https://yunpengzhang.github.io/2013/2013-10-22-some_ideas/"/>
    <id>https://yunpengzhang.github.io/2013/2013-10-22-some_ideas/</id>
    <published>2013-10-21T16:00:00.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>自从上次把博客迁移后，本来想多些写东西的，不过都没写出来就又断了两周。写博客还是不能停<br>要坚持下来才可以。发现最近也没什么成块的成果写出来，写一些最近零星的想法，记录下来给自己查看。<br>##博客方面<br>使用jekyll发现还是比较好用的，专心地使用喜欢的编辑器写东西，源数据保存下来就好，其他都样式都是<br>周边的，可再造的。这也是我刚刚才领悟的。</p><p>如果你都硬盘坏了，觉得什么丢了最可惜？是自己拍都照片，还是下载收藏都电影，电子书。肯定是前者，相对来说<br>他是独一无二的。丢了就再也找不回来了。文章也是一样，虽然不是什么值钱都东西，但是记录了一段时间的感受，<br>写出来都东西，谁都无法再还原。对别人不重要，但是对自己还是挺重要都，丢了也觉得可惜。</p><p>jekyll提供了一种方法，而bootstrape提供了一个框架，让实现界面更规矩，更模块化。我不是前段开发，都是自己修改的时候猜测的。<br>所以为了快速建站，引用了一个bootstrape都默认主题就行了，不满世界折腾了。后面学习下前段再慢慢弄吧。现在的重点还是要多些点文章是真的。</p><p>刚用markdown都时候觉得回车不会分行，感觉很不可思议。现在才发现也有个好处，有些编辑器就是不折行，<br>为了让自己看着舒服，不到分段的地方也会按回车，但其实不是为了分段。听说也有修改都markdown语法是支持回车折行的。不过我是不会用的，<br>现在觉得还是用原生，最基本都标准最好，引入都特性越多，变化升级的时候越不方便。就像使用jekyll自带的主题也能改成和bootstrape一样的效果，<br>但是没有个框架，可能哪天再加功能就不方便了。还是用成熟，广泛的技术，这也是为什么开源生生不息的缘故吧。<br>后面参考下这篇文章看看<a href="http://calefy.org/2012/03/03/my-process-of-building-jekyll-blog.html">http://calefy.org/2012/03/03/my-process-of-building-jekyll-blog.html</a></p><p>##躁动的心<br>心里总有种抑制不住的感觉。总想折腾点什么，但是又给压下去了。想学学emacs，头几年就想学了，但是一直没开始，现在突然又萌生了想法。但是又<br>马上抑制住了。不是他不重要，是因为还有更重要都事情没有做。</p><p>时间好快，人老的也好快。但是还有很多事情没有实现，甚至连一些想法都没有。每当觉得自己有点NB的时候，就会发现和小伙伴们相比，又是个渣，生命不息，<br>奋斗不止。上班和上学不一样，人生更多元化了。要选准方向，知道最想要什么。赚钱重要吗？就像上学的时候拼命学习的一些知识，现在觉得当时不如玩点<br>别的，培养些其他的兴趣。赚钱不重要吗？书到用时方恨少，上学的时候怎么就没学明白某些知识呢？</p><p>想玩玩魔方了，想玩玩乐器，也想再多学些知识。</p><p>##idea重要吗<br>发现一个又一个的想法被实现，变成真实。之前想过一个手游，捉鬼，主要通过关系连来激励玩。现在出来了天天系列都游戏，做得很不错。也发现有相同想法的<br>产品，都获得了A级专利。刚工作都时候就像做个框架，到现在也没出来，但是公司内都框架已经如火如荼，做得也不错。早年间就像把博客弄好，要是那时就坚持<br>下来现在也不错了。想要个笔记软件，发现evernote和我想的一样，连网摘想的都一样。</p><p>其实不是自己多么nb，都长了一个脑袋，很多想法大家都去想过。这不重要，重要的是有一部分人深入的想了，把方案列到了纸上。还有一部分人真的去做了。又有一部分<br>人做了还坚持下来成功了。当你看到成功都人实，不要想我也想过，捶胸顿足，其实和人家差的远呢，下次做了再说吧，想谁都会。</p><p>##不折腾<br>编辑器，浏览器，操作系统……这些东西花了很多时间折腾，但都没有什么“效果“，都是在重复的是错，累了，暂时不折腾了。先放着，会有时间好好折腾你们的。<br>##不将就，坚持<br>如果一个人想成功，坚持应该是需要的，还有不将就，不要像懒惰妥协，做就做到完美，没有什么是做不到的。设计的时候要细心，实现的时候要完美，人挡杀人，佛档杀<br>佛。</p><p>写的有点散，希望有时间自己再看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从上次把博客迁移后，本来想多些写东西的，不过都没写出来就又断了两周。写博客还是不能停&lt;br&gt;要坚持下来才可以。发现最近也没什么成块的成果写出来，写一些最近零星的想法，记录下来给自己查看。&lt;br&gt;##博客方面&lt;br&gt;使用jekyll发现还是比较好用的，专心地使用喜欢的编辑器</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Text file busy</title>
    <link href="https://yunpengzhang.github.io/2013/2013-07-19-text-file-busy/"/>
    <id>https://yunpengzhang.github.io/2013/2013-07-19-text-file-busy/</id>
    <published>2013-07-19T06:30:05.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<p>最近在测试程序替换进程时，发现有时替换时提示“text file busy”</p><p>但是把文件rm了，就可以了。或者把进程给重启就ok了。</p><p>记录下。</p><p>后面找下为什么，网上说是因为文件在被使用，使用</p><p>fuser -cdkux filename</p><p>命令就可以了。</p><p>后续：</p><p>查看fuser如何使用；</p><p>为什么有时text file busy，有时不会，是不是文件太大了，内存放不下导致？</p><p><a href="http://blog.chinaunix.net/uid-83572-id-3331.html">http://blog.chinaunix.net/uid-83572-id-3331.html</a></p><p><a href="http://www.cnblogs.com/276815076/archive/2011/10/10/2205682.html">http://www.cnblogs.com/276815076/archive/2011/10/10/2205682.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在测试程序替换进程时，发现有时替换时提示“text file busy”&lt;/p&gt;
&lt;p&gt;但是把文件rm了，就可以了。或者把进程给重启就ok了。&lt;/p&gt;
&lt;p&gt;记录下。&lt;/p&gt;
&lt;p&gt;后面找下为什么，网上说是因为文件在被使用，使用&lt;/p&gt;
&lt;p&gt;fuser -cdkux </summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>人们喜欢随机</title>
    <link href="https://yunpengzhang.github.io/2013/2013-07-09-people-like-random/"/>
    <id>https://yunpengzhang.github.io/2013/2013-07-09-people-like-random/</id>
    <published>2013-07-08T21:35:23.000Z</published>
    <updated>2024-07-20T15:19:39.359Z</updated>
    
    <content type="html"><![CDATA[<img src="/2013/2013-07-09-people-like-random/suibian-300x225.jpg" class="" title="suibian-300x225"><p>生活中，人们经常无所适从，不知道怎么选择。吃饭点什么菜，注册邮箱选什么id，用久了的密码更换时选择什么，听歌听什么。。。</p><p>更多时候，我们是找人帮我们选择，如果没有人，那么选择随机。所以豆瓣电台火了，漂流瓶也火了，一些皮肤设置中的“随机更换”也是大多数人的最爱。</p><p>为什么人们爱随机呢？</p><p>选择是痛苦的。</p><p>不知道选什么，不知道自己要的是什么。</p><p>选择的东西都已经熟悉了，对自己认知的范围内不感兴趣，随机的也许会有些新鲜的东西，不一样的感觉。</p><p>所以，新时期大数据分析就更重要。聚类，推荐等，在多元化的数据中，一个人属于某一类人，别人喜欢的东西可能是你喜欢的，只是你的渠道有限暂时没接触到罢了。就像好声音，外国的观众喜欢，中国肯定相似的观众也会喜欢。所以给你随机的时候就是变相试探和推荐。让你越来越喜欢。</p><p>社交的随机是让人有个倾诉，逃离现实关系链的束缚。把自己的压力，软弱或坚强的另一面，展示给一个不认识的互诉心声，发泄了就好。就像小时候流行笔友，天南海北的用信件交流。</p><p>这都是以后产品可以延伸的点子。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2013/2013-07-09-people-like-random/suibian-300x225.jpg&quot; class=&quot;&quot; title=&quot;suibian-300x225&quot;&gt;

&lt;p&gt;生活中，人们经常无所适从，不知道怎么选择。吃饭点什么菜，注册邮箱选什么</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>论“有用”</title>
    <link href="https://yunpengzhang.github.io/2013/2013-06-26-on-the-useful/"/>
    <id>https://yunpengzhang.github.io/2013/2013-06-26-on-the-useful/</id>
    <published>2013-06-26T06:59:51.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>小时候老师会说：“看课外书小说没用，功课才有用，可以考大学”</p><p>大学家长会说：“找对象没用，影响学业，好好读书才有用”</p><p>上班朋友会说：“钻研工作没用，赚钱快乐最有用”</p><p>……</p><p>人生被太多的有用没用的话题所充斥，偶尔我们自己回忆，也会觉得某段时期的事情“没用”，而有用的没有做。</p><p>前段时间还看过一片文章，一个修女给NASA写信，认为人类探索宇宙是没用的，应该把探索宇宙的钱用来捐助儿童。</p><p>到底什么是有用，什么没用呢？</p><p>回答这个问题前，我们先回答个别的问题。什么是益虫，什么是害虫？大老虎和小白兔哪个好呢？</p><p>显然，人们把自己的喜好加入了评判，根据对自己的优劣来定位。</p><p>有用没用也是如此，是否是自己看重的，或是可以通过他获取满足感、存在感等。</p><p>学生成绩会让他受重视，找对象耽误学业和时间，会影响。当下的社会价值观决定大家对行为的取向。</p><p>曾几何时，玩dota昏天暗地，觉得这才是生活，乐此不疲。现在不会了，但为什么当时很喜欢而且心甘情愿呢？因为当时满足了心理需求，当时没觉得物质和周围的环境对自己有影响，除了游戏，其他的也都好。但现在呢，工作的压力、生活的压力显现了，玩游戏满足不了心灵需求。可能过些年发达了，不需要奋斗了，也觉得现在的奋斗也是“没用”的。<span id="more"></span></p><p>但是积少成多，蝴蝶效应。明天的结果和今天的每一小步都有关系。有用没用只是暂时的，而且要发自内心，而不是大众。自己快乐或觉得好才是真的好。如果那天觉得不是了，那是你成熟了，也可能是你变了。</p><p>任何年龄干任何时候的事，做好当下最重要。不要用自己的价值观绑架别人，你觉得爱护动物别人就不能吃肉吗？</p><p>《中国合伙人》里的王阳就是一个例子。</p><p>总之，不要用自己的高尚绑架他人，世界是丰富多彩的，每个人的认知有限，不求所有人理解自己，但是自己包容其他正确的思想就可以。</p><p>以下文章转自</p><p><a href="http://select.yeeyan.org/view/265546/309669">http://select.yeeyan.org/view/265546/309669</a></p><p>1970年，赞比亚修女 Mary Jucunda 给 Ernst Stuhlinger 博士写了一封信，他因在火星之旅工程中的原创性研究，成为 NASA（美国航空航天局）Marshall 太空航行中心的科学副总监。信中，Mary Jucunda 修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>Stuhlinger 很快给Jucunda 修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员 William Anders 于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由 NASA 以《为什么要探索宇宙》为标题发表。</p><hr><p>亲爱的Mary Jucunda修女：</p><p>每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。</p><p>首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在人类的技术水平可以畅想火星之旅之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气。“我们还在受瘟疫的苦，”他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动。“我会尽可能地接济大家，”他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作（以及同时期其他人的努力）赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入会感到很困扰，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。</p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问，为什么先设计出宇航员登月舱的维生系统，而不是先为心脏病患者造出远程体征监测设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。</p><p>若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的研究、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p><p><img src="http://cdn.yeeyan.org/upload/image/2012/08/10114831_54510.jpg"></p><p>随信一块寄出的这张照片，是1968年圣诞节那天阿波罗8号在环月球轨道上拍摄的地球的景象。太空项目所能带来的各种结果中，这张照片也许是其中最可贵的一项。它开阔了人类的视野，让我们如此直观地感受到地球是广阔无垠的宇宙中如此美丽而又珍贵的孤岛，同时让我们认识到地球是我们唯一的家园，离开地球就是荒芜阴冷的外太空。无论在此之前人们对地球的了解是多么的有限，对于破坏生态平衡的严重后果的认识是多么的不充分。在这张照片公开发表之后，面对人类目前所面临的种种严峻形势，如环境污染、饥饿、贫穷、过度城市化、粮食问题、水资源问题、人口问题等等，号召大家正视这些严重问题的呼声越来越多。人们突然表示出对自身问题的关注，不能说和目前正在进行的这些初期太空探索项目，以及它所带来的对于人类自身家园的全新视角无关。</p><p>太空探索不仅仅给人类提供一面审视自己的镜子，它还能给我们带来全新的技术，全新的挑战和进取精神，以及面对严峻现实问题时依然乐观自信的心态。我相信，人类从宇宙中学到的，充分印证了Albert Schweitzer那句名言：“我忧心忡忡地看待未来，但仍满怀美好的希望。”</p><p>向您和您的孩子们致以我最真挚的敬意！</p><p>您诚挚的，</p><p>恩斯特·史都林格</p><p>科学副总监</p><p>1970年5月6日</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小时候老师会说：“看课外书小说没用，功课才有用，可以考大学”&lt;/p&gt;
&lt;p&gt;大学家长会说：“找对象没用，影响学业，好好读书才有用”&lt;/p&gt;
&lt;p&gt;上班朋友会说：“钻研工作没用，赚钱快乐最有用”&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;人生被太多的有用没用的话题所充斥，偶尔我们自己回忆，也会觉得某段时期的事情“没用”，而有用的没有做。&lt;/p&gt;
&lt;p&gt;前段时间还看过一片文章，一个修女给NASA写信，认为人类探索宇宙是没用的，应该把探索宇宙的钱用来捐助儿童。&lt;/p&gt;
&lt;p&gt;到底什么是有用，什么没用呢？&lt;/p&gt;
&lt;p&gt;回答这个问题前，我们先回答个别的问题。什么是益虫，什么是害虫？大老虎和小白兔哪个好呢？&lt;/p&gt;
&lt;p&gt;显然，人们把自己的喜好加入了评判，根据对自己的优劣来定位。&lt;/p&gt;
&lt;p&gt;有用没用也是如此，是否是自己看重的，或是可以通过他获取满足感、存在感等。&lt;/p&gt;
&lt;p&gt;学生成绩会让他受重视，找对象耽误学业和时间，会影响。当下的社会价值观决定大家对行为的取向。&lt;/p&gt;
&lt;p&gt;曾几何时，玩dota昏天暗地，觉得这才是生活，乐此不疲。现在不会了，但为什么当时很喜欢而且心甘情愿呢？因为当时满足了心理需求，当时没觉得物质和周围的环境对自己有影响，除了游戏，其他的也都好。但现在呢，工作的压力、生活的压力显现了，玩游戏满足不了心灵需求。可能过些年发达了，不需要奋斗了，也觉得现在的奋斗也是“没用”的。</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>gcc -fno-strict-aliasing 选项注意</title>
    <link href="https://yunpengzhang.github.io/2013/2013-06-26-gcc-fno-strict-aliasing-options-note/"/>
    <id>https://yunpengzhang.github.io/2013/2013-06-26-gcc-fno-strict-aliasing-options-note/</id>
    <published>2013-06-26T01:53:13.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做CRO的时候发现好多makefile都使用了“-fno-strict-aliasing”选项，仔细查看了一下他的含义，发现在使用优化的时候，大家应该多注意。</p><blockquote></blockquote><blockquote></blockquote><p>If optimization level is &gt;&#x3D; 2 in gcc-4.1, strict-aliasing is used, and this could cause probelms when a pointer is referencing to a different type of object and the object is refered there after by using this pointer. That is the case in this example. So you should force the compiler to not use strict-aliasing by a argument “-fno-strict-aliasing” if you want to use “-O2” or “-O3”.</p><p>在gcc4.1版本以上，如果多种类型的指针指向同一块内存，使用-O2或-O3优化时，会把不同类型指针的操作给优化掉，认为不会有不同类型的指针操作同一块内存。</p><p>举个例子</p><pre><code>#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/time.h&gt;#include int n;int foo(unsigned long *ptr) &#123;            n=1;    *ptr=3;    return n;&#125;int main() &#123;    fprintf(stdout, &quot;%d\n&quot;, foo(&amp;n));    return 0;&#125;</code></pre><p>代码编译</p><p>​<br>     gcc main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    3</p><p>如果优化</p><p>​<br>     gcc -O2 main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    1</p><p>加入参数</p><p>​<br>     gcc -O2 -fno-strict-aliasing main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    3</p><p>综上，得出结论：</p><p>1.重视编译告警，根据告警修复代码。</p><p>2.编译优化是否真的重要，对性能提升是否明显，如果不需要尽量不要提早优化，gcc的优化参数很多，有些坑没踩过是不会hold住的。</p><p>3.尽量减少不同类型指针强转的操作，可以使用同类型指针或者union操作等方法。</p><p>4.编译优化加上“-fno-strict-aliasing”选项，让编译器不优化这里。</p><p><a href="http://www.dutor.net/index.php/2012/07/gcc-strict-aliasing/">http://www.dutor.net/index.php/2012/07/gcc-strict-aliasing/</a></p><p><a href="http://www.zeali.net/entry/454">http://www.zeali.net/entry/454</a></p><p><a href="http://hi.baidu.com/rsjdsibkwtnrxyr/item/b04e86dbdc8351de241f40cc">http://hi.baidu.com/rsjdsibkwtnrxyr/item/b04e86dbdc8351de241f40cc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做CRO的时候发现好多makefile都使用了“-fno-strict-aliasing”选项，仔细查看了一下他的含义，发现在使用优化的时候，大家应该多注意。&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp和udp</title>
    <link href="https://yunpengzhang.github.io/2013/2013-06-18-tcp-and-udp/"/>
    <id>https://yunpengzhang.github.io/2013/2013-06-18-tcp-and-udp/</id>
    <published>2013-06-18T03:14:31.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>tcp适合对流量敏感的应用，tcp的窗口机制可以很好的利用带宽。</p><p>udp适合对时延敏感的应用。</p><p>mtu尺寸576bit（包括ip和udp包头）否则太大会出现路由器组分包的时候错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tcp适合对流量敏感的应用，tcp的窗口机制可以很好的利用带宽。&lt;/p&gt;
&lt;p&gt;udp适合对时延敏感的应用。&lt;/p&gt;
&lt;p&gt;mtu尺寸576bit（包括ip和udp包头）否则太大会出现路由器组分包的时候错误。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>两种修改主机名方法</title>
    <link href="https://yunpengzhang.github.io/2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name/"/>
    <id>https://yunpengzhang.github.io/2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name/</id>
    <published>2013-06-13T23:11:25.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>一、修改redhat类机器</p><blockquote><p>cat &#x2F;etc&#x2F;sysconfig&#x2F;network<br>NETWORKING&#x3D;yes</p></blockquote><p>HOSTNAME&#x3D;myservice</p><p>二、修改suse机器</p><blockquote><p>&#x2F;etc&#x2F;HOSTNAME</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、修改redhat类机器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cat &amp;#x2F;etc&amp;#x2F;sysconfig&amp;#x2F;network&lt;br&gt;NETWORKING&amp;#x3D;yes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HOSTNAME&amp;#x3D;mys</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>生命要有痕迹</title>
    <link href="https://yunpengzhang.github.io/2013/2013-06-04-traces-of-life-have/"/>
    <id>https://yunpengzhang.github.io/2013/2013-06-04-traces-of-life-have/</id>
    <published>2013-06-04T07:01:39.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>时光飞逝，白驹过隙。致即将逝去的青春。生命还有多少值得我们去浪费，对于时间不可再生的财产，要规划下了。生命就如焰火，绚烂一阵，遍飞逝了。然而并不是每个人都能在天空划出一道美丽的光彩，生命究竟应该怎样度过？活过，就要有痕迹。</p><p>如果感觉生活是乏味的，那么不是生活乏味，而是你把生活给过得乏味了。遇到问题并不可怕，要改变现状，让生活更美好。</p><p>重复，单调是浪费时间，如果有重复单调的事情，要想办法让他不再来，来了有自动的应对方法。人生苦短，我们要陪家人，要赚钱，还要拯救世界，时间对我们太重要了，不要浪费。要知道自己要的是什么，而不是做的过程，不是埋头干。有了目标，朝着目标前行。做个有观点的人，有目标的人才为人。</p><p>不屈服、不随流，最终达到目标，就如焰火飞向高空，划出最美的曲线，给人留下印象，然后结束一生，不枉此行。</p><p>不同年龄做不同的事，莫压抑，莫张狂，活过，就要有痕迹。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时光飞逝，白驹过隙。致即将逝去的青春。生命还有多少值得我们去浪费，对于时间不可再生的财产，要规划下了。生命就如焰火，绚烂一阵，遍飞逝了。然而并不是每个人都能在天空划出一道美丽的光彩，生命究竟应该怎样度过？活过，就要有痕迹。&lt;/p&gt;
&lt;p&gt;如果感觉生活是乏味的，那么不是生活乏</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>glibc随机函数</title>
    <link href="https://yunpengzhang.github.io/2013/2013-05-29-glibc-random-function/"/>
    <id>https://yunpengzhang.github.io/2013/2013-05-29-glibc-random-function/</id>
    <published>2013-05-28T22:11:33.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>一、如何使用随机函数<br>查看man可以找到<br>#include &lt;stdlib.h&gt;</p><p>int rand(void);</p><p>int rand_r(unsigned int *seedp);</p><p>void srand(unsigned int seed);</p><p>rand返回0~RAND_MAX之间的整数，是“伪随机”<br>srand()用来设置rand函数的随机种子，随机种子相同产生的随机数序列也是相同的。<br>如果没调用srand那么rand函数自动使用1作为种子。</p><p>在函数初始化的时候srand()调用设置一次随机种子就可以里，不必每次调用rand都使用srand调用。</p><p>随机函数原理<br>RAND_MAX的值为32767<br>原理是使用Linear-Congruential-Random-Number-Generator算法产生伪随机数。（具体的我还没弄明白）弄明白再补一篇。<br>函数如下</p><pre><code>static int32_t randtbl[DEG_3 + 1] =  &#123;    TYPE_3,    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,    1627687941, -179304937, -2073333483, 1780058412, -1989503057,    -615974602, 344556628, 939512070, -1249116260, 1507946756,    -812545463, 154635395, 1388815473, -1926676823, 525320961,    -1009028674, 968117788, -123449607, 1284210865, 435012392,    -2017506339, -911064859, -370259173, 1132637927, 1398500161,    -205601318,  &#125;;/* Initialize the random number generator based on the given seed.  If the   type is the trivial no-state-information type, just remember the seed.   Otherwise, initializes state[] based on the given &quot;seed&quot; via a linear   congruential generator.  Then, the pointers are set to known locations   that are exactly rand_sep places apart.  Lastly, it cycles the state   information a given number of times to get rid of any initial dependencies   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]   for default usage relies on values produced by this routine.  */int__srandom_r (seed, buf)     unsigned int seed;     struct random_data *buf;&#123;  int type;  int32_t *state;  long int i;  int32_t word;  int32_t *dst;  int kc;  if (buf == NULL)    goto fail;  type = buf-&gt;rand_type;  if ((unsigned int) type &gt;= MAX_TYPES)    goto fail;  state = buf-&gt;state;  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */  if (seed == 0)    seed = 1;  state[0] = seed;  if (type == TYPE_0)    goto done;  dst = state;  word = seed;  kc = buf-&gt;rand_deg;   for (i = 1; i &lt; kc; ++i)     &#123;       /* This does:        state[i] = (16807 * state[i - 1]) % 2147483647;      but avoids overflowing 31 bits.  */       long int hi = word / 127773;       long int lo = word % 127773;       word = 16807 * lo - 2836 * hi;       if (word &lt; 0)     word += 2147483647;       *++dst = word;     &#125;   buf-&gt;fptr = &amp;state[buf-&gt;rand_sep];   buf-&gt;rptr = &amp;state[0];   kc *= 10;   while (--kc &gt;= 0)     &#123;       int32_t discard;       (void) __random_r (buf, &amp;discard);     &#125;  done:   return 0;  fail:   return -1; &#125;int__random_r (buf, result)     struct random_data *buf;     int32_t *result;&#123;  int32_t *state;  if (buf == NULL || result == NULL)    goto fail;  state = buf-&gt;state;  if (buf-&gt;rand_type == TYPE_0)    &#123;      int32_t val = state[0];      val = ((state[0] * 1103515245) + 12345) &amp; 0x7fffffff;      state[0] = val;      *result = val;    &#125;  else    &#123;      int32_t *fptr = buf-&gt;fptr;      int32_t *rptr = buf-&gt;rptr;      int32_t *end_ptr = buf-&gt;end_ptr;      int32_t val;      val = *fptr += *rptr;      /* Chucking least random bit.  */      *result = (val &gt;&gt; 1) &amp; 0x7fffffff;      ++fptr;      if (fptr &gt;= end_ptr)    &#123;      fptr = state;      ++rptr;                                                  &#125;      else    &#123;      ++rptr;      if (rptr &gt;= end_ptr)        rptr = state;    &#125;      buf-&gt;fptr = fptr;      buf-&gt;rptr = rptr;    &#125;  return 0; fail:                    __set_errno (EINVAL);  return -1;&#125;</code></pre><p>可以看到，设置随机种子的时候操作很复杂，如果每次rand都调用srand是非常耗时，而且没有用途的。特别是有人总是用srand(time(NULL))，那样一秒钟产生的随机数都是相同的，根本没有作用。</p><p>二、使用场景</p><p>如果只是为了使用随机得到尽量乱平均的数字，可以使用rand函数，或者使用自己写的</p><pre><code>static unsigned long next = 1;/* RAND_MAX assumed to be 32767 */int myrand(void) &#123;next = next * 1103515245 + 12345;return((unsigned)(next/65536) % 32768);&#125;void mysrand(unsigned seed) &#123;next = seed;&#125;</code></pre><p>也能达到效果，例如在寻址函数中随机挑选一个服务器，为的就是平均，即使轮询影响也不大。</p><p>如果是为了加密，构造随机数，那么rand函数不适合你，还是用硬件的函数吧<br>参考硬件相关的安全随机数：<a href="http://yunpengzhang.com/articles/202.html">&#x2F;dev&#x2F;random和&#x2F;dev&#x2F;urandom</a></p><p>参考：<br><a href="http://blog.csdn.net/flyoxs/article/details/5331718">http://blog.csdn.net/flyoxs/article/details/5331718</a></p><p><a href="http://hi.baidu.com/tlogin/item/e619169c2c0dfdc9b6253149">http://hi.baidu.com/tlogin/item/e619169c2c0dfdc9b6253149</a></p><p><a href="http://hi.baidu.com/g0t3n/item/c3508beaa9a903b22f140baf">http://hi.baidu.com/g0t3n/item/c3508beaa9a903b22f140baf</a></p><p><a href="http://en.wikipedia.org/wiki/Linear_congruential_generator">http://en.wikipedia.org/wiki/Linear_congruential_generator</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、如何使用随机函数&lt;br&gt;查看man可以找到&lt;br&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int rand(void);&lt;/p&gt;
&lt;p&gt;int rand_r(unsigned int *seedp);&lt;/p&gt;
&lt;p&gt;void srand(uns</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>随机端口复用导致丢包的问题及解决方法</title>
    <link href="https://yunpengzhang.github.io/2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions/"/>
    <id>https://yunpengzhang.github.io/2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions/</id>
    <published>2013-05-27T04:59:01.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>因为redhad随机分配端口和suse策略不同，导致有随机分配端口的业务迁移到redhad上会</p><p>出现端口被抢占而丢包的问题。</p><p><strong>解决方法：</strong></p><p><strong>【方法一】</strong>创建socket的时候，setsockopt函数设置绑定端口socket的属性为不可重用的。</p><p><strong>【方法二】</strong>控制绑定端口范围在32768以下。</p><p>**0.**<strong>抢占的原则是什么？</strong></p><p>**      **   顺序和系统实现有关，我们公司的suse和redhad都是后启动绑定的socket抢占先绑定的。</p><p>**1.**<strong>为什么会出现tlinux上而suse没事？</strong></p><p>因为suse随机绑定端口时会绕过已经被绑定的端口，而tlinux不会，会完全</p><p>随机。但是已经绑定的端口如果设置成not reuse，就不会被绑定。</p><p>**2.**<strong>都什么程序会出现这种问题？</strong></p><p>有随机绑定端口，而且设置成reuse的都可能会遇到。</p><p>例如：</p><p>如果初始化函数地址填0，会随机绑定端口。</p><p>一些老的agent进程也是随机创建端口，而且也是允许reuse。</p><p>一些程序内部的api会随机创建端口发包收取。</p><p>**3.**<strong>为什么要缩小绑定端口范围在32768以下？</strong></p><p>**     **    因为系统的配置随机范围在32768——61000范围。</p><blockquote><p>sysctl -a | grep ip_local_port_range<br>net.ipv4.ip_local_port_range &#x3D; 32768 61000</p></blockquote><p>我们的老库创建socket函数，框架都设置udp是socket在创建时是reuse的，</p><p>所以迁移tlinux都会出现这些问题。</p><p>对于udp，不用设置reuse，因为只有多播的时候才需要，但是我们的</p><p>业务并不使用多播。可能是框架和库出于对tcp的统一，都设置成了reuse。</p><p>深度参考</p><p><a href="http://blog.csdn.net/dog250/article/details/5303572">http://blog.csdn.net/dog250/article/details/5303572</a></p><p>vi &#x2F;etc&#x2F;sysctl.conf<br>添加下面一行：<br>net.ipv4.ip_local_port_range &#x3D; 1024 65535</p><p>然后执行：</p><p>sysctl -p</p><p>意思是告诉linux可以使用的端口是从1024到65535，不用编译内核就可以生效。<br>[root@PerfTestApp3 ~]# sysctl -a|grep ip_local_port_range<br>net.ipv4.ip_local_port_range &#x3D; 32768 61000</p><p><a href="http://rdc.taobao.com/blog/cs/?p=1195">http://rdc.taobao.com/blog/cs/?p=1195</a><br>SO_REUSEADDR可以用在以下四种情况下。<br>(摘自《Unix网络编程》卷一，即UNPv1)<br>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启<br>动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。<br>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但<br>每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可<br>以测试这种情况。<br>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个soc<br>ket绑定的ip地址不同。这和2很相似，区别请看UNPv1。<br>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的<br>多播，不用于TCP。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为redhad随机分配端口和suse策略不同，导致有随机分配端口的业务迁移到redhad上会&lt;/p&gt;
&lt;p&gt;出现端口被抢占而丢包的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【方法一】&lt;/strong&gt;创建socket</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>snprintf</title>
    <link href="https://yunpengzhang.github.io/2013/2013-01-31-snprintf/"/>
    <id>https://yunpengzhang.github.io/2013/2013-01-31-snprintf/</id>
    <published>2013-01-31T06:30:44.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h2><p>int snprintf(char *str, size_t size, const char *format, …);</p><p>将可变个<a href="http://baike.baidu.com/view/327406.htm">参数</a>(…)按照format格式化成字符串，然后将其复制到str中</p><p>(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(‘\0’)；</p><p>(2) 如果格式化后的字符串长度 &gt;&#x3D; size，则只将其中的(size-1)个字符复制到str中，并返回一个负值，其后没有字符串结束符(‘\0’)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;snprintf&quot;&gt;&lt;a href=&quot;#snprintf&quot; class=&quot;headerlink&quot; title=&quot;snprintf()&quot;&gt;&lt;/a&gt;snprintf()&lt;/h2&gt;&lt;p&gt;int snprintf(char *str, size_t size, const</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>学习点滴</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-30-learn-drip/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-30-learn-drip/</id>
    <published>2012-12-29T22:46:16.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>工作了几年的人，一问起是否还在学习，很多都说太忙了，没有时间学习。确实，每天工作的时间都很长，而且杂事琐事也很多，有时回到家里，脑子里想得还是工作的事情。想大块的时间来读书，学习并实践新的知识还是很难的。但是it行业不进则退，上班后要如何充电呢？</p><span id="more"></span><p>程序员要学的知识也很多，例如一个后台开发，要学习linux内核、c&#x2F;c++的语言深层次的东西、数据结构算法、新的语言如python，ruby等、了解业界的动态、学习架构、学习编译器的特性、数据挖掘……哪项拿出来都够学习很久的。<br>刚出校门的时候，学习还是按照上课那样的学习，我管他叫“阵地学习法”。先找来两本书，然后从头开始看，记笔记学习。像学习课本一样。但时间久了发现效果并不是那么好，因为学的很累，有些东西学起来暂时还没有实践，慢慢的也就忘记了。<br>后来和一位老员工探讨，学到了一种方法。“兴趣是最好的老师”，你对什么感兴趣就学什么。实践也很重要，你遇到什么问题了，或者通过问题来发散到的知识点，立即去挖去学习效果会比较好。一来解决了问题，二来经过实践记忆深刻，效果自然就好。这样一本书就不用都看了，只看一部分就可以了。也不会觉得“以有崖换无崖，殆矣”。姑且管这种叫做“游击式学习法”吧。<br>物极必反，不能说“游击式”和“阵地式”哪个更好，还是要看具体的环境。“游击式”适合学习时间少，快速解决某种问题。“阵地式”学的面更广，通常会接触到疑问的底层，知其然还知其所以然，问题理解更透彻，但时间更久。都综合起来更好。<br>首先要规划出学习时间，例如每天晚上两小时、周末。然后细化，哪些是处理游击学习，哪些是处理阵地学习。通过每天遇到的问题来找到游击学习的点，通过游击点和自身发现的短板来归纳出阵地学习的范围。这样养成习惯。先集中精力把眼前的问题解决并收集到相关方法。因为有的知识我们不是马上就需要，或者马上就能学会的，但是我们可以先知道有这个东西，再遇到这类问题可以用这个关键词找到，或者有时间可以阵地地把这部分学了。<br>然后确定优先级。游击式以解决实际问题和兴趣涉猎为主。例如工作遇到问题的最优解法查询，对于业界新知识新算法的了解。定期把这些点挑出值得学习的输入到阵地学习单子里。阵地式主要是提高自身深度，处理最急迫需要学习的。注意：最急迫可能是你要发展更深的擅长领域，例如已经懂得了C++并天天用，但是要更深入学习C++的底层；也可能是学习python、ruby等新语言，拓宽知识面。就看你觉得哪个是你觉得最重要的了。</p><p>总之，要了解学习的目的，学习不是看书，不是花时间。是为了解决问题，让自己长进。什么能符合这个目标我们就学什么，否则还不如歇会呢。道理虽简单，但是能够跳出来思考这个问题，并且能抽出时间觉得要学习，还是很难得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作了几年的人，一问起是否还在学习，很多都说太忙了，没有时间学习。确实，每天工作的时间都很长，而且杂事琐事也很多，有时回到家里，脑子里想得还是工作的事情。想大块的时间来读书，学习并实践新的知识还是很难的。但是it行业不进则退，上班后要如何充电呢？&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>解决内存读写冲突</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-29-resolve-memory-access-conflicts/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-29-resolve-memory-access-conflicts/</id>
    <published>2012-12-29T05:23:24.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了几个内存读写冲突的场景：</p><p>1.内存hash读写冲突</p><p>一个进程写，多个进程读，当读进程找到要读取的指针时，写进程进行了写操作，然后回收了原先读进程要读的内存块。这时cpu又调度到读进程，读失败，返回错误给前端，重试ok。</p><p>由于业务场景可以容忍读到旧数据，最终采用的解决方法为延迟回收内存块，即内存回收前放到一个回收队列里，先不清理数据，过500ms后再回收数据，有重组的时间等待读冲突的读进程取数据。</p><span id="more"></span><p>但是要不能容忍读到旧数据呢？加锁，读的时候加锁，读写互斥，我觉得不好，当读量巨大一直有读，让写永远也抢不到锁，最终活锁。</p><p>只有写的时候加锁，读发现读到的有问题然后重新读指针读新数据。</p><p>2.上报内存多进程写冲突</p><p>多个进程收到请求，对统一上报属性值进行累加，操作的是同一块固定共享内存。发现请求量大时上报数量不准。在t1时刻，进程p1读到内存值v1，然后cpu调度到p2，也读到内存值v1。之后p1把v1+x，然后set到内存，这时p2也把v1+y，然后set到内存。结果覆盖了。少报了x。</p><p>解决方法:都一直是累加操作，应该让每个进程读取和累加完成之后再被cpu调度走。即读取和累加成为一个原子操作。</p><p>在gcc中有原子函数接口。</p><p>type<code> __sync_fetch_and_add (</code>type<code> *ptr, </code>type<code> value, ...)</code></p><p>使用后就好了。</p><p>3.多进程写操作hash内存检测节点</p><p>对于场景2来说，数据结构是数组，每个上报在固定的共享内存中。但是如果改为hash呢，会有什么不同吗？每个进程除了要把内存的值原子读取和操作外，还要对操作的hash节点的指针进行校对，因为你把一个属性的指针给删除或修改了，其他的进程可能正保存着呢，然后进行读写操作会把其他内存写如脏数据，也使自己的上报不准。</p><p>解决方法：使用cas（Compare-and-swap），就是在修改值之前先把值读出来，然后写之前会比对刚才读到的值和现在写之前内存的值是否一致，如果一致才进行写操作，把新的值set进去。</p><p>在gcc中的函数是</p><p><code>bool</code> <code>__sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</code></p><p><code>type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</code></p><p>以上三个场景究其原因，都是cpu是多核，多个进程同时操作，cpu抢占所造成的。在多线程编程中会更多见。</p><p>都是因为读写操作的时序问题，把一个本应该是原子操作的整个事务给分开提交造成的冲突。</p><p>扩展阅读：<br><a href="http://blog.csdn.net/lifesider/article/details/6582338">http://blog.csdn.net/lifesider/article/details/6582338</a><br>cas （compare and swap）<a href="http://blog.csdn.net/chenziwen/article/details/6050140">http://blog.csdn.net/chenziwen/article/details/6050140</a><br>Built-in functions for atomic memory access<a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html">http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html</a></p><p><a href="http://en.wikipedia.org/wiki/Compare-and-swap">http://en.wikipedia.org/wiki/Compare-and-swap</a></p><p><a href="http://en.wikipedia.org/wiki/Fetch-and-add">http://en.wikipedia.org/wiki/Fetch-and-add</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了几个内存读写冲突的场景：&lt;/p&gt;
&lt;p&gt;1.内存hash读写冲突&lt;/p&gt;
&lt;p&gt;一个进程写，多个进程读，当读进程找到要读取的指针时，写进程进行了写操作，然后回收了原先读进程要读的内存块。这时cpu又调度到读进程，读失败，返回错误给前端，重试ok。&lt;/p&gt;
&lt;p&gt;由于业务场景可以容忍读到旧数据，最终采用的解决方法为延迟回收内存块，即内存回收前放到一个回收队列里，先不清理数据，过500ms后再回收数据，有重组的时间等待读冲突的读进程取数据。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>《the art of unix programming》读书笔记</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-23-the-art-of-unix-programming-reading-notes/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-23-the-art-of-unix-programming-reading-notes/</id>
    <published>2012-12-23T05:31:43.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>是什么吸引程序开发使用*nix平台，为什么全世界去修改这个系统还这么井然有序。这和unix的设计哲学分不开，一个好的架构，软件的执行思想，使得无论使用和开发这个系统都是那么的吸引人，简单。这本书介绍了很多unix的艺术，让人觉得好的架构和思想真是一门学问，用艺术的观点来开发系统，简单的东西实现复杂的规则，本身就是美。它山之石，不只是操作系统，在其他的系统、领域，都是通用的。</p><p>ken thompson:先制作原型，再精雕细琢。优化之前先确保能用。<br>“极限编程”宗师kent beck从另一种不同的文化将这点扩展为：先求运行，再求正确，最后求快。</p><p>系统和函数要对接收的东西要包容，对输出的东西要严格。</p><p>态度：看到该做的就去做——短期来看似乎是多做了，但从长期看来，这才是最佳捷径。<br>如果不能确定什么是对的，那么就只做最少量的工作，确保任务完成就行，至少直到明白什么是对的。</p><p>良好运用unix哲学，应该珍惜你的时间决不浪费，一旦某人已经解决了某个问题，就直接拿来利用，<br>不要让骄傲或偏见拽祝你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，<br>好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p><p>模块化原则的内容：<br>模块化代码的首要特质就是封装。封装良好的模块不会过多向外部披露自身的细节，不会直接调用其他模块的实现码，<br>也不会胡乱共享全局数据。模块之间通过应用程序编程接口（API）——一组严密、定义良好的程序调用和数据结构来通信。</p><p>88p</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;是什么吸引程序开发使用*nix平台，为什么全世界去修改这个系统还这么井然有序。这和unix的设计哲学分不开，一个好的架构，软件的执行思想，使得无论使用和开发这个系统都是那么的吸引人，简单。这本书介绍了很多unix的艺术，让人觉得好的架构和思想真是一门学问，用艺术的观点来开发</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>最近经验总结</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-16-recent-experience/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-16-recent-experience/</id>
    <published>2012-12-16T05:32:29.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>1.拖延症害死人，有事情要做，马上去做，别拖来拖去。</p><p>2.心灵要强大，要有抗压能力，要自信，否则啥都帮不了你。</p><p>3.遇到问题不要慌，查看视图属性，把和曲线重合的都找到，如果属性很多也要都翻一遍才行，有的时候找到第一个就停手然后马上就找问题有点着急，应该都看一遍，把和问题曲线相关的都找到。</p><p>4.不要为了读书而读书，到底对什么感兴趣，想解决什么问题就去看那部分，需要扩展的地方再去查看周围的东西扩展。否则按部就班是没有那么多时间的。</p><p>吾生也有涯，而知无涯，以有涯随无涯，殆矣。——庄子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.拖延症害死人，有事情要做，马上去做，别拖来拖去。&lt;/p&gt;
&lt;p&gt;2.心灵要强大，要有抗压能力，要自信，否则啥都帮不了你。&lt;/p&gt;
&lt;p&gt;3.遇到问题不要慌，查看视图属性，把和曲线重合的都找到，如果属性很多也要都翻一遍才行，有的时候找到第一个就停手然后马上就找问题有点着急</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统读书笔记3</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-09-in-depth-understanding-of-computer-systems-reading-notes-3/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-09-in-depth-understanding-of-computer-systems-reading-notes-3/</id>
    <published>2012-12-09T01:22:15.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>从第三到第六章，对系统硬件层面讲述的比较多，于平时工作的范围联系不是很大，另外硬件方面的内容也需要再结合其他书籍再写笔记最好。所以只是把三到六章大概的读了以下，后面再补充详细的笔记。本次写的是第七章——链接。</p><p>现代操作系统抽象得最好的地方：程序执行时，就像自己单独使用所有的cpu，单独地占用系统的所有内存。使应用程序的开发变得简单，不必局限于底层的硬件类型来进行实现。</p><p>链接是将各种代码和数据部分收集起来，并组合成一个单一文件的过程。组合成单一的二进制bin文件，可以被加载到存储器执行。</p><span id="more"></span><p>链接可以在编译时，也可以在加载时执行，也可以在运行时由应用程序执行。</p><p>链接模块使模块开发成为可能，一个巨大的程序可以分为众多模块来分别编译，一部分修改后只要编译修改部分。</p><p>大多数编译系统提供编译驱动程序，用户在需要时调用语言预处理器、编译器、汇编器和链接器。分别把cpp-&gt;.i-&gt;.s-&gt;.o-&gt;可执行目标文件。</p><p>.o文件由不同的代码和数据节组成。</p><p>链接器要做两个事情：符号解析（把每个符号引用和定义联系起来）；重定位（把每个符号定义与一个存储器位置联系起来，然后修改这些符号的引用，使得他们指向这个存储器位置，从而重定位这些节）。</p><p>链接器只是链接，对目标机器了解很少，因为编译器和汇编器已经根据机器的硬件生成了代码和数据的指令，链接器只要处理好符号解析和重定位就可以了。</p><p>目标文件的三种形式：<br>可重定位目标文件。.o文件。包含二进制代码和数据，与其它可重定位目标文件可创建一个可执行目标文件。<br>可执行目标文件。也是包含二进制代码和数据，可以被直接拷贝到存储器并执行。 共享目标文件。可以加载或者运行时被动态加载到存储器并链接。.so文件。</p><p>可重定位目标文件结构：</p><p><a href="http://yunpengzhang.com/wp-content/uploads/2012/12/ELF%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png"><img src="http://yunpengzhang.com/wp-content/uploads/2012/12/ELF%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6-258x300.png"></a></p><p>ELF头：包含了ELF文件的一些基本信息如头大小、目标文件类型、机器类型等。<br>.text：已编译程序的机器代码。<br>.rodata:只读数据<br>.data:已初始化的全局C变量。<br>.bss：未初始化的全局C变量。这个解不占据实际的空间，仅仅是一个占位符。<br>.symtab:符号表，存放程序定义和引用的函数和全局变量信息。和-g选项调试无关。不包括局部变量条目。<br>.rel.text：一个.text节中位置的列表。<br>.rel.data：被模块引用或定义的任何全局变量的重定位信息。<br>.debug：调试符号表。-g选项会有。<br>.line:程序行号和.text机器指令映射。<br>.strtab:包括.symtab和.debug节中的符号表，以及节头部中的节名字。都是以null结尾的字符串序列。</p><p>在函数中定义的局部static不是存储在栈中，也存在.data或.bss中。</p><p>可以利用static隐藏变量和函数名字，不被其他模块访问，通常做库的时候使用，防止别人的函数和你的重名。</p><p>链接器解析符号引用的方法是将每个引用与可重定位目标文件的符号表中的一个确定的符号定义联系起来。</p><p><a href="http://yunpengzhang.com/wp-content/uploads/2012/12/ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png"><img src="http://yunpengzhang.com/wp-content/uploads/2012/12/ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6-300x206.png"></a></p><p>函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p><p>链接器处理多重符号规则：<br>1.不允许有多个强符号。<br>2.如果有一个强符号和多个弱符号，选择强符号。<br>3.有多个弱符号，那么从弱符号任意选一个。</p><p>所以好的编程习惯很重要，尽量不要使用全局变量，如果使用，那么初始化。</p><p>静态库是一个打包的目标模块文件。</p><p>链接器如何使用静态库解析？<br>链接器从左到右，按照命令行出现顺序扫描目标文件和存档文件。维持一个可重定位目标文件的集合E，一个未解析的符号集合U，一个前面输入文件中已经定义的而符号集合D。初始都为空。<br>对于每个输入文件，如果是目标文件，那么链接器把f添加到E，修改U和D。如果是存档文件，那么尝试匹配U中未解析的符号和有存档文件成员定义的符号。如果存档文件成员m定义了一个符号来解析U中的引用，那么m加到E中，并修改U和D反映m中的符号和引用。对存档文件中所有目标文件反复进行这个过程，直到U和D都不再发生变化。如果链接器完成所有文件扫描后，U是空的，那么会合并和重定位E中的目标文件，构建执行文件。</p><p>所以对库的位置很重要，如果有相互依赖的，有的库要重新在makefile出现两次。</p><p>共享库是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，运行时。可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。动态链接。<br>共享库也叫共享目标，unix为.so文件，windows为dll文件。</p><p>-fPIC指示编译器生成与位置无关的代码。-shared指示链接器创建一个共享的目标文件。</p><p>可以使用dlfcn.h中的dlopen，dlsym,dlclose,dlerror对共享库进行操作，应用程序。</p><p>ar,strings,strip,nm,size,readelf,objdump,ldd都是分析目标文件的工具。</p><p><strong>都为静态链接库,有同名函数参与情况下,链接会出现符号多次定义的错误!</strong></p><p><strong>若都为动态库,并且进行隐式调用,输出结果和动态库的顺序有关.</strong></p><p><strong>动态链接库如果不加库连选项 ,函数调用是正确的 加库路径,会以库的路径顺序为主! 左边覆盖右边. 而且当只链接其中一个时 也生效</strong></p><p><strong>在有静态和动态时，不把动态库库名显示加入编译选项,输出是正常的,如果加进去以静态库为主和link顺序无关！！</strong></p><h2 id="深析静态链接库和动态链接库相同函数覆盖及库调用顺序问题"><a href="#深析静态链接库和动态链接库相同函数覆盖及库调用顺序问题" class="headerlink" title="深析静态链接库和动态链接库相同函数覆盖及库调用顺序问题"></a><a href="http://www.crazyshell.org/blog/?p=619">深析静态链接库和动态链接库相同函数覆盖及库调用顺序问题</a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;从第三到第六章，对系统硬件层面讲述的比较多，于平时工作的范围联系不是很大，另外硬件方面的内容也需要再结合其他书籍再写笔记最好。所以只是把三到六章大概的读了以下，后面再补充详细的笔记。本次写的是第七章——链接。&lt;/p&gt;
&lt;p&gt;现代操作系统抽象得最好的地方：程序执行时，就像自己单独使用所有的cpu，单独地占用系统的所有内存。使应用程序的开发变得简单，不必局限于底层的硬件类型来进行实现。&lt;/p&gt;
&lt;p&gt;链接是将各种代码和数据部分收集起来，并组合成一个单一文件的过程。组合成单一的二进制bin文件，可以被加载到存储器执行。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>如何提高工作效率</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-02-how-to-improve-the-work-efficiency/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-02-how-to-improve-the-work-efficiency/</id>
    <published>2012-12-02T06:46:12.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>近期工作比较忙，在忙碌之余，闲暇思考，又有了些许新的体会，做到这些，工作效率又会提高到一个新的台阶。</p><h4 id="多记录收集，不遗漏工作点"><a href="#多记录收集，不遗漏工作点" class="headerlink" title="多记录收集，不遗漏工作点"></a>多记录收集，不遗漏工作点</h4><p>记得上学的时候，觉得PDA这些东西都没有什么用途，根本不用记录，有脑子就行了，什么事情都能在脑子里记住。刚工作的时候也用脑子记。后来发先“记性不好了”，好多事情会忘记。其实是事情太多了，杂事太多了，处理的问题复杂度也远超过了大学的课表。所以拥有个笔记本，或者记录到txt。需要对于分配的任务都有个记录，有个todolist来把todo的东西记住。觉得工具用什么不重要，工具是提高效率，主要的还是要记录。从前用过evernote和onenote，都觉得太重了，有的时候依赖太多，想携带不方便；也用过todolist软件，不过不会用，研究半天放弃了。</p><p>现在是开会记录到实体本子上，回去整理到电脑的word文档中，在word文档里记录，如果定时用foxmail的邮箱定时。看上去很土，没有软件功能强大，不过这方面暂时没时间探索，如果有人知道，可以推荐给我。</p><h4 id="确定优先级，和解决方法，逐个击破"><a href="#确定优先级，和解决方法，逐个击破" class="headerlink" title="确定优先级，和解决方法，逐个击破"></a>确定优先级，和解决方法，逐个击破</h4><p>任务收集后要区分优先级，不是来个就做的。随着处理的问题越来越复杂，精力也没从前充沛（刚上班每天10点钟，一周上七天都不累）。事情是做不完的，要分优先级来做，这样才会井井有条，也让依赖你的人有个数，不会成为瓶颈。</p><p>对于收集的事情，要先鉴定是否可以做，如果可以做大体要怎么做。难的是不知道能否做的，要做调研的，要先分配好调研的时间后才做。</p><h4 id="任务分解，大问题划分成小问题"><a href="#任务分解，大问题划分成小问题" class="headerlink" title="任务分解，大问题划分成小问题"></a>任务分解，大问题划分成小问题</h4><p>对于任务要会分解，能并行的要并行，可以和同事并发处理。如果都自己来搞定，可能要很久，但是多个人一起就方便了。就像算法里的递归分解一样。</p><h4 id="定期整理，不要积压"><a href="#定期整理，不要积压" class="headerlink" title="定期整理，不要积压"></a>定期整理，不要积压</h4><p>任务做完了要从todolist里删掉，做不了的也标记下给删掉。邮件要整理，归档。桌面也不要乱乱的，总之要整理，完成一件整理一件。还有总结，都不要拖，拖到最后要不也做，花费更多精力；要不不做，对于工作是不利的。所以建议每天都整理好，这点我做的也不好，要提高。</p><h4 id="学会做减法"><a href="#学会做减法" class="headerlink" title="学会做减法"></a>学会做减法</h4><p>有好多东西要学习，工具要学习，事情要知道，工作要做。真的都要做吗，慢慢地发现精力不够了，时间也不够。都是在做加法，要多做多学，可是有没有想想呢，做这些是为什么，要现在做吗？现在的原则：三个月内用不到，不着急的事情都放一放，真是连收集的资料和书都放到一个角落，或者干脆删掉，等到时再捞起也行。否则一直在心头萦绕，还干扰实现。搜索到需要内容的速度也是工作效率提升的关键。</p><p>做到以上几点，对于工作确实会有提升，不过要一直做到养成习惯还不易，要多多实践还要多总结优化才行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期工作比较忙，在忙碌之余，闲暇思考，又有了些许新的体会，做到这些，工作效率又会提高到一个新的台阶。&lt;/p&gt;
&lt;h4 id=&quot;多记录收集，不遗漏工作点&quot;&gt;&lt;a href=&quot;#多记录收集，不遗漏工作点&quot; class=&quot;headerlink&quot; title=&quot;多记录收集，不遗漏工</summary>
      
    
    
    
    <category term="技巧" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>screen命令使用</title>
    <link href="https://yunpengzhang.github.io/2012/2012-12-02-screen-command/"/>
    <id>https://yunpengzhang.github.io/2012/2012-12-02-screen-command/</id>
    <published>2012-12-02T06:08:36.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>screen是一个比较好用的工具，用来管理会话，登录多台主机非常有用。在联调时，一个窗口抓包，另外一个窗口执行程序看log等非常方便，开发的时候多个窗口切换也应对自如。</p><p>参考：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/">linux 技巧：使用 screen 管理你的远程会话</a></p><p>用man看screen好长，暂时就用用得上的，其他的等需要的时候再查，工具主要还是要多用才行，一部分用熟练了再多学习，否则看了一堆也忘得快。</p><p>常用快捷键：</p><p>C-a ? 显示所有键绑定信息<br>C-a w 显示所有窗口列表<br>C-a C-a 切换到之前显示的窗口<br>C-a c 创建一个新的运行shell的窗口并切换到该窗口<br>C-a n 切换到下一个窗口<br>C-a p 切换到前一个窗口(与C-a n相对)<br>C-a 0..9 切换到窗口0..9<br>C-a a 发送 C-a到当前窗口<br>C-a d 暂时断开screen会话<br>C-a k 杀掉当前窗口<br>C-a [ 进入拷贝&#x2F;回滚模式</p><p>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</p><p>-S &lt;作业名称&gt; 　指定screen作业的名称。</p><p>-d -m 启动一个开始就处于断开模式的会话<br>-r sessionowner&#x2F; [pid.tty.host] 重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限<br>-S sessionname 创建screen会话时为会话指定一个名字<br>-v 显示screen版本信息<br>-wipe [match] 同-list，但删掉那些无法连接的会话</p><p>.screen配置文件，主要解决了终端配色和乱码问题，看起来还比较顺眼。</p><pre><code>#显示256颜色attrcolor b &quot;.I&quot;    # 允许加粗色彩--由于某些原因是必须的termcapinfo xterm &#39;Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm&#39;   # 告诉screen如何设置颜色。AB 指背景，AF 指前景defbce on    # 使用当前背景色来显示删除的字符encoding UTF-8altscreen onattrcolor b &quot;.I&quot;defbce &quot;on&quot;vbell offstartup_message offdefscrollback 5000bufferfile &quot;$HOME/.screen/exchange&quot;hardcopydir &quot;$HOME/.screen/hardcopy&quot;sorendition dYhardstatus alwayslastlinesorendition dYhardstatus offhardstatus alwayslastlinehardstatus string &#39;%&#123;= kG&#125;[ %&#123;G&#125;%H %&#123;g&#125;][%= %&#123;= kw&#125;%?%-Lw%?%&#123;r&#125;(%&#123;W&#125;%n*%f%t%?(%u)%?%&#123;r&#125;)%&#123;w&#125;%?%+Lw%?%?%= %&#123;g&#125;][%&#123;B&#125; %m-%d %&#123;W&#125; %c %&#123;g&#125;]&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;screen是一个比较好用的工具，用来管理会话，登录多台主机非常有用。在联调时，一个窗口抓包，另外一个窗口执行程序看log等非常方便，开发的时候多个窗口切换也应对自如。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.ibm.com/developerworks</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】悠着点，慢着点 ——“贫富与欲望”漫谈 </title>
    <link href="https://yunpengzhang.github.io/2012/2012-11-11-switch-too-hard-hold-point-wealth-and-desire-talk/"/>
    <id>https://yunpengzhang.github.io/2012/2012-11-11-switch-too-hard-hold-point-wealth-and-desire-talk/</id>
    <published>2012-11-11T02:35:20.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>莫言&#x2F;文</p><p>我们应该用我们的文学作品向人们传达许多最基本的道理：譬如房子是盖来住的，不是用来炒的；如果房子盖了不住，那房子就不是房子。我们要让人们记起来，在人类没有发明空调之前，热死的人并不比现在多。在人类没有发明电灯前，近视眼远比现在少。在没有电视前，人们的业余时间照样很丰富。有了网络后，人们的头脑里并没有比从前储存更多的有用信息；没有网络前，傻瓜似乎比现在少。我们要通过文学作品让人们知道，交通的便捷使人们失去了旅游的快乐，通讯的快捷使人们失去了通信的幸福，食物的过剩使人们失去了吃的滋味，性的易得使人们失去恋爱的能力。我们要通过文学作品告诉人们，没有必要用那么快的速度发展，没有必要让动物和植物长得那么快，因为动物和植物长得快了就不好吃，就没有营养，就含有激素和其它毒药。我们要通过文学作品告诉人们，在资本、贪欲、权势刺激下的科学的病态发展，已经使人类生活丧失了许多情趣且充满了危机，我们要通过文学作品告诉人们，悠着点，慢着点，十分聪明用五分，留下五分给子孙。<span id="more"></span><br>一篇小文，哲理浅浅。但发人深省。尤其对上点年岁的人，须解其味。把苹果弄到四五千元一个的乔布斯可以说是无所不能，但是在病痛面前却是无能为力的！乔氏西去，敬告各位：<br>1、别总是在压力下工作，累坏了自己，特傻！<br>2、别忘了身体是一切，没有了健康，无法享用人生所有的乐趣，特亏！<br>3、别以为能救命的是医生，其实是你自己，养生重于救命，特对！<br>4、别以为付出就有回报，凡事只有不计回报，才能终有好报，特灵！<br>5、别忽视了与你有缘者，等繁华落尽，你才明白知音难觅，特悔！<br>顺其自然的工作吧！慢慢享受生活，快乐享受人生每一天！</p><p>多年前我跟一位同学谈话。那时他太太刚去世不久，他告诉我说，他在整理他太太的东西的时候，发现了一条丝质的围巾，那是他们去纽约旅游时，在一家名牌店买的。那是一条雅致、漂亮的名牌围巾，高昂的价格卷标还挂在上面，他太太一直舍不得用，她想等一个特殊的日子才用。讲到这里，他停住了，我也没接话，好一会儿后他说：“<strong>再也不要把好东西留到特别的日子才用，你活着的每一天都是特别的日子。”</strong><br>   以后，每当想起这几句话时，我常会把手边的杂事放下，找一本小说，打开音响，躺在沙发上，抓住一些自己的时间。我会从落地窗欣赏淡水河的景色，不去管玻璃上的灰尘，我会拉着家人到外面去吃饭，不管家里的饭菜该怎么处理。生活应当是我们珍惜的一种经验，而不是要捱过去的日子。<br>我曾将这段谈话与一位女士分享。后来见面时，她告诉我她现在已不像从前那样，把美丽的瓷具放在酒柜里了。以前她也以为要留到特别的日子才拿出来用，后来发现那一天从未到来。“将来”、“总有一天”已经不存在于她的字典里了。如果有什么值得高兴的事，有什么得意的事，她现在就要听到，就要看到。<br>我们常想跟老朋友聚一聚，但总是说“找机会”。<br>我们常想拥抱一下已经长大的小孩，但总是等适当的时机。<br>我们常想写信给另外一半，表达浓郁的情意，或者想让他知道你很佩服他，但总是告诉自己不急。<br>其实每天早上我们睁开眼睛时，都要告诉自己这是特别的一天。每一天，每一分钟都是那么可贵。<br>有人说：你该尽情地跳舞，好像没有人看一样。<br>你该尽情地爱人，好像从来不会受伤害一样。<br>我也要尽情地跳舞，尽情地爱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;莫言&amp;#x2F;文&lt;/p&gt;
&lt;p&gt;我们应该用我们的文学作品向人们传达许多最基本的道理：譬如房子是盖来住的，不是用来炒的；如果房子盖了不住，那房子就不是房子。我们要让人们记起来，在人类没有发明空调之前，热死的人并不比现在多。在人类没有发明电灯前，近视眼远比现在少。在没有电视前，人们的业余时间照样很丰富。有了网络后，人们的头脑里并没有比从前储存更多的有用信息；没有网络前，傻瓜似乎比现在少。我们要通过文学作品让人们知道，交通的便捷使人们失去了旅游的快乐，通讯的快捷使人们失去了通信的幸福，食物的过剩使人们失去了吃的滋味，性的易得使人们失去恋爱的能力。我们要通过文学作品告诉人们，没有必要用那么快的速度发展，没有必要让动物和植物长得那么快，因为动物和植物长得快了就不好吃，就没有营养，就含有激素和其它毒药。我们要通过文学作品告诉人们，在资本、贪欲、权势刺激下的科学的病态发展，已经使人类生活丧失了许多情趣且充满了危机，我们要通过文学作品告诉人们，悠着点，慢着点，十分聪明用五分，留下五分给子孙。</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>PM总结（二）</title>
    <link href="https://yunpengzhang.github.io/2012/2012-11-06-pm-summary-two/"/>
    <id>https://yunpengzhang.github.io/2012/2012-11-06-pm-summary-two/</id>
    <published>2012-11-06T06:46:14.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>会议控制</p><p>作为PM经常会主持一些会议，例如：项目启动会、项目总结会、晨会、体验项目会。。。在会议中也是有很多需要注意的。</p><p>要明确会议的目的，事先对会议有所准备。想好会议要传达什么事情，得出什么结论。每个人在会议中担任什么角色。一定要事先有准备，有备而来。不要到现场现准备。</p><span id="more"></span><p>会议时间控制好，要确定会议开的时间，不要超时，每个环节多长不让大家分散。</p><p>需求裁剪</p><p>对于需求要进行裁剪，分成优先级，哪些该做哪些不该做都心中有数。不能累死团队，好钢用在刀刃上。</p><p>风险管理</p><p>项目延期，似乎在互联网企业里是个很平常的事。如果哪个项目真的很正常，那真是烧了高香了。一般开发人员会同时处理多件事，有时产品们又加了新的需求，竞争对手有了新的变化我们也要变，老板用了提出了新的意见。。。</p><p>可变因素很多，所以作为产品经理要时刻给自己的项目把脉，确认他是否健康。发现有风险的苗头要即使制止。看有什么方法停住。即使已经发生也不怕，要思考能不能再发生，不能两次都掉到一个坑里。例如有的开发没开发完，那是不是要换人，还是他的事情太多要找leader反馈下。</p><p>把控住权利</p><p>在给开发人员排期的时候，不要说你说多久就多久，那pm是干什么的，什么都听你们的还用pm干啥，找个闹钟不就行了。pm要从产品上线的角度给开发人员们定日期，再询问是否有问题，什么问题，再去解决。这就要求pm要有大局观，能够对技术也有些了解，至少知道这个东西要多少工作量，不知道可以找开发来调查，总是权利要把控在自己的手中，不能什么都放手。有的时候也不能过渡的“可怜”别人。你要帮他减少干扰，而不是让他不干活。</p><p>目标控制</p><p>项目做到中间，很多时候就会掉进某个需求里。要清醒头脑，知道自己到底是要的什么，什么东西才是你最key的东西，一切都围绕着目标来进行。因为最后是否产品成功也是来衡量你做的和定的目标的吻合度。另外锦上添花的前提是把锦给织出来。</p><p>打破焦虑克服拖延症</p><p>有时事情很多，容易焦虑，好像都是困难都无从下手。</p><p>有个好方法，把你焦虑的事情都写下来，你到底在焦虑什么。然后再把目标写出来，两者对比下，看哪些是和目标有关的，哪些是现在不用在意的焦虑。</p><p>确定下和结果有关的事情后，接下来就是解决。针对每种焦虑的事情写出什么事情完成后你就会不焦虑，最后再写出要实现这些东西要做哪些具体的事情。</p><p>总结起来就是先发现问题，找出问题，然后再写出解决方案。所有的难题都有了解决方案后，在实现之前还要做的一件事就是定优先级。要事优先。如果你分不清哪个重要呢，做最难的那个。通常最难的也是最重要的。</p><p>当然，上面所有总结的都不是银弹，要做个合格的pm要会融会贯通，能够见机行事，就像一个音乐指挥家，没有一个完完全全的套路让你按部就班。多总结，多实践，不怕困哪迎难而上，最终磨练成为一个优秀项目经理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;会议控制&lt;/p&gt;
&lt;p&gt;作为PM经常会主持一些会议，例如：项目启动会、项目总结会、晨会、体验项目会。。。在会议中也是有很多需要注意的。&lt;/p&gt;
&lt;p&gt;要明确会议的目的，事先对会议有所准备。想好会议要传达什么事情，得出什么结论。每个人在会议中担任什么角色。一定要事先有准备，有备而来。不要到现场现准备。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://yunpengzhang.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统读书笔记 1</title>
    <link href="https://yunpengzhang.github.io/2012/2012-10-28-in-depth-understanding-of-computer-systems-study-notes-a/"/>
    <id>https://yunpengzhang.github.io/2012/2012-10-28-in-depth-understanding-of-computer-systems-study-notes-a/</id>
    <published>2012-10-28T05:41:49.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>第二章 信息的表示和处理<br>C++和C使用相同的数字表示和运算，java使用了全新的一套，用类来表示普通的数字。<br>8位的块，字节是最小的可寻址的存储器单位。<br>机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器。<br>所有可能地址的集合称为虚拟地址空间。<br>16进制的数字表示</p><span id="more"></span>计算机都有一个字长，指明整数和指针数据的标称大小。（以前32位字长机器比较多，现在正过度到64位字长机器）<p>32位机器限制虚拟地址空间最大位4G。</p><p>小端：最低有效字节在最前面的存储方法。<br>大端：最高有效字节在最前面的方式。——网络序</p><p>应用程序强烈不推荐似乎用强制类型转换，但是在系统级编程来说是非常有用，甚至是必须的。</p><p>typedef来命名数据类型可以改善代码的可读性。</p><p>sizeof运算符来确定对象使用的字节数。方便可移植。</p><p>程序仅仅是字节的序列。机器没有关于原始程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p><p>布尔代数和环</p><p>使用异或方式的交换在性能上没有任何优势。</p><p>使用位运算方便移植，不假定机器的位长。</p><p>对于移位运算，移位量应该是0～n-1之间的值，n是机器的字长。</p><p>右移有两种：算数右移左端补0；逻辑右移左端补最高有效位的拷贝。C标准没有明确定义应该使用哪种类型的右移。实际上大多数对有符号整数都使用算数右移。</p><p>C整数表示使用二进制补码编码方式。但C标准并没有要求要用二进制补码形式来表示有符号整数，实际上都是这么做的。<br>C库中的&lt;limits.h&gt;定义了一组常量，来限定数据范围INT_MAX,INT_MIN,UINT_MAX。<br>要创建一个无符号常量，必须加上后缀字符U或者u。</p><p>有符号到无符号数的隐式转换导致一些程序错误，而且不易发觉。java就不支持无符号整数。</p><p>GCC使用12个字节表示long double（10个字节就够用）</p><p>浮点寄存器使用特殊的80位的扩展精度存储浮点数，比存储器中的值所使用的普通32位单精度和64位双精度更准确。<br>但是使用-O2编译优化，有时使用寄存器和存储器对于相同值也是不一样的，要在编译选项使用 -ffloat-store来调用gcc，<br>每个浮点计算结果在试用期那都必须从存储到存储器中，再读回来。但是在有时直接计算比较时还是不准确。<br>另外一种解决方法就是使用long double类型，但是也是有代价的。</p><p>必须非常小心地使用浮点运算，因为浮点运算的范围和精度有限，而且浮点运算并不遵循普遍的算数属性，比如结合性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二章 信息的表示和处理&lt;br&gt;C++和C使用相同的数字表示和运算，java使用了全新的一套，用类来表示普通的数字。&lt;br&gt;8位的块，字节是最小的可寻址的存储器单位。&lt;br&gt;机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器。&lt;br&gt;所有可能地址的集合称为虚拟地址空间。&lt;br&gt;16进制的数字表示&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>PM总结（1）</title>
    <link href="https://yunpengzhang.github.io/2012/2012-10-25-pm-conclusion-1/"/>
    <id>https://yunpengzhang.github.io/2012/2012-10-25-pm-conclusion-1/</id>
    <published>2012-10-25T04:37:04.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>在[去年带项目]之后又带了一个项目，开始以为有了一定经验一切都能搞定了，不过发现又上了一课。还是有很多需要提高的，遇到了新的问题，而且还应该有要以后遇到的，先总结下现阶段，为以后做些积累。<span id="more"></span></p><h4 id="内控性"><a href="#内控性" class="headerlink" title="内控性"></a>内控性</h4><p>对于项目要有内控性，对自己要有信心，既然是PM就要对整个项目负责。是整个项目的总指挥，在项目质量和需求功能、进度上不能有半点马虎。在技术能达到的情况下，必须要保质保量让成员把事情完成。就事论事，不好就是不好，好就是好，把问题和榜样都摆出来，不要想太多。作为PM要严格把握项目进度，我就是项目的负责人，当然要对项目负责，一切对项目好的都要做，不好的都别做。跟项目没关的东西就不要出现在项目里。</p><h4 id="记住目标"><a href="#记住目标" class="headerlink" title="记住目标"></a>记住目标</h4><p>项目的目标是什么，做完了项目是什么样子，一定要一直心里有数。有时会是个笼统的说法，说明项目初期对项目没有深入了解，那么就要在项目过程中即使总结，制定完成最终目标还需要做什么，把每个小点都划分完，落实到人，然后让大家一一实现。当然，我觉得这么做是有问题的，PM不应该靠自己一个人给大家划分任务和跟项目，好的PM应该是调动大家，在大方向上把握好，调动项目成员来处理一个个问题。告诉你目标就是你把这个模块完成后发布，至于怎么开发，如何申请机器，要不要搭新环境，那时具体负责人要考虑的问题。不应该由PM做完规划让他实现，除非是有资源问题，需要PM来协调。但是现实总是残酷的，有时给你干活的人不care这个项目的，积极性没那么高，还有的成员经验就不行，什么都不知道，需要人指导才能做事；另外就是有的人工作态度不行，但也要将就着用，只有你多把关了。总之，理想条件都是好的，真正实施起来还是有很多困难等着的。</p><h4 id="抓紧进度，及时暴露问题"><a href="#抓紧进度，及时暴露问题" class="headerlink" title="抓紧进度，及时暴露问题"></a>抓紧进度，及时暴露问题</h4><p>每天都要按时开晨会，不是形势，而是要检查大家的项目进度，把风险降到最低。晨会应该让大家都爱参加才可以，如果一直一个人主持会很累，而且有的项目成员会有怨言，现象是每天开完都觉得放松。可以试着让项目成员轮流主持，一来让他们也感受下当PM检查别人工作的快感，另外也让他们知道PM也不容易；更多的是大家多交流，不只是项目，让大家也通过项目多多认知了解。</p><p>对于有不能全力投入的成员要即使发现，弄清原因，必要时要上升甚至换人。</p><h4 id="把握大局，保证产品顺利出生"><a href="#把握大局，保证产品顺利出生" class="headerlink" title="把握大局，保证产品顺利出生"></a>把握大局，保证产品顺利出生</h4><p>有时产品会提出很多需求，这些需求不对吗，对，而且做了会更好。但是你的人就这么多，时间就这么多，要学会做减法，不能啥都做，否则几天改明天改，总也产不出来，项目还一直延期，那就不好了。就好像一个人很饿，那就先给他吃点饼干，再做饭也不迟。别一上来就去买菜要弄个满汉全席，等做好了人都饿死了。</p><p>————————————————分割线———————————————</p><p>除了对PM这个工作的总结，还有观察别人的工作。</p><p>我们要如何工作呢？</p><p>对工作要有热情，要积极主动。工作一段时间后，在一个工作岗位上，可以说大家的水平差不太多，起码对于日常的工作开发上都能完成任务。那为什么会有的人绩效好，有的人不行呢？主要还是要对工作的态度，要积极主动。你的热情别人是能感受到的，你给别人传递的都是积极的态度，那么别人也会收到感染，更喜欢你工作的方式。每天热情也不高，工作敷衍，让做什么只做什么，那么你就是台machine，没有人喜欢和机器打交道。做事情要多想，积极些，别人让你做个后台，如果你能做很多监控和日志，那虽然不是必须，但是会看出是有心之人，以后运维也方便。</p><p>合作要有同理心。别人和在IM里说个任务，应答下不会死的，能做就做，不能做就不做，别缩着头，别人也不知道你什么意思。问什么都不知道，我知道你不知道，就是让你去查啊，你说不知道让我搞吗？</p><p>世界之大，什么事情都有啊，当PM有时真心觉得困难啊？</p><p>现在觉得能安心写代码真是轻松啊，当PM特别是二把刀的PM还有很长的路要走。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在[去年带项目]之后又带了一个项目，开始以为有了一定经验一切都能搞定了，不过发现又上了一课。还是有很多需要提高的，遇到了新的问题，而且还应该有要以后遇到的，先总结下现阶段，为以后做些积累。</summary>
    
    
    
    <category term="学习" scheme="https://yunpengzhang.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>关于健康</title>
    <link href="https://yunpengzhang.github.io/2012/2012-10-21-about-health/"/>
    <id>https://yunpengzhang.github.io/2012/2012-10-21-about-health/</id>
    <published>2012-10-21T05:30:23.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="http://yunpengzhang.com/articles/39.html">工作一年感悟</a>》中就说过，最终的要是健康。只有身体是最终的本钱，在身体面前，别的都可以放一放。</p><p>如果发现身体有问题了，再急的工作都可以放到一边，看的很重的事情也马上就可以放到脑后，很多觉得有时间的事情也变成了立即去办。</p><p>要保护好身体，保持健康。</p><p>上班每天都在家和办公室之间来回，基本上一座就是一天，没有什么运动。前几天看过一篇文章《坐的越久，死的越快》也是有道理了。要多运动，能走动就多走动下。有的人说，我忙啊，哪有时间。其实运动花不了我们多少时间，办公室坐一小时打杯水，走一下，不算什么，周末爬个山，打个篮球，看起来是多花了点时间，实际对是节省时间。不生病能生多少时间和金钱啊，另外运动的过程也能激发思考。</p><p>不挑食，少吃垃圾食品，少熬夜。健康啊，年轻人不在乎，老人珍惜，不过等老了有点晚了。</p><p>认清楚什么才是最重要的事情，不要浪费时间。</p><p>生命有限，时间有限。在有限的时间做自己追求的事情，你的目标是什么，你想干什么，像乔布斯说的那样，把每天都当成最后一天，这样就明确了。人喜欢拖延和逃避，很多人会说，那我现在不干这个干什么，我要积累。你是真的积累吗，还是在逃？</p><p>这些思考源于去医院的体检。每次体检都希望身体没有问题，但是我们关注自己身体多少呢？从现在开始，关注健康吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在《&lt;a href=&quot;http://yunpengzhang.com/articles/39.html&quot;&gt;工作一年感悟&lt;/a&gt;》中就说过，最终的要是健康。只有身体是最终的本钱，在身体面前，别的都可以放一放。&lt;/p&gt;
&lt;p&gt;如果发现身体有问题了，再急的工作都可以放到一边，看的</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>警惕：函数被定义或声明前被调用</title>
    <link href="https://yunpengzhang.github.io/2012/2012-10-13-vigilance-the-function-is-defined-or-declared-before-being-called/"/>
    <id>https://yunpengzhang.github.io/2012/2012-10-13-vigilance-the-function-is-defined-or-declared-before-being-called/</id>
    <published>2012-10-13T07:15:24.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个函数在被定义或声明前被调用，那么返回类型就默认为整型！有时会产生预想不到的结果，而且很难发现错误。</p><p>在编译C程序时要加如-Wall选项，不要放过一个warning，调用的函数要引用相应的头文件，在头文件中有函数声明。</p><p>最好是加上-Werror选项，要保持代码没warning。</p><span id="more"></span><p>cal.h内容</p><pre><code>#ifndef _CAL_H_#define _CAL_H_#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;uint64_t calfunc(uint64_t x);#endif</code></pre><p>cal.c内容</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;#include &quot;cal.h&quot;uint64_t calfunc(uint64_t x)&#123;    uint64_t ret = x * 1000000;    return ret;&#125;</code></pre><p>main.c</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;/*#include &quot;cal.h&quot;*/int main(int argc, char **argv)&#123;    uint64_t x = 12345678912345;    uint64_t ret = calfunc(x);    printf(&quot;ret = %llu\n&quot;, ret);    return 0;&#125;</code></pre><p>如果包含cal.h文件，执行正常，打印</p><p>ret &#x3D; 12345678912345000000</p><p>否则打印</p><p>ret &#x3D; 18446744071584794688</p><p>因为0xab54a98f815ac840在返回的时候当作int返回，被截断然后复制为0xffffffff815ac840</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果一个函数在被定义或声明前被调用，那么返回类型就默认为整型！有时会产生预想不到的结果，而且很难发现错误。&lt;/p&gt;
&lt;p&gt;在编译C程序时要加如-Wall选项，不要放过一个warning，调用的函数要引用相应的头文件，在头文件中有函数声明。&lt;/p&gt;
&lt;p&gt;最好是加上-Werror选项，要保持代码没warning。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言使用inline函数</title>
    <link href="https://yunpengzhang.github.io/2012/2012-10-13-c-language-using-inline-functions/"/>
    <id>https://yunpengzhang.github.io/2012/2012-10-13-c-language-using-inline-functions/</id>
    <published>2012-10-13T05:11:40.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>在C语言中定义inline函数，如果有多个文件包含并在一起用gcc编译会出现重复定义的错误，但是使用g++则不会。先上代码展示问题。<span id="more"></span></p><p>在inline.c和inlin.h中定义usefunc函数，调用了inline的func函数，相当于写了一个库函数，供main.c调用。</p><pre><code>#ifndef _CINLINE_H_#define _CINLINE_H_#include &lt;stdio.h&gt;int usefunc(int x);//static inline int func(int x)inline int func(int x)&#123;    printf(&quot;in func x = %d\n&quot;, x);    return 0;&#125;#endif#include &lt;stdio.h&gt;#include &quot;cinline.h&quot;int usefunc(int x)&#123;    printf(&quot;in usefunc x=%d\n&quot;, x);    func(x);    return 0;&#125;#include &lt;stdio.h&gt;#include &quot;cinline.h&quot;int main(int argc, char **argv)&#123;    usefunc(10);    return 0;&#125;</code></pre><p>编译函数结果报错显示重复定义。</p><pre><code>multiple definition of `func&#39;main.o:cinline.h:6: first defined herecollect2: ld returned 1 exit statusmake: *** [main] 错误 1</code></pre><p>修改方法：</p><p>1.把inlin.h中的inline改为static函数即编译正常显示结果</p><p>2.改用g++进行编译</p><blockquote><p>in usefunc x&#x3D;10</p></blockquote><p>in func x &#x3D; 10</p><p>为什么g++可以而gcc不行？</p><p>因为g++和gcc对inline的支持不一样，在g++中是按照C++的标准来支持inline函数的：“直接嵌套汇编代码，取代函数调用，提高效率。”</p><p>而gcc对inline的支持则有不同。</p><p><strong>c99标准</strong></p><p>inline ：用于同一c&#x2F;cpp文件内部被调用处展开；对外部文件来说函数不可用 static inline ：用于在同一c&#x2F;cpp文件内部被调用处展开；一般情况下，编译器并不会为此函数生成单独的目标代码；如遇到内联函数无法展开，或内联函数以地址形式被调用，则编译器将会为此内联函数生成单独的代码；</p><p>简单地说，c99中inline关键字申明的函数一般仅用于同一文件，函数本身不会生成单独的目标代码；static关键字修订后，如果需要，则会生成单独的目标代码。</p><p><strong>gcc</strong></p><p>inline ：对同一c&#x2F;cpp文件，函数将会在被调用处展开；对外部文件，此函数等同于”extern”函数 static inline ：与c99标准中相同 extern inline : 仅用于同一c&#x2F;c++文件内部，在被调用处展开</p><p>gcc中的inline关键字与c99中不同，默认情况下(仅使用inline)，在同一文件中被调用处当作内联函数展开，而在外部文件调用中等同于普通extern函数(也就是说会生成单独的目标代码)；加static关键字修订后，反而不可应用于外部文件，但如果需要可以生成单独的目标代码；gcc扩展的extern inline模式更是缩小函数的使用仅限于在同文件中展开。</p><p>gcc对C语言的inline做了自己的扩展，其行为与C99标准中的inline有较大的不同。</p><p>相对于C99的inline来说，GCC的inline更容易理解：可以认为它是一个普通全局函数加上了inline的属性。即在其定义所在文件内，它的 表现和static inline一致：在能展开的时候会被内联展开编译。但是为了能够在文件外调用它，gcc一定会为它生成一份独立的汇编码，以便在外部进行调用。即从文件 外部看来，它和一个普通的extern的函数无异。</p><p>在main.c引用头文件的时候，相当与在头文件中定义了一个extern的函数，所以会报错。</p><p>在c语言里就不要把函数定义到头文件中了。</p><p>使用static就使函数分别在被包含的文件范围内可见。</p><p>在写程序时，尤其是写库，把外部用不到的都加上static内部自己用，宏定义也要有前缀，减少重复定义的危险。</p><p>参考：</p><p><a href="http://news.ccidnet.com/art/32859/20100712/2112675_1.html">c语言的inline</a></p><p><a href="http://www.cppblog.com/codejie/archive/2012/09/21/191508.html">Why the inline function can not be covered?</a></p><p><a href="http://www.greenend.org.uk/rjk/tech/inline.html">Inline Functions In C</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>makefile</p><pre><code>CXX = g++CC = gccTARGET = mainC_FLAGS += -g -WallLIB_FLAGS = -pthread# INC += .# LIB += all: $(TARGET)main: main.o cinline.o    $(CC) -o $@ $^ $(LIB_FLAGS) $(LIB) $(C_FLAGS).cpp.o:    $(CXX) -c -o $*.o $(INC) $(C_FLAGS) $*.cpp.c.o:    $(CC) -c -o $*.o $(INC) $(C_FLAGS) $*.cclean:    -rm -f *.o $(TARGET)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;在C语言中定义inline函数，如果有多个文件包含并在一起用gcc编译会出现重复定义的错误，但是使用g++则不会。先上代码展示问题。</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记0</title>
    <link href="https://yunpengzhang.github.io/2012/2012-09-23-in-depth-understanding-of-computer-systems-reading-notes-0/"/>
    <id>https://yunpengzhang.github.io/2012/2012-09-23-in-depth-understanding-of-computer-systems-reading-notes-0/</id>
    <published>2012-09-23T05:25:00.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要读这本书？</p><p>《深入理解计算机系统》英文名《computer system: A programmer’s perspective》。从程序员的角度来理解计算机系统。为程序员描述计算机系统的实现细节。可以对程序的整体，在计算机系统内部运行的细节都熟悉。可以开发出高效，健壮的程序，并且可以更快地排除程序错误，调整性能。以上这些对于一名程序员来说诱惑是很大的，如果只专注于应用程序的实现，而不熟悉运行在下面的系统知识，不是一个完美的programmer。<span id="more"></span></p><p>第一章《计算机系统漫游》</p><p>概述性质的一章，以“hello world”程序的生命周期，来介绍计算机系统的主要概念和主题。</p><p>计算机系统是由硬件和系统软件组成的，他们共同工作来运行应用程序。</p><p>理解计算机的本质和它如何影响你的应用程序是非常重要的。</p><p>信息是一些比特流，区分不同比特的方法是读到这些数据对象的上下文。</p><p>C语言源文件被其他程序转化为一系列的低级机器语言指令，然后按照可执行目标程序打包，以二进制文件存放起来。目标程序也就是可执行目标文件。</p><p>Hello.c 编译为hello二进制的路程为：</p><p>Hello.c   hello.i  hello.s hello.o hello</p><p>分别经历预处理阶段，编译阶段，汇编阶段，链接阶段。</p><p>知道编译系统如何工作的好处：</p><p>优化程序性能</p><p>理解链接时出现的错误</p><p>避免安全漏洞</p><p>系统的硬件组成：</p><p>总线：贯穿系统的电子管道</p><p>IO设备：每个IO设备都是通过控制器或者适配器与I&#x2F;O总线连接起来的。</p><p>主存：主存是一个临时存储设备，由一组DRAM芯片组成。</p><p>处理器：中央处理单元（CPU），是解释或执行存储在主存中指令的引擎。在任何一个时间点PC都指向主存中的某条机器语言指令。</p><p>执行hello程序的步骤：加载程序，把代码和数据拷贝到主存。处理器执行hello程序主存中的机器语言指令。把需要的字节从存储器中拷贝到寄存器堆，再从寄存器中文件拷贝到显示设备，显示到屏幕。</p><p>执行一次程序经过好几次拷贝，会把性能变慢。硬件的高速缓存存储器的机理，可以使程序员利用这些极大地提高程序的性能。</p><p>设备是分层次的，按照缓存的概念，上层的设备都可以说是下层的缓存，例如本地磁盘是其他系统磁盘的缓存。技术都是想通的，计算机底层的思想在上层应用中也有广泛的使用。就如同物理中的宏观微观，他们都有着类似的原理。</p><p>操作系统主要由两个用途：1.防止硬件被失控的应用程序滥用2.在控制复杂而又通常广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。</p><p>进程是操作系统对运行程序的一种抽象。</p><p>操作系统保存进程运行所需要的所有状态信息——上下文（context）</p><p>系统调用会将控制权传递给操作系统。</p><p>每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，线程一般比进程更高效。</p><p>虚拟地址空间：一个很经典的图。</p><p>基本思想：一个进程虚拟存储器的内容存储在磁盘上，用主存作为磁盘的告诉缓存。</p><p>文件：一个强大的定义，磁盘、IO设备、网络都可以抽象为文件。</p><p>本章还是概述性质，通过一个简单的程序引出众多的概念，为后面的章节铺垫。</p><p>文件是对IO设备的抽象概念；虚拟存储器是对主存和磁盘的抽象概念；进程是粗利器、主存和IO设备的抽象概念。网络也是一种IO设备。</p><p>对系统的种种抽象，都是为了解耦，抽象后可以对无限的不同的设备以统一的方式进行处理。应用程序也可以借鉴，这样程序就有了扩展性。程序员要写一个程序摧毁斯巴达，是应该写destroySparta () ，还是distroycity(Sparta)呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么要读这本书？&lt;/p&gt;
&lt;p&gt;《深入理解计算机系统》英文名《computer system: A programmer’s perspective》。从程序员的角度来理解计算机系统。为程序员描述计算机系统的实现细节。可以对程序的整体，在计算机系统内部运行的细节都熟悉。可以开发出高效，健壮的程序，并且可以更快地排除程序错误，调整性能。以上这些对于一名程序员来说诱惑是很大的，如果只专注于应用程序的实现，而不熟悉运行在下面的系统知识，不是一个完美的programmer。</summary>
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>读取文件的几个函数</title>
    <link href="https://yunpengzhang.github.io/2012/2012-09-04-several-functions-to-read-the-file/"/>
    <id>https://yunpengzhang.github.io/2012/2012-09-04-several-functions-to-read-the-file/</id>
    <published>2012-09-04T05:39:51.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://man.chinaunix.net/develop/c&c++/linux_c/default.htm">http://man.chinaunix.net/develop/c&c++/linux_c&#x2F;default.htm</a></p><p>使用场景：一个文件，一行一个号码，读取并对号码进行操作。</p><p>在c语言里，可以使用fscanf，或fgets、getline配合strtoul进行操作。</p><blockquote><p>int fscanf(FILE * stream ,const char *format,….);</p></blockquote><p>fscanf()会自参数stream的文件流中读取字符串，再根据参数format字符串来转换并格式化数据。格式转换形式请参考scanf()。转换后的结构存于对应的参数内。</p><p>调用的时候如果有非数字出现，会使程序卡住，一直在那读取。</p><blockquote><p>char * fgets(char * s,int size,FILE * stream);</p></blockquote><p>fgets()用来从参数stream所指的文件内读入字符并存到参数s所指的内存空间，直到出现换行字符、读到文件尾或是已读了size-1个字符为止，最后会加上NULL作为字符串结束。</p><p>配合strtoul使用，如果有非数字，会转化为0，需要对0进行特殊判断。</p><blockquote><p>getline函数</p></blockquote><p>#include &lt;stdio.h&gt;</p><p>ssize_t getline(char **lineptr, size_t *n, FILE *stream);</p><p>ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);</p><p>如果你给定一个非空指针，和大小，如果不满足函数内部会relloc；如果是空指针，他会给你分配空间，不过要你自己释放。</p><p>配合strtoul使用，如果有非数字，会转化为0，需要对0进行特殊判断。</p><p>大多数时候使用fgets，用数组读指定的长度进行转换，有杂质也可以过滤过去。</p><p>strtoul的返回值可能是0或ULONG_MAX但是他们都会让文件和程序继续，对于号码不会有这样的值出现，只要过滤掉就好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://man.chinaunix.net/develop/c&amp;c++/linux_c/default.htm&quot;&gt;http://man.chinaunix.net/develop/c&amp;c++/linux_c&amp;#x2F;default.htm&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>换一种思路，路更开阔</title>
    <link href="https://yunpengzhang.github.io/2012/2012-08-23-for-an-idea-the-road-is-more-open/"/>
    <id>https://yunpengzhang.github.io/2012/2012-08-23-for-an-idea-the-road-is-more-open/</id>
    <published>2012-08-22T21:14:45.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>　　以前处理的协议都是二进制的协议，会有根据字段的值不同填写不同的结构的情况。后来要做一个网页模拟打包工具，按某位的值填写好麻烦，要不停地判断填写的值然后给出各种选择。后来研究了一下protobuf协议，还想要是以后用pb这种情况怎么处理。突然发现，原来pb就不用这么处理了，因为在pb中什么字段都是用tlv方式存储的，你要添加那就写进去，如果不添加就空着。其实以前的网页也可以简单的实现，就是把所有字段都暴露给填写者，最后根据他选择填的字段再组包，虽然不优雅，也算十个取巧的方式。<br>　　<br>　　以前也一直局限于单进程模型，后来接触到RPC，觉得这东西怎么能做成异步的呢？后来才发现，原来可以用多线程实现，这样就简单许多。不过这个还是要再研究下，现在理解还不深。<br>　　<br>　　使用了微博的api，才发现原来可以这么设计api，可以这么简单。但是我们的为什么不能这么做呢？使用场景不同，网页最终端要调用和后台svr调用还是有差别的，但是还是有我们参考的，为什么他们的用着这么爽？新手上手这么快。<br>　　<br>　　通过以上两件事情发现，时间久了在技术上会产生定势思维，拿着锤子看什么都像钉子。要时不时地挑出来，多学习，借鉴其他技术，像别人多交流，才能想到更适合的方法。思路多了，发现走的路也变宽了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　以前处理的协议都是二进制的协议，会有根据字段的值不同填写不同的结构的情况。后来要做一个网页模拟打包工具，按某位的值填写好麻烦，要不停地判断填写的值然后给出各种选择。后来研究了一下protobuf协议，还想要是以后用pb这种情况怎么处理。突然发现，原来pb就不用这么处理了</summary>
      
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Google Protocol Buffer 学习</title>
    <link href="https://yunpengzhang.github.io/2012/google-protocol-buffer-learning/"/>
    <id>https://yunpengzhang.github.io/2012/google-protocol-buffer-learning/</id>
    <published>2012-08-22T09:27:34.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章 <a href="http://www.codelast.com/?p=276">Google Protocol Buffers安装、使用二三事</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章 &lt;a href=&quot;http://www.codelast.com/?p=276&quot;&gt;Google Protocol Buffers安装、使用二三事&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员杂想</title>
    <link href="https://yunpengzhang.github.io/2012/2012-07-13-miscellaneous-programmers-want/"/>
    <id>https://yunpengzhang.github.io/2012/2012-07-13-miscellaneous-programmers-want/</id>
    <published>2012-07-12T21:45:57.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>以前看过一篇关于程序员为什么很少受到尊重的一篇文章，大意是程序员之前不会互相尊重，总认为别的程序员不好。像从前一个同事说过，程序员之间就像文人，互相<img src="file:///C:\DOCUME~1\����\LOCALS~1\Temp\SGTpbq\3684\00077A10.gif">不看中。但我觉得程序员和其他职业也没有什么差别，类似发生的事情在厨师、医生……职业都会遇见。还是和具体的人有关，要转变观念，寻求一种职业的追求和素养，程序员之间才能合作愉快，创造出更大的价值。</p><span id="more"></span><h1 id="1-要谦虚"><a href="#1-要谦虚" class="headerlink" title="1.要谦虚"></a>1.要谦虚</h1><p>一般在大公司的程序员，相对来说能力都是比较强，会人觉得自己很牛。山外有山，还是要保持谦虚的精神。不可目中无人，只有自己最牛其他的人都啥也不懂，写的东西也都不好，这一点对职业的发展及其不利。要多与人请教，取长补短。</p><h1 id="2-态度要温和"><a href="#2-态度要温和" class="headerlink" title="2.态度要温和"></a>2.态度要温和</h1><p>程序员之间会合作，与人打交道的时候也很多。人不是机器，你改几行代码，重新编译下就运行了。程序的很多逻辑你自己门清，但是讲给别人会分费力。可以休息下再讲，不要不耐烦，这是与人相处之道，总要给人个台阶。也要换位思考，如果你是接程序的人会怎样，会不会心里暗暗地想，就这傻×，还不耐烦了。还有很多场景，例如太忙的时候有人请教问题，接手别人乱七八糟的代码，依赖的其他系统总有问题……发脾气对解决问题没有任何作用，还会让心心烦，要沉住气想办法才是王道。</p><h1 id="3-注重合作，尊重其他人"><a href="#3-注重合作，尊重其他人" class="headerlink" title="3.注重合作，尊重其他人"></a>3.注重合作，尊重其他人</h1><p>程序员之间的合作太多了，首先要把你的合作伙伴当做一个人，不要当做机器。要尊重他，想办法使沟通更顺畅，更好地完成工作。而不是互相推诿工作和责任。看不起对方的观点和工作。只要有人说个什么就是你想错了，这个不对那个不对的，打断别人，别人的程序出了问题冷嘲热讽。出来混迟早是要还的。太狂妄了早晚会打了自己的脸。</p><h1 id="4-责任心，追求完美"><a href="#4-责任心，追求完美" class="headerlink" title="4.责任心，追求完美"></a>4.责任心，追求完美</h1><p>程序运行的外表和编译他的代码不一定完全一样的。一个界面漂亮的应用程序，可能后面支撑的代码乱七八糟，维护起来难上加难。你是混一混就让他过去呢，还是尽量把他修改好，干干净净的代码和清晰的逻辑呢？</p><p>不想做一件事可以找一万件理由，但是想做只要一个决心。陈年代码乱上加乱，可以说重构工作量大，容易出问题。考虑到客观的条件，那我们可否在新加的代码上让逻辑清晰呢，让自己的每一行代码都很美观呢。有一个好的评价标准，你敢让你写的这段代码发到论坛或开源出去吗？很多时候程序员的代码是没人检查的，看到的都是运行的样子，写出来的软件。代码的维护和文档的完整，完全靠自己的责任心了。要有一种追求完美精益求精的职业精神，最后会有回报的。</p><p>一件事坏也是做，好也是做，为什么不做好呢？只要开始做，其实没想的那么难，主要还是人太懒的原因。</p><h1 id="5-学习进取心"><a href="#5-学习进取心" class="headerlink" title="5.学习进取心"></a>5.学习进取心</h1><p>技术发展日新月异，不可以吃老本，要有学习的进取心，不断的学习才能有提高，逆水行舟，不进则退。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前看过一篇关于程序员为什么很少受到尊重的一篇文章，大意是程序员之前不会互相尊重，总认为别的程序员不好。像从前一个同事说过，程序员之间就像文人，互相&lt;img src=&quot;file:///C:&#92;DOCUME~1&#92;����&#92;LOCALS~1&#92;Temp&#92;SGTpbq&#92;3684&#92;00077A10.gif&quot;&gt;不看中。但我觉得程序员和其他职业也没有什么差别，类似发生的事情在厨师、医生……职业都会遇见。还是和具体的人有关，要转变观念，寻求一种职业的追求和素养，程序员之间才能合作愉快，创造出更大的价值。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>时间管理</title>
    <link href="https://yunpengzhang.github.io/2012/2012-07-02-time-management/"/>
    <id>https://yunpengzhang.github.io/2012/2012-07-02-time-management/</id>
    <published>2012-07-02T05:24:23.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>如何提升定时能力：<br>1.练习判断时间。看自己到底判断的如何。<br>2.利用琐碎时间做事。一来节省时间，而来防止拖延找借口。<br>3.预防意外，提前发现风险。<br>4.委派任务。尽可能让别人帮你做你不必要做的事。<br>5.懂的事件的取舍。不要用自己一直忙来拖延时间！！！<br>6.享受自由的时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何提升定时能力：&lt;br&gt;1.练习判断时间。看自己到底判断的如何。&lt;br&gt;2.利用琐碎时间做事。一来节省时间，而来防止拖延找借口。&lt;br&gt;3.预防意外，提前发现风险。&lt;br&gt;4.委派任务。尽可能让别人帮你做你不必要做的事。&lt;br&gt;5.懂的事件的取舍。不要用自己一直忙来拖延时</summary>
      
    
    
    
    <category term="技巧" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>vim技巧之两段的尾合并</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-30-vim-tips-merger-of-two-of-the-tail/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-30-vim-tips-merger-of-two-of-the-tail/</id>
    <published>2012-06-30T05:40:51.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>在水木上看到的</p><blockquote><p>aaa<br>bbb<br>ccc<br>111<br>222<br>333</p></blockquote><p>合并成</p><blockquote></blockquote><p>aaa 111<br>bbb 222<br>ccc 333</p><p>光标放到ccc行</p><pre><code>:1,g/^/&#39;&#39;+m. | -j</code></pre><p>还不明白原理，有时间查下资料解释下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在水木上看到的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aaa&lt;br&gt;bbb&lt;br&gt;ccc&lt;br&gt;111&lt;br&gt;222&lt;br&gt;333&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;合并成&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;aaa 111&lt;br&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>linux内存分配注意事项</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-24-linux-memory-allocation-precautions/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-24-linux-memory-allocation-precautions/</id>
    <published>2012-06-24T06:08:59.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，分配内存是家常便饭，然而其中也有很多“潜规则”需要注意。</p><p>linux栈内存不要超过10M，超过会使程序崩溃，而且还不容易发现。在做应用程序时经常遇到这种情况，大家不会吝惜内存分配，可能结构体套结构体，一会就把局部内存给分满了。对于这种情况，可以分配静态变量。但是最根本的还是按需分配，对于程序要使用的内存大小和结构设计要了如指掌。<span id="more"></span></p><p>在程序中，不用频繁分配释放大内存，例如在一个循环里不停地分配然后执行完回收。</p><p>linux分配内存有两个系统调用：brk和mmap。当分配的内存小于128k时（M_MMAP_THRESHOLD控制），在.data段的_edata指针往高地址便宜相应大小，完成内存分配。如果最高地址的内存回收，并不是马上指针指向低地址紧缩，而是空闲内存达到128k（M_TRIM_THRESHOLD控制）。禁止内存紧缩也会提高程序的执行效率。可以调用以下代码实现。</p><pre><code>mallopt(M_TRIM_THRESHOLD, -1); // 禁止内存紧缩</code></pre><p>如果分配的内存大于128k时，会调用mmap在堆和栈的中间分配虚拟内存，并且分配的内存可以单独释放，不想brk分配的内存要高地址的内存释放后才能释放。用mmap调用的会进入内核态，引起缺页中断，对应用程序的效率产生影响。</p><p>可以分配静态内存来避免mmap调用，或者开始分配好一块内存减少频繁分配释放，共享内存也是一种解决方法。</p><p>在程序中调用下面代码可以不使用mmap分配内存。</p><pre><code>mallopt(M_MMAP_MAX, 0); // 禁止malloc调用mmap分配内存</code></pre><p>参考《<a href="http://blog.csdn.net/sniperhuangwei/article/details/5422016">频繁分配释放内存导致的性能问题的分析</a>》</p><p>简单的测试程序</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv)&#123;    for (int i = 0; i &lt; 150; ++i)    &#123;        char *ptr = (char *)malloc(1024 * i);    &#125;    return 0;&#125;</code></pre><p>测试程序运行用strce查看</p><pre><code>brk(0xca4000)                           = 0xca4000brk(0xce2000)                           = 0xce2000brk(0xd21000)                           = 0xd21000brk(0xd61000)                           = 0xd61000mmap(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1a9efac000mmap(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1a9ef8b000mmap(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1a9ef6a000</code></pre><p>申请的内存达到135168大约100多k的时候调用mmap申请。</p><p>至于为什么不是128k还没有找到原因，有知道的朋友可以帮忙解答下。</p><p>**用命令ps -o majflt minflt -C program来查看进程的majflt, minflt的值，这两个值都是累加值，从进程启动开始累加。在对高性能要求的程序做压力测试的时候，我们可以多关注一下这两个值。 **</p><p>参考<a href="http://bbs.csdn.net/topics/330179712">http://bbs.csdn.net/topics/330179712</a></p><h3 id="百度分享-频繁分配释放内存导致的性能问题的分析"><a href="#百度分享-频繁分配释放内存导致的性能问题的分析" class="headerlink" title="[百度分享]频繁分配释放内存导致的性能问题的分析"></a>[百度分享]频繁分配释放内存导致的性能问题的分析</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发过程中，分配内存是家常便饭，然而其中也有很多“潜规则”需要注意。&lt;/p&gt;
&lt;p&gt;linux栈内存不要超过10M，超过会使程序崩溃，而且还不容易发现。在做应用程序时经常遇到这种情况，大家不会吝惜内存分配，可能结构体套结构体，一会就把局部内存给分满了。对于这种情况，可以分配静态变量。但是最根本的还是按需分配，对于程序要使用的内存大小和结构设计要了如指掌。</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>守护进程单例运行</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-20-daemon-running-single-case/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-20-daemon-running-single-case/</id>
    <published>2012-06-20T04:00:22.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如何让守护进程单例运行？</strong></p><p>如果已经启动一个进程，再启动的进程要监控到已启动进程的状态，涉及到进程间通信。<br>如果是网络程序，可以不重用端口，发现已经绑定就不创建。<br>可以申请公共的共享内存，在共享内存中标记已经有进程启动，退出时标记回来。<br>但是上面的方法有问题，大家可以想一下。<br>常用的方法是建立一个进程文件，用文件锁锁住文件。再启动的进程发现文件锁住了，就不启动，保证进程单例运行。</p><p><strong>为什么要单例运行？</strong><br>防止两个进程使用统一资源，调度相同的逻辑引起混乱。例如crontab，两个一起调用会让任务重复执行。</p><span id="more"></span><p><strong>什么是文件锁？</strong><br>进程创建一个文件，给文件添加一把锁，只允许创建一把写锁。其他进程无法操作文件，意味着已经存活着相同的进程。当创建锁的进程终止时，锁被解除。</p><p>实现锁的方法</p><pre><code>fcntl()、lockf()、flock()int fcntl (int fd, int cmd, struct flock *lock);struct flock &#123;    ...        short l_type;    /* Type of lock: F_RDLCK,                    F_WRLCK, F_UNLCK */    short l_whence;  /* How to interpret l_start:                SEEK_SET, SEEK_CUR, SEEK_END */    off_t l_start;   /* Starting offset for lock */    off_t l_len;     /* Number of bytes to lock */    pid_t l_pid;     /* PID of process blocking our lock                (F_GETLK only) */    ...&#125;;</code></pre><p>返回errno，如果为EAGAIN或者EACCES，表示其他进程已经拥有该文件的锁，本次操作被禁止。</p><p>示例程序：</p><pre><code>    intlockfile(int fd) //~ try to lock the file, affecting errno when it fails.&#123;    struct flock fk;    fk.l_type = F_WRLCK;    fk.l_start = 0;    fk.l_whence = SEEK_SET;    fk.l_len = 0;    return (fcntl(fd, F_SETLK, &amp;fk));&#125;    intalready_running(const char* fname) //~ return 1, if another daemon is running&#123;    int fd;    fd = open(fname, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);    if( fd &lt; 0 )    &#123;        //~ in daemon process, you should use syslog, instead of stdout, for logging        //~ syslog(LOG_ERR, &quot;cannot open %s: %s&quot;, fname, strerror(errno));        fprintf(stdout, &quot;cannot open %s: %s&quot;, fname, strerror(errno));        fflush(stdout);        exit(1);    &#125;    if( lockfile(fd) &lt; 0 )    &#123;        if( errno == EACCES || errno == EAGAIN )        &#123;Linux 2.6 中的文件锁            //~ syslog(LOG_ERR, &quot;cannot lock %s: %s&quot;, fname, strerror(errno));            fprintf(stdout, &quot;cannot lock %s: %s&quot;, fname, strerror(errno));            close(fd);            return 1;        &#125;        //~ syslog(LOG_ERR, &quot;cannot lock %s: %s&quot;, fname, strerror(errno));        fprintf(stdout, &quot;cannot lock %s: %s&quot;, fname, strerror(errno));        fflush(stdout);        exit(1);    &#125;    ftruncate(fd, 0);    char buf[16];    sprintf(buf, &quot;%ld&quot;, (long)getpid());    write(fd, buf, strlen(buf) + 1);    return 0;&#125;</code></pre><p>参考：</p><p>《<a href="http://www.dutor.net/index.php/2010/09/daemon-process-singleton/">守护进程的单例运行</a>》</p><p>《<a href="http://hi.baidu.com/xioazhu/blog/item/d4e526a451f184fc9152eee9.html">守护进程的单实例实现</a>》</p><p>《<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filelock/index.html">Linux 2.6 中的文件锁</a>》</p><p>《<a href="http://apt-blog.net/unix_program_daemonize">Unix单实例后台守护进程的“规范方法”</a>》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;如何让守护进程单例运行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果已经启动一个进程，再启动的进程要监控到已启动进程的状态，涉及到进程间通信。&lt;br&gt;如果是网络程序，可以不重用端口，发现已经绑定就不创建。&lt;br&gt;可以申请公共的共享内存，在共享内存中标记已经有进程启动，退出时标记回来。&lt;br&gt;但是上面的方法有问题，大家可以想一下。&lt;br&gt;常用的方法是建立一个进程文件，用文件锁锁住文件。再启动的进程发现文件锁住了，就不启动，保证进程单例运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要单例运行？&lt;/strong&gt;&lt;br&gt;防止两个进程使用统一资源，调度相同的逻辑引起混乱。例如crontab，两个一起调用会让任务重复执行。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>daemon守护进程</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-20-daemon-daemon/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-20-daemon-daemon/</id>
    <published>2012-06-19T22:08:56.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>**　　什么是守护进程？**</p><p>守护进程（daemon）是运行在后台不属于任何终端的进程。服务类程序多为daemon进程：例如网络程序。而且多采用named的形式命名。</p><p>如何创建守护进程？</p><p>1.程序在后台执行。</p><p>fork（）进程，然后父进程退出。新的子进程脱离命令行或shell程序的控制，在后台运行，并且不再是进程组组长，为下一步setsid做准备。</p><p>2.脱离控制终端，登录会话和进程组。</p><p>进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的PID。登录会话可以包含多个进程组。他们用一个控制终端，这个终端通常是创建进程的登录终端。</p><span id="more"></span><p>控制终端，登录会话和进程组通常是从父进程继承下来的。要摆脱他们，要调用setsid（）邓伟会话组长。</p><p>setsid（）如果是进程组长调用会失败，但是第一步fork后子进程不是会话组长。调用成功后，进程成为新的组长，与原来登录会话和进程组脱离，由于会话过程对控制终端的独占性，进程同事与控制</p><p>终端脱离。</p><p>3.禁止进程重新打开控制终端。</p><p>进程成为无终端的会话组长，是可以重新申请打开一个控制终端，可以再次fork是进程不成为会话组长来禁止重新打开控制终端。</p><p>再次fork，新的子进程来执行程序。</p><p>4.关闭打开文件描述符，然后chdir(“&#x2F;“)，更改目录为根目录。</p><p>关闭从父进程继承的文件描述符，防止浪费资源和无法卸载文件系统等问题。</p><p>更换当前工作目录保证进程所在文件系统卸载后不会影响到进程正常工作。</p><p>5.重设文件掩码（可选）</p><p>可以对进程的文件进行所有操作。</p><p>umask(0)</p><p>6.处理SIGCHLD信号（可选）</p><p>如果服务器请求来时生成子进程处理请求。如果父进程不等待子进程结束，会产生僵尸进程，占用资源。但是等待子进程结束，会增加父进程负担，影响并发性能。可以使用signal(SIGCHLD,SIG_IGN);</p><p>内核在子进程结束时不会产生僵尸进程。</p><p>**　　例子程序**</p><pre><code>int main(void)&#123;/*如果本进程是从前台作为一个shell命令启动的，当父进程终止时，shell就认为该命令已经执行完毕。这样子进程就自动在后台运行。*/if ((pid =Fork())&lt;0)return -1;else if (pid)exit(0); //parent terminates//child continues/*当前进程编程新的会话的头进程以及新的进程组的进程组头进程，从而不再有控制终端。*/if (setsid()&lt;0) //become session leaderreturn -1;/*这里必须忽略SIGHUP信号，因为当会话头进程终止时，其会话中的所有进程（即再次fork产生的子进程）都会受到SIGHUP信号。*/Signal(SIGHUP, SIG_IGN);/*再次fork的目的是确保本守护进程将来即使打开了一个终端设备，也不会自动获得控制终端。当没有控制终端的一个会话头进程打开一个终端设备时，该终端自动成为这个会话头进程的控制终端。*/if ((pid = Fork())&lt;0)return -1;else if(pid)exit(0); //child 1 terminates//child 2 continues/*要是守护进程产生了某个core文件，该文件就存放在当前目录中。改变工作目录的另一个理由是，守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就无法拆卸，除非使用潜在破坏性的强制措施。*/chdir(&quot;/&quot;); //change working directory/*要是一个守护进程未打开这些描述子，却作为服务器打开了某个客户关联的一个套接口，那么这个套接口很可能占用这些描述字（譬如标准输出1、标准错误输出2），这种情况下如果守护进程调用诸如perror之类函数，那就会把非预期的数据发送给那个客户。*/for (i = 0; i &lt; MAXFD; i++) //close off file descriptorsclose(i);//redirect stdin, stdout, and stderr to /dev/nullopen(&quot;/dev/null&quot;, O_RDONLY);open(&quot;/dev/null&quot;, O_RDWR);open(&quot;/dev/null&quot;, O_RDWR);openlog(pname LOG_PID, facility);return 0;&#125;</code></pre><p>**　　备忘**</p><p>可以使用nohup在后台启动程序不受终端干扰</p><p>尽量在调用daemon_init之前不要创建socket或打开文件。</p><p>**　　参考**</p><p><a href="http://www.steve.org.uk/Reference/Unix/faq_2.html">1.7 How do I get my program to act like a daemon?</a><br><a href="http://www.360doc.com/content/11/0111/15/1317564_85756949.shtml">Linux 守护进程的编程方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;**　　什么是守护进程？**&lt;/p&gt;
&lt;p&gt;守护进程（daemon）是运行在后台不属于任何终端的进程。服务类程序多为daemon进程：例如网络程序。而且多采用named的形式命名。&lt;/p&gt;
&lt;p&gt;如何创建守护进程？&lt;/p&gt;
&lt;p&gt;1.程序在后台执行。&lt;/p&gt;
&lt;p&gt;fork（）进程，然后父进程退出。新的子进程脱离命令行或shell程序的控制，在后台运行，并且不再是进程组组长，为下一步setsid做准备。&lt;/p&gt;
&lt;p&gt;2.脱离控制终端，登录会话和进程组。&lt;/p&gt;
&lt;p&gt;进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的PID。登录会话可以包含多个进程组。他们用一个控制终端，这个终端通常是创建进程的登录终端。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ tips</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-19-c-tips/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-19-c-tips/</id>
    <published>2012-06-19T05:05:28.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>1.在switch语句中，default放在最前也不会被执行，都不满足才执行，但是如果没有break，会继续往下执行。</p><ol start="2"><li></li></ol><p>#define MAX_LEN 1</p><p>sizeof(MAX_LEN)</p><p>值为4，当作了一个整数。</p><ol start="3"><li></li></ol><p>在64位机</p><p>uint64_t ddwLen &#x3D; 0xFFFF000000000000;</p><p>不会有问题，</p><p>在32位会编译出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.在switch语句中，default放在最前也不会被执行，都不满足才执行，但是如果没有break，会继续往下执行。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#define MAX_LEN 1&lt;/p&gt;
&lt;p&gt;sizeof(MAX_LEN</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>gcc warning “will be initialized after/when initialized here”</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-19-gcc-warning-will-be-initialized-after-when-initialized-here/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-19-gcc-warning-will-be-initialized-after-when-initialized-here/</id>
    <published>2012-06-19T04:26:39.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>下面这段代码会产生warning</p><pre><code>#include &lt;iostream&gt;using namespace std;struct foo&#123;    foo() : Y(1), X(Y+1) &#123;&#125;    int X;    int Y;&#125;;int main(int argc, char *argv[])&#123;    return 0;&#125;</code></pre><p> <span id="more"></span></p><blockquote><p>In constructor ‘foo::foo()’:<br>8: warning: ‘foo::Y’ will be initialized after<br>7: warning:   ‘int foo::X’<br>6: warning:   when initialized here</p></blockquote><p>产生这个warning的原因是因为初始化列表的顺序和声明变量的顺序不一致。</p><p>编译器要求必须是一致的，否则会有问题。</p><p>上面的例子，X的值最开始初始化为Y+1,由于Y的值是垃圾值，所以X的值也是垃圾值，然后Y被初始化为1。</p><p>如果修改X和Y的声明顺序，则Y初始为1，X初始为2。</p><p>切记：</p><p>编译的时候带上-Wall选项！</p><p>不要放过一个warning！</p><p>在使用初始化列表的时候顺序要和声明一致！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;下面这段代码会产生warning&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

struct foo
&amp;#123;
    foo() : Y(1), X(Y+1) &amp;#123;&amp;#125;
    int X;
    int Y;
&amp;#125;;

int main(int argc, char *argv[])
&amp;#123;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>开发人员如何带项目</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-19-how-developers-with-projects/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-19-how-developers-with-projects/</id>
    <published>2012-06-19T03:35:37.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>　　在正规的项目中，会有pm、产品和开发等多种角色，项目的总体节奏基本上都是由pm来掌控的。在《<a href="http://yunpengzhang.com/articles/294.html">如何在pm和de之间生存</a>》的文章中也有所介绍，作为一名开发人员如何当好pm一职。今天说的不是这个，其实作为一名开发，在项目中也是要起带动作用的，也要有所发挥才能让项目更顺利。</p><span id="more"></span><p>　　<br>　　<strong>如何制定项目实现方案</strong><br>　　<br>　　互联网产品唯快不破，一般在开发前大家就摩拳擦掌，恨不得马上就打开编译器写代码。“走错了方向，走的越快，离目标越远”。在制定方案的时候切记不可轻率，要多想，多评审。做到可扩展和平滑升级，要做到心中有数。支撑多少的请求量，能够满足什么需求，不能满足什么需求。我们的产品在未来发展会不会突破架构。说起来简单，未来有很多是难以预测的，要想一步到位还真的挺难。<br>　　<br>　　三个臭皮匠赛过诸葛亮。自己想不通，可以拉上项目组的所有开发，架构师一起评审，一起想。一般自己想好方案，经过推敲后输出文档。发送给评审团，约好时间。在开会前可以先大概写出重点和需要评审的薄弱环节。方便大家帮助思考，也让时间少的同事可以掌握概况。评审的时候要做好主持人，不要让大家发散让会议跑题。<br>　　<br>　　会后输出会议纪要，同时修改方案，制定详细方案。与一通开发的同事一起分享，方便大家互相知道开发的思想。一来可以把错误尽早发现解决，二来能够大家互为主备容易接手业务。<br>　　<br>　　<strong>如何与产品pk</strong><br>　　<br>　　有了明确的方案之后，对于产品的需求，可以分门别类。哪些能做，哪些不能做，哪些可以一起做，哪些先做，哪些后做……<br>　　<br>　　原则是要对产品确实有好处，言之有物，有凭有据。现在做不了的以后可以做，永远做不了的有替代方案可以实现，如果需求真的不靠谱，那么可以pk掉。</p><p>　　产品希望功能越来越炫，达到极致。考虑到投入产出比，在时间和成本间要做个折衷，即使现在满足不了，在未来需要也有升级可能。<br>　　<br>　　<strong>如何把握开发节奏</strong><br>　　<br>　　项目时间不宜过长，这个更多来说是pm的事情。但是如果多项目并发，还是不要拖得太久。时间久了人就会关注的少，而且一个事情总放在那里，难免会有些情绪反应。这个时候有责任提醒pm发布版本，观察市场效果，如果做好了还拖好久，还不如晚加入，把精力投入到更紧急的项目中去。<br>　　<br>　　<strong>如何开发好程序</strong><br>　　<br>　　代码要写的尽量好些，起码要用格式化软件让代码格式整洁。减少耦合，减少耦合，减少耦合！！！代码尽量少耦合，方便需求变更和代码重用，也方便他人熟悉代码。可以想，如果这段代码开源出去，我会不会感到可以。如果不可以，还是改一下，就像一个人的着装，写字。可能邋遢些，字写的丑也没人管你，但是还是好一点让别人和自己舒服些。<br>　　<br>　　文档要有记录，代码要有注释。文档信息少，让人摸不着头脑，多呢，也让人难受。如果有歧义会更加浪费时间。所以文档和代码注释要即使更新，而且要保存到svn中，方便大家观看和修改。<br>　　<br>　　<strong>如何交接</strong><br>　　<br>　　项目交接要检查代码是否都上传到svn，文档是否健全。把代码中的bug和容易出问题的地方交代清楚，最好都写道文档中。最完美的是有文档只看文档就搞定，但是如果实现不了就多解答下，态度要好要谦虚。也可以问下第三方的体会，认为项目做的如何，好以后改进。<br>　　<br>　　总之作为一名开发还是要有自己的责任感，写出健壮的代码和产品，为自己的职业增加成就感。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　在正规的项目中，会有pm、产品和开发等多种角色，项目的总体节奏基本上都是由pm来掌控的。在《&lt;a href=&quot;http://yunpengzhang.com/articles/294.html&quot;&gt;如何在pm和de之间生存&lt;/a&gt;》的文章中也有所介绍，作为一名开发人员如何当好pm一职。今天说的不是这个，其实作为一名开发，在项目中也是要起带动作用的，也要有所发挥才能让项目更顺利。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】为什么开发人员工作10多年了还会迷茫？没有安全感？</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-19-switch-why-developers-will-work-for-10-years-lost-insecure/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-19-switch-why-developers-will-work-for-10-years-lost-insecure/</id>
    <published>2012-06-18T21:15:49.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://www.cnblogs.com/jirigala/">http://www.cnblogs.com/jirigala/</a></p><p>眼看自己大学毕业后都快12年了，也快2个孩子的爸爸了，但是有时候还是会有不少不安全的感觉产生。都快奔35了，技术也过得去，收入其实也很稳定，但是偶尔还是会有迷茫的时候，最近有几个朋友，也发QQ聊天信息，同样有类似的感觉。也稍微揣摩了一下，为啥会有这样的感觉产生？</p><p>   其实<strong>软件开发也是一个行业，当厨师的也是一个行业</strong>，一个厨师干了10多年后，会不会变成国家主席？很可能还是厨师，甚至有有可能一辈子都是厨师，软件开发人员也是一个行业而已，也是为人民服务而已，估计厨师也会有迷茫的时候，我们也照样会有迷茫的时候，05年左右在上海做日本外包时，还真有同事是厨师出身的。</p><span id="more"></span><p>   年轻时：</p><p>   01：<strong>年轻时，目标很简单，就是学技术</strong>，当时学PHP前后耗费了1-2年，接着学C#，SQLServer，Oracle耗费了前后10年接近了，有目标的人就不迷茫，就是一个字想学习知识。</p><p>   02：年轻时，欲望比较少，一个月能赚5000元的工资就很开心，生活没任何压力身体也很壮实，就也不会有啥负担，一心还是想着学好技术，找好单位，拿高薪。</p><p>   03：年轻时，<strong>可以有很多空想，就是狗屁不是，也可以抱有很多美好的理想，也可以做白日梦。</strong></p><p>   年纪大了后：</p><p>   01：<strong>打工总会有一个瓶颈</strong>，好单位也不是天天招聘，他们的业务也是有瓶颈，等你水平提高了，年龄也太大了，没啥竞争优势了，当初想进入的单位都不会招聘40岁的老头了。</p><p>   02：年纪大了，身体也开始不行了，要成家立业，养孩子，养老婆，父母年纪也大了，可能身体也更不行了，很可能也需要赡养了，<strong>生活的各种开支，不是小几千能搞定的</strong>。</p><p>   03：<strong>学了一大堆知识后未必都能转换成RMB</strong>，不转换成RMB，你的很多需求是得不到满足，你看很多人开着好车，住着豪宅，身边女人多多，一看自己也快奔40了，2手空空。</p><p>   04：<strong>很多年轻时的梦想实现了也未必能变成RMB</strong>，以前想架构一个完美的开发框架，结果努力了10年，想出售也很难遇到各种困难，就这么耗费掉了10年了。</p><p>   05：10年里会发现很多曾经的朋友成功了，但是你可能还是<strong>一个默默无闻的打工者</strong>，甚至能看到一直到到老的时候会怎么样？很可能打工一辈子。</p><p>   06：<strong>做技术的失业了就真失业了</strong>，啥也没了，没人给按时发工资了，连社保都都没了，不干活了就很可能没任何稳定收入了，没任何安全感了。</p><p>   07：<strong>有些行业越老越值钱，客户也越来越多</strong>，技术人员的客户都是老板的，越老越容易走下坡路，精力，能力都会下降，干劲更容易下降。</p><p>   08：<strong>老板也不是印钞机，老板也需要成本控制</strong>，所以尽量不会雇佣预算很高的员工，宁可雇佣在预算范围内的员工，谁都想拿10万一个与，但是老板赚不来那么多客户的钱。</p><p>   调整心态：</p><p>   01：<strong>人绝大部分是庸俗的普通人</strong>，不是每个人都能出人头地，1%不到的人相对能得到成功，99%甚至更多的人，是普通人一辈子。</p><p>   02：一般牛人的才华35岁前就体现出来了，<strong>35过了也是俗人的，再过几年就爆发不来</strong>，也很少，性格已经成型了，基本上可以过的安稳的日子就可以了。</p><p>   03：不要总是跟成功人士比，<strong>偶尔也向下看看</strong>，看看扫地的，看看服务员，看看人民公仆，多少心里会有一些安慰。</p><p>   04：<strong>人活着不只是为了赚钱</strong>，身体好，家庭幸福，感情顺利，孩子健康，父母健康，同事关系和睦，都是宝贵的财富。</p><p>   05：<strong>人生其实很短暂</strong>的，一晃10年就过去了，学会好好过生活，调节好每一天，想想要解放生活在水深火热中韩国的朝鲜人民军队，吃不饱饭，我们也幸福很多了。</p><p>   事实：</p><p>   01：年轻的时候没付出，年纪大了也有好的收成是很难的，除非你购买彩票中奖了，但是你最起码为了买彩票也得付出一些劳动，所以没有白来的成功白来的收获。</p><p>   02：世界很大社会在发展，到处需要技术服务，我们做技术的就是为社会技术需要做辛苦劳动而已，所以只要社会安定团结，我们就不用太愁没饭吃。</p><p>   03：每个人都想成功，做医生的难道不想巨大成功？做老师的难道不想巨大成功？谁都想有巨大的成功，但是，只有一个院长，一个校长，其他都是普通人。</p><p>   04：水平没有，让你当个部门经理，没几天也得被大家罢免，水平没有，给你1000个人公司，第2个月，你就发不出工资，1年不到就倒闭。</p><p>   05：人都很迷茫，迷茫的时候千万别吸毒、别赌博，别沉溺与网络游戏，迷茫的时候适当的调节一下心里，看看健康的电影，听听音乐，找几个朋友聊聊天。</p><p>   扫地最厉害的人是谁？很可能顶多是扫地组的组长，例如杭州西湖区环境保护临时工中的小组长，种地种最厉害的？炒菜炒最厉害的？那一样，写程序最厉害的，很可能就是项目组组长，人嘛都想老板，但是都不想付出老板的艰辛。</p><p>   真想巨大成功，就走出来自己干，就知道有多难打工还是很舒服每个月按时发工资，压力也是大家一起承担，周末还可以休息，晚上可能也不用加班。</p><p>   迷茫的时候，看看我的博客，就会好很多了。</p><p>   幸福有很多种类：</p><p>   1：你有年轻漂亮的老婆。</p><p>   2：你有健康聪明的小宝宝。</p><p>   3：你有一个强壮的身体。</p><p>   4：你会唱歌跳舞多多才多艺。</p><p>   5：你喜欢钓鱼，绣花。</p><p>   6：吉日嘎拉喜欢写几篇软文，看看别人的回复就其乐无穷，偶尔看看网络上美女图片，看看美国大片，都是其乐无穷的事情，偶尔鼓励一下小朋友，跟老朋友聚聚，吃吃喝喝都是很快乐很幸福的。</p><p>   人人都想当比尔盖茨，可惜你<strong>没那样的妈妈</strong>（IBM的高级主管？），也<strong>没那样的爸爸</strong>（纽约著名律师？），今天<strong>也考不上那样的大学</strong>（哈佛很好考吗？），<strong>更不可能支付那么高的费用购买别人的软件产品</strong>（按当年的美元计算，当年一个月工资多少，现在多少，按当年的汇率折算，30-40年后现在让你支付这些费用，也很可能买不起当年的DOS什么的版权）。</p><p>   <strong>成功很多时候不是偶然的，很多是必然的</strong>，有几个国家领导人是普通老百姓？都是高干子女居多。</p><p>   从农村的大山沟里能爬出来到中国的人间天堂定居生活也知足了，<strong>知足常乐，不能跟自己过不去</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自&lt;a href=&quot;http://www.cnblogs.com/jirigala/&quot;&gt;http://www.cnblogs.com/jirigala/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;眼看自己大学毕业后都快12年了，也快2个孩子的爸爸了，但是有时候还是会有不少不安全的感觉产生。都快奔35了，技术也过得去，收入其实也很稳定，但是偶尔还是会有迷茫的时候，最近有几个朋友，也发QQ聊天信息，同样有类似的感觉。也稍微揣摩了一下，为啥会有这样的感觉产生？&lt;/p&gt;
&lt;p&gt;   其实&lt;strong&gt;软件开发也是一个行业，当厨师的也是一个行业&lt;/strong&gt;，一个厨师干了10多年后，会不会变成国家主席？很可能还是厨师，甚至有有可能一辈子都是厨师，软件开发人员也是一个行业而已，也是为人民服务而已，估计厨师也会有迷茫的时候，我们也照样会有迷茫的时候，05年左右在上海做日本外包时，还真有同事是厨师出身的。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://yunpengzhang.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>makefile变量和赋值</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-18-makefile-variables-and-assignments/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-18-makefile-variables-and-assignments/</id>
    <published>2012-06-17T21:21:56.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>makefile变量表示</strong></p><p>在makefile中，表示一个变量要用$(VAR) ${VAR}两种都行，但是在shell中必须要用大括号。其实makefile要求用小括号，只是在shell中解析用哪个都行。如果在makefile中要解析shell变量，要使用$${PWD}才可以。</p><p><strong>makefile赋值<span id="more"></span></strong></p><p>VARIABLE &#x3D; value</p><p>普通的赋值，如果使用值的时候会递归展开，并不是在定义的之后就把值赋好。<br>VARIABLE ?&#x3D; value</p><p>只有在VARIABLE 为空的时候才赋值<br>VARIABLE :&#x3D; value</p><p>在声明的时候就把值给赋值好了，后面value的值改变不影响VARIABLE 。<br>VARIABLE +&#x3D; value</p><p>在VARIABLE 的值后面增加value的值。</p><blockquote><p>#example<br>a &#x3D; orginal_value<br>b &#x3D; $(a)<br>a &#x3D; later_value<br>all:<br>    @echo $(b)<br>运行make<br>#make<br>later_value<br>#example<br>a &#x3D; orginal_value<br>b :&#x3D; $(a)<br>a &#x3D; later_value<br>all:<br>    @echo<br>$(b)<br>#make<br>original_value</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;makefile变量表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在makefile中，表示一个变量要用$(VAR) ${VAR}两种都行，但是在shell中必须要用大括号。其实makefile要求用小括号，只是在shell中解析用哪个都行。如果在makefile中要解析shell变量，要使用$${PWD}才可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;makefile赋值</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>XML使用心得</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-13-xml-use-the-experience/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-13-xml-use-the-experience/</id>
    <published>2012-06-13T03:53:59.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>最近的一个项目中使用到了xml文件，主要用来读取配置。对xml有了一些了解。为什么要用xml呢？数据的格式方便阅读，擅长做为有层级关系的配置文件。例如：一个系统有3个ip和端口。如果用传统的配置，则要写成ip1 xxx ip2 yyy ip3 zzz。如果加ip呢，如果每个ip都再添加一些属性呢？要用下标来标记，看起来不直观，写起来也麻烦。如果换成xml就会简单许多。</p><p><strong>什么是XML？</strong></p><p>XML 代表Extensible Markup Language（eXtensible Markup Language的缩写，意为可扩展的标记语言）。XML是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。</p><p>XML 指可扩展标记语言（EXtensible Markup Language）<span id="more"></span></p><p>XML 是一种标记语言，很类似 HTML</p><p>XML 的设计宗旨是传输数据，而非显示数据</p><p>XML 标签没有被预定义。您需要自行定义标签</p><p>XML 被设计为具有自我描述性。</p><p>XML 是 W3C 的推荐标准</p><p>XML 文档形成一种树结构</p><p>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>所有元素均可拥有子元素：</p><pre><code>&lt;root&gt;　　&lt;child&gt;　　　　&lt;subchild&gt;.....&lt;/subchild&gt;　　&lt;/child&gt;&lt;/root&gt;</code></pre><p><strong>XML到底有什么用途和好处呢？</strong></p><p>XML方便数据传递，不同的程序不同的操作系统，都可以通过XML来传递数据。提供了一种解析的标准和协议，像TLV格式的加强版，协议解析只需解析需要的部分，对于程序扩展向下兼容有好处。</p><p>具体详细的XML介绍还请参考下面两篇文章。</p><p><a href="http://www.ibm.com/developerworks/cn/xml/newto/">XML 新手入门</a> <a href="http://www.w3school.com.cn/xml/index.asp"> XML 教程</a></p><p><strong>XML解析程序</strong></p><p>用到了tinyxml，是一个轻量级的xml C++库，对于简单的xml解析还是很方便的，下面简要介绍一下tinyxml的使用和原理。</p><p>tinyxml中也是把xml文档定义为TiXmlDocument。一个TiXmlDocument运行了LoadFile方法读取xml文件成功后就把xml文件解析成为一颗树。</p><p>每个树的节点用TiXmlNode来表示。TiXmlNode有类型，分为TiXmlNode::TINYXML_DOCUMENT，TiXmlNode::TINYXML_DOCUMENT，TiXmlNode::TINYXML_UNKNOWN，TiXmlNode::TINYXML_DECLARATION，TiXmlNode::TINYXML_TEXT，TiXmlNode::TINYXML_TEXT。由TiXmlNode的Type()方法展示。</p><p>TiXmlNode使用ToXXX转换成不同的类型。例如ToElement()转换成元素类型TiXmlElement。遍历element的属性可以是用pElement-&gt;FirstAttribute()和pAttrib-&gt;Next();</p><p>如果要遍历element，要使用TiXmlNode的FirstChild()和NextSibling()来遍历每个element的儿子节点。</p><p>tinyxml tutorial 中的 Full listing for dump_to_stdout可以很好的理解xml的遍历。简单的应用也可以修改这个程序搞定。</p><p>也可以参考<a href="http://www.wuzesheng.com/?p=260">TinyXml使用与剖析</a>的介绍理解tinyxml的实现原理。</p><p>这里是<a href="http://www.grinninglizard.com/tinyxml/">tinyxml</a>的主页</p><p>TiXmlHandle</p><pre><code>TiXmlElement* root = document.FirstChildElement( &quot;Document&quot; );if ( root )&#123;    TiXmlElement* element = root-&gt;FirstChildElement( &quot;Element&quot; );    if ( element )    &#123;        TiXmlElement* child = element-&gt;FirstChildElement( &quot;Child&quot; );        if ( child )        &#123;            TiXmlElement* child2 = child-&gt;NextSiblingElement( &quot;Child&quot; );            if ( child2 )            &#123;                // Finally do something useful.</code></pre><p>使用TiXmlHandle类</p><pre><code>TiXmlHandle docHandle( &amp;document );TiXmlElement* child2 = docHandle.FirstChild( &quot;Document&quot; ).FirstChild( &quot;Element&quot; ).Child( &quot;Child&quot;, 1 ).ToElement();if ( child2 )&#123;    // do something useful</code></pre><p>看过这个例子后，在提取xml文件元素的时候会方便很多，不用每次都遍历在递归中判断。</p><p>后续：把从前的代码用handle实现；读tinyxml的源代码。</p><p>简单的使用了一下，发现确实使用handle很方便，配合数字可以很容易遍历所有的元素。</p><p>对于属性还是要搜索遍历，不过应该也可以使用handle来处理属性。</p><p>判断返回的指针是否为空很重要。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近的一个项目中使用到了xml文件，主要用来读取配置。对xml有了一些了解。为什么要用xml呢？数据的格式方便阅读，擅长做为有层级关系的配置文件。例如：一个系统有3个ip和端口。如果用传统的配置，则要写成ip1 xxx ip2 yyy ip3 zzz。如果加ip呢，如果每个ip都再添加一些属性呢？要用下标来标记，看起来不直观，写起来也麻烦。如果换成xml就会简单许多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是XML？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;XML 代表Extensible Markup Language（eXtensible Markup Language的缩写，意为可扩展的标记语言）。XML是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。&lt;/p&gt;
&lt;p&gt;XML 指可扩展标记语言（EXtensible Markup Language）</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>实现两个Mysql数据库之间的主从同步</title>
    <link href="https://yunpengzhang.github.io/2012/2012-06-01-mysql-database-to-achieve-two-master-slave-synchronization-between/"/>
    <id>https://yunpengzhang.github.io/2012/2012-06-01-mysql-database-to-achieve-two-master-slave-synchronization-between/</id>
    <published>2012-05-31T21:41:37.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>主要参考《实现两个Mysql数据库之间的主从同步》<br><a href="http://blog.csdn.net/guoguo1980/article/details/2343722">http://blog.csdn.net/guoguo1980/article/details/2343722</a>的文章。</p><p>注意：两个mysql的<strong>版本要相同</strong>，否则会有问题。</p><h6 id="一、在master机器。"><a href="#一、在master机器。" class="headerlink" title="一、在master机器。"></a><strong>一、在master机器。</strong></h6><p>1.在master机器上建立帐户并赋予权限。</p><pre><code>grant SUPER,REPLICATION CLIENT on *.* to &#39;backup&#39;@&#39;xxx.xxx.xxx.xxx&#39; identified by &#39;1234&#39;;grant replication slave on *.* to &#39;backup&#39;@&#39;xxx.xxx.xxx.xxx&#39; identified by &#39;1234&#39;;grant file on *.* to &#39;backup&#39;@&#39;xxx.xxx.xxx.xxx&#39; identified by &#39;1234&#39;;</code></pre><p>2、增加一个数据库作为同步数据库：</p><pre><code>create database test;</code></pre><span id="more"></span><p>3、创建一个表结构：</p><pre><code>create table mytest (username varchar(20),password varchar(20));</code></pre><p>4、修改配置文件：</p><p>修改A的&#x2F;etc&#x2F;my.cnf文件，在my.cnf配置项中加入下面配置：</p><pre><code>server-id = 1      #Server标识log-binbinlog-do-db=test  #指定需要日志的数据库</code></pre><p>5、重起数据库服务：</p><pre><code>service mysqld restart</code></pre><p>查看server-id：</p><pre><code>show variable like &#39;server_id&#39;;</code></pre><p>实例：</p><p>mysql&gt; show variables like ‘server_id’;</p><p>+—————+——-+</p><p>| Variable_name | Value |</p><p>+—————+——-+</p><p>| server_id     | 1     |</p><p>+—————+——-+</p><p>1 row in set (0.00 sec)</p><p>6、用show master status\G命令看日志情况。</p><p>正常为：</p><p>mysql&gt; show master status\G</p><p>*************************** 1. row ***************************</p><p>File: mysqld-bin.000002</p><p>Position: 198</p><p>Binlog_Do_DB: test,test</p><p>Binlog_Ignore_DB:</p><p>1 row in set (0.08 sec)</p><h3 id="二、在slave机器。"><a href="#二、在slave机器。" class="headerlink" title="二、在slave机器。"></a><strong>二、在slave机器。</strong></h3><p>1、增加一个数据库作为同步数据库：</p><pre><code>create database test;</code></pre><p>2、创建一个表结构：</p><pre><code>create table mytest (username varchar(20),password varchar(20));</code></pre><p>3、修改配置文件：</p><p>修改B的&#x2F;etc&#x2F;my.cnf文件，在my.cnf配置项中加入下面配置：</p><p>server-id&#x3D;2</p><p>master-host&#x3D;10.10. 0.119</p><p>master-user&#x3D;backup    #同步用户帐号</p><p>master-password&#x3D;1234</p><p>master-port&#x3D;3306</p><p>master-connect-retry&#x3D;60 #预设重试间隔60秒</p><p>replicate-do-db&#x3D;test    #告诉slave只做backup数据库的更新</p><p>5、重起数据库服务：</p><p>service mysqld restart</p><p>查看server-id：</p><p>show variables like ‘server_id’；</p><p>实例：</p><p>mysql&gt; show variables like ‘server_id’;</p><p>+—————+——-+</p><p>| Variable_name | Value |</p><p>+—————+——-+</p><p>| server_id     | 2     |</p><p>+—————+——-+</p><p>1 row in set (0.00 sec)</p><p>6、用show slave status\G命令看日志情况。</p><p>正常为：</p><p>mysql&gt; show slave status\G</p><p>*************************** 1. row ***************************</p><p>Slave_IO_State: Waiting for master to send event</p><p>Master_Host: 10.10.0.119</p><p>Master_User: backup</p><p>Master_Port: 3306</p><p>Connect_Retry: 60</p><p>Master_Log_File: mysqld-bin.000001</p><p>Read_Master_Log_Pos: 98</p><p>Relay_Log_File: mysqld-relay-bin.000003</p><p>Relay_Log_Pos: 236</p><p>Relay_Master_Log_File: mysqld-bin.000001</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes</p><p>Replicate_Do_DB: test,test</p><p>Replicate_Ignore_DB:</p><p>Replicate_Do_Table:</p><p>Replicate_Ignore_Table:</p><p>Replicate_Wild_Do_Table:</p><p>Replicate_Wild_Ignore_Table:</p><p>Last_Errno: 0</p><p>Last_Error:</p><p>Skip_Counter: 0</p><p>Exec_Master_Log_Pos: 98</p><p>Relay_Log_Space: 236</p><p>Until_Condition: None</p><p>Until_Log_File:</p><p>Until_Log_Pos: 0</p><p>Master_SSL_Allowed: No</p><p>Master_SSL_CA_File:</p><p>Master_SSL_CA_Path:</p><p>Master_SSL_Cert:</p><p>Master_SSL_Cipher:</p><p>Master_SSL_Key:</p><p>Seconds_Behind_Master: 0</p><p>1 row in set (0.01 sec)</p><h3 id="三、验证配置"><a href="#三、验证配置" class="headerlink" title="三、验证配置"></a><strong>三、验证配置</strong></h3><p>分别使用insert, delete , update在A主机进行增删改查数据库；查看B主机的数据库是否与A主机一致；若一致，则配置成功。</p><h3 id="四、双机互备模式"><a href="#四、双机互备模式" class="headerlink" title="四、双机互备模式"></a><strong>四、双机互备模式</strong></h3><p>如果在A主机加入slave设置，在B主机加入master设置，则可以做B-&gt;A的同步。</p><p>1、在A主机的配置文件中 mysqld配置项加入以下设置：</p><p>master-host&#x3D;10.10.8.112</p><p>master-user&#x3D;backup</p><p>master-password&#x3D;1234</p><p>replicate-do-db&#x3D;test</p><p>master-connect-retry&#x3D;10</p><p>2、在B的配置文件中 mysqld配置项加入以下设置：</p><p>log-bin</p><p>binlog-do-db&#x3D;test</p><p>注意：当有错误产生时，*.err日志文件同步的线程退出，当纠正错误后，要让同步机制进行工作，运行slave start。</p><p>重起A、B机器，则可以实现双向的热备份。</p><h3 id="五、常见问题及解决"><a href="#五、常见问题及解决" class="headerlink" title="五、常见问题及解决"></a><strong>五、常见问题及解决</strong></h3><p>1、Slave机器的权限问题，不但要给slave机器File权限，还要给它REPLICATION SLAVE的权限。</p><p>2、在修改完Slave机器&#x2F;etc&#x2F;my.cnf之后，slave机器的mysql服务启动之前，记得要删除掉master.info</p><p>3、在show master status或着show slave status不正常时，看看.err是怎样说的。</p><p>4、Slave上Mysql的Replication工作有两个线程, I&#x2F;O thread和SQL thread。I&#x2F;O的作用是从master 3306端口上把它的binlog取过来(master在被修改了任何内容之后,就会把修改了什么写到自己的binlog等待slave更新),然后写到本地的relay-log,而SQL thread则是去读本地的relay-log,再把它转换成本Mysql所能理解的语句，于是同步就这样一步一步的完成.决定I&#x2F;O thread的是&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;master.info,而决定SQL thread的是&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;relay-log.info.</p><p>5、启动slave，命令用start slave；重新启动用restart slave</p><p>重启可以使用</p><p>service mysqld restart</p><p>或者</p><p>mysqladmin -u root -p shutdown</p><p>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;safe_mysqld  –user&#x3D;mysql &amp;</p><p>回收命令可以使用</p><p>revoke file on <em>.</em> from ‘user‘@’xxx.xxx.xxx.xxx’;</p><p>删除用户</p><p>drop user ‘user‘@’xxx.xxx.xxx.xxx’;</p><p>load data from master</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要参考《实现两个Mysql数据库之间的主从同步》&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guoguo1980/article/details/2343722&quot;&gt;http://blog.csdn.net/guoguo1980/article/details/2343722&lt;/a&gt;的文章。&lt;/p&gt;
&lt;p&gt;注意：两个mysql的&lt;strong&gt;版本要相同&lt;/strong&gt;，否则会有问题。&lt;/p&gt;
&lt;h6 id=&quot;一、在master机器。&quot;&gt;&lt;a href=&quot;#一、在master机器。&quot; class=&quot;headerlink&quot; title=&quot;一、在master机器。&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、在master机器。&lt;/strong&gt;&lt;/h6&gt;&lt;p&gt;1.在master机器上建立帐户并赋予权限。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant SUPER,REPLICATION CLIENT on *.* to &amp;#39;backup&amp;#39;@&amp;#39;xxx.xxx.xxx.xxx&amp;#39; identified by &amp;#39;1234&amp;#39;;
grant replication slave on *.* to &amp;#39;backup&amp;#39;@&amp;#39;xxx.xxx.xxx.xxx&amp;#39; identified by &amp;#39;1234&amp;#39;;
grant file on *.* to &amp;#39;backup&amp;#39;@&amp;#39;xxx.xxx.xxx.xxx&amp;#39; identified by &amp;#39;1234&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、增加一个数据库作为同步数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database test;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>提高效率——使用awk代替shell读文件</title>
    <link href="https://yunpengzhang.github.io/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/"/>
    <id>https://yunpengzhang.github.io/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/</id>
    <published>2012-05-02T05:07:44.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>对一个号码文件进行操作，调用的处理事件越来越慢。</p><p>曲线如下</p><img src="/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/image-20240718172040309.png" class="" title="image-20240718172040309"><p>脚本大致如下：</p><p>#!&#x2F;bin&#x2F;bash</p><p>while read seq</p><p>do</p><p>echo $seq</p><p>done &lt; seq.dat<span id="more"></span></p><p>改成awk读取后发现曲线平稳</p><img src="/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell"  alt="img" style="zoom: 25%;" /><p>脚本如下</p><p>#!&#x2F;bin&#x2F;bash</p><p>awk ‘{system(“echo “ $0);}’ seq.dat</p><p>shell利用重定向read时的系统调用如下：</p><img src="/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/wps2.png" class="" title="img"><p>在不停地调用_llseek定位文件偏移，然后读取128个字节，使用read需要的字节数后，执行输出操作，然后再重复_llseek的操作。每次读取的字节是有重复的。随着文件的增加，只有_llseek的参数变大，<strong>推断出因为</strong><strong>_llseek****系统调用与文件便宜有关，但还不确定，因为并未读取源码，请知道的同学解答。</strong></p><p>Awk操作如下：<img src="/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/wps3.png" class="" title="img"></p><p>采用缓存，操作一次读一行，使用完缓冲区顺序往下读，顺序读取，所以执行稳定。</p><img src="/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/wps4.png" class="" title="img"><p><strong>建议：以后对号码文件调用工具进行操作，使用awk<strong><strong>调用shell</strong></strong>的方法会得到比较稳定的速度，在预期的时间内完成任务。</strong></p><p><strong>附：****测试程序</strong></p><p>seq 1000000 &gt; seq.dat</p><p>while read s;</p><p>do</p><p>if [ <code>expr $s % 50000</code> -eq 0 ];then</p><p>echo -n $( expr <code>date +%s</code> - $A) ‘ ‘;</p><p>A&#x3D;<code>date +%s</code>;</p><p>fi</p><p>done &lt; seq.dat</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对一个号码文件进行操作，调用的处理事件越来越慢。&lt;/p&gt;
&lt;p&gt;曲线如下&lt;/p&gt;
&lt;img src=&quot;/2012/2012-05-02-improve-efficiency-use-awk-instead-of-reading-a-file-shell/image-20240718172040309.png&quot; class=&quot;&quot; title=&quot;image-20240718172040309&quot;&gt;

&lt;p&gt;脚本大致如下：&lt;/p&gt;
&lt;p&gt;#!&amp;#x2F;bin&amp;#x2F;bash&lt;/p&gt;
&lt;p&gt;while read seq&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;echo $seq&lt;/p&gt;
&lt;p&gt;done &amp;lt; seq.dat</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux性能监控——CPU、Memory、IO、Network</title>
    <link href="https://yunpengzhang.github.io/2012/linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94cpu%E3%80%81memory%E3%80%81io%E3%80%81network/"/>
    <id>https://yunpengzhang.github.io/2012/linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94cpu%E3%80%81memory%E3%80%81io%E3%80%81network/</id>
    <published>2012-03-12T16:45:41.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>一、CPU</p><p>1、良好状态指标</p><ul><li>CPU利用率：User Time &lt;&#x3D; 70%，System Time &lt;&#x3D; 35%，User Time + System Time &lt;&#x3D; 70%。</li><li>上下文切换：与CPU利用率相关联，如果CPU利用率状态良好，大量的上下文切换也是可以接受的。</li><li>可运行队列：每个处理器的可运行队列&lt;&#x3D;3个线程。</li></ul><p>2、监控工具</p><span id="more"></span><ul><li>vmstat</li></ul><p>$ vmstat 1 procs ———–memory———- —swap– —–io—- –system– —–cpu—— r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 14  0    140 2904316 341912 3952308  0    0     0   460 1106 9593 36 64  1  0  0 17  0    140 2903492 341912 3951780  0    0     0     0 1037 9614 35 65  1  0  0 20  0    140 2902016 341912 3952000  0    0     0     0 1046 9739 35 64  1  0  0 17  0    140 2903904 341912 3951888  0    0     0    76 1044 9879 37 63  0  0  0 16  0    140 2904580 341912 3952108  0    0     0     0 1055 9808 34 65  1  0  0 重要参数： r，run queue，可运行队列的线程数，这些线程都是可运行状态，只不过CPU暂时不可用； b，被blocked的进程数，正在等待IO请求； in，interrupts，被处理过的中断数 cs，context switch，系统上正在做上下文切换的数目 us，用户占用CPU的百分比 sys，内核和中断占用CPU的百分比 id，CPU完全空闲的百分比 上例可得： sy高us低，以及高频度的上下文切换（cs），说明应用程序进行了大量的系统调用； 这台4核机器的r应该在12个以内，现在r在14个线程以上，此时CPU负荷很重。</p><ul><li>查看某个进程占用的CPU资源</li></ul><p>$  while :; do ps -eo pid,ni,pri,pcpu,psr,comm  grep ‘db_server_login’; sleep 1; done   PID  NI PRI %CPU PSR COMMAND 28577   0  23  0.0   0 db_server_login 28578   0  23  0.0   3 db_server_login 28579   0  23  0.0   2 db_server_login 28581   0  23  0.0   2 db_server_login 28582   0  23  0.0   3 db_server_login 28659   0  23  0.0   0 db_server_login ……        二、Memory 1、良好状态指标</p><ul><li>swap in （si） &#x3D;&#x3D; 0，swap out （so） &#x3D;&#x3D; 0</li><li>应用程序可用内存&#x2F;系统物理内存 &lt;&#x3D; 70%</li></ul><p>2、监控工具</p><ul><li>vmstat</li></ul><p>$ vmstat 1 procs ———–memory———- —swap– —–io—- –system– —–cpu—— r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 0  3 252696   2432    268   7148 3604 2368  3608  2372  288  288  0  0 21 78  1 0  2 253484   2216    228   7104 5368 2976  5372  3036  930  519  0  0  0 100  0 0  1 259252   2616    128   6148 19784 18712 19784 18712 3821 1853  0  1  3 95  1 1  2 260008   2188    144   6824 11824 2584 12664  2584 1347 1174 14  0  0 86  0 2  1 262140   2964    128   5852 24912 17304 24952 17304 4737 2341 86 10  0  0  4 重要参数： swpd，已使用的 SWAP 空间大小，KB 为单位； free，可用的物理内存大小，KB 为单位； buff，物理内存用来缓存读写操作的buffer大小，KB 为单位； cache，物理内存用来缓存进程地址空间的 cache 大小，KB 为单位； si，数据从 SWAP 读取到 RAM（swap in）的大小，KB 为单位； so，数据从 RAM 写到 SWAP（swap out）的大小，KB 为单位。 上例可得： 物理可用内存 free 基本没什么显著变化，swapd逐步增加，说明最小可用的内存始终保持在 256MB(物理内存大小) * 10％ &#x3D; 2.56MB 左右，当脏页达到10％的时候就开始大量使用swap。</p><ul><li>free</li></ul><p>$ free -m total used free shared buffers cached Mem: 8111 7185 926 0 243 6299 -&#x2F;+ buffers&#x2F;cache: 643 7468 Swap: 8189 0 8189</p><p>三、磁盘IO 1、良好状态指标</p><ul><li>iowait % &lt; 20%</li></ul><p>提高命中率的一个简单方式就是增大文件缓存区面积，缓存区越大预存的页面就越多，命中率也越高。 Linux 内核希望能尽可能产生次缺页中断（从文件缓存区读），并且能尽可能避免主缺页中断（从硬盘读），这样随着次缺页中断的增多，文件缓存区也逐步增大，直到系统只有少量可用物理内存的时候 Linux 才开始释放一些不用的页。 2、监控工具</p><ul><li>查看物理内存和文件缓存情况</li></ul><p>$ cat &#x2F;proc&#x2F;meminfo MemTotal:      8182776 kB MemFree:       3053808 kB Buffers:        342704 kB Cached:        3972748 kB 这台服务器总共有 8GB 物理内存（MemTotal），3GB 左右可用内存（MemFree），343MB左右用来做磁盘缓存（Buffers），4GB左右用来做文件缓存区（Cached）。</p><ul><li>sar</li></ul><p>$ sar -d 2 3 Linux 2.6.9-42.ELsmp (webserver) 11&#x2F;30&#x2F;2008 _i686_ (8 CPU) 11:09:33 PM DEV tps rd_sec&#x2F;s wr_sec&#x2F;s avgrq-sz avgqu-sz await svctm %util 11:09:35 PM dev8-0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 11:09:35 PM DEV tps rd_sec&#x2F;s wr_sec&#x2F;s avgrq-sz avgqu-sz await svctm %util 11:09:37 PM dev8-0 1.00 0.00 12.00 12.00 0.00 0.00 0.00 0.00 11:09:37 PM DEV tps rd_sec&#x2F;s wr_sec&#x2F;s avgrq-sz avgqu-sz await svctm %util 11:09:39 PM dev8-0 1.99 0.00 47.76 24.00 0.00 0.50 0.25 0.05 Average: DEV tps rd_sec&#x2F;s wr_sec&#x2F;s avgrq-sz avgqu-sz await svctm %util Average: dev8-0 1.00 0.00 19.97 20.00 0.00 0.33 0.17 0.02 重要参数： await表示平均每次设备I&#x2F;O操作的等待时间（以毫秒为单位）。 svctm表示平均每次设备I&#x2F;O操作的服务时间（以毫秒为单位）。 %util表示一秒中有百分之几的时间用于I&#x2F;O操作。 如果svctm的值与await很接近，表示几乎没有I&#x2F;O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I&#x2F;O队列等待太长，系统上运行的应用程序将变慢。 如果%util接近100%，表示磁盘产生的I&#x2F;O请求太多，I&#x2F;O系统已经满负荷的在工作，该磁盘可能存在瓶颈。</p><p>四、Network IO 1、良好状态指标 接收、发送缓冲区不长时间有等待处理的网络包 2、监控工具</p><ul><li>netstat</li></ul><p>对于UDP服务，查看所有监听的UDP端口的网络情况 $ watch netstat -lunp Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name udp        0      0 0.0.0.0:64000           0.0.0.0:*                           - udp        0      0 0.0.0.0:38400           0.0.0.0:*                           - udp        0      0 0.0.0.0:38272           0.0.0.0:*                           - udp        0      0 0.0.0.0:36992           0.0.0.0:*                           - udp        0      0 0.0.0.0:17921           0.0.0.0:*                           - udp        0      0 0.0.0.0:11777           0.0.0.0:*                           - udp        0      0 0.0.0.0:14721           0.0.0.0:*                           - udp        0      0 0.0.0.0:36225           0.0.0.0:*                           - RecvQ、SendQ为0，或者不长时间有数值是比较正常的。</p><p>对于UDP服务，查看丢包情况（网卡收到了，但是应用层没有处理过来造成的丢包） $ watch netstat -su Udp:     278073881 packets received     4083356897 packets to unknown port received.     2474435364 packet receive errors     1079038030 packets sent packet receive errors 这一项数值增长了，则表明在丢包</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一、CPU&lt;/p&gt;
&lt;p&gt;1、良好状态指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU利用率：User Time &amp;lt;&amp;#x3D; 70%，System Time &amp;lt;&amp;#x3D; 35%，User Time + System Time &amp;lt;&amp;#x3D; 70%。&lt;/li&gt;
&lt;li&gt;上下文切换：与CPU利用率相关联，如果CPU利用率状态良好，大量的上下文切换也是可以接受的。&lt;/li&gt;
&lt;li&gt;可运行队列：每个处理器的可运行队列&amp;lt;&amp;#x3D;3个线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、监控工具&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>删除svn目录</title>
    <link href="https://yunpengzhang.github.io/2012/2012-02-16-remove-svn-directories/"/>
    <id>https://yunpengzhang.github.io/2012/2012-02-16-remove-svn-directories/</id>
    <published>2012-02-16T01:36:48.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>当向svn添加目录时，如果目录下有.svn目录，会出现冲突。</p><p>所以在引用代码时总是先删除掉.svn目录，使用以下命令。</p><p>[code lang&#x3D;”cpp”]<br>find . -name “.svn” -exec rm -rf {} ;</p><p>find . -name “.svn” | xargs rm -rf<br>[&#x2F;code]</p><p>具体的含义可以参考《find命令总结》</p><p>find命令将所有匹配到的文件一起传递给exec执行,有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。</p><p>注意：在删除文件前最好先打印一下查找到的文件，核对下是否是要删除的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当向svn添加目录时，如果目录下有.svn目录，会出现冲突。&lt;/p&gt;
&lt;p&gt;所以在引用代码时总是先删除掉.svn目录，使用以下命令。&lt;/p&gt;
&lt;p&gt;[code lang&amp;#x3D;”cpp”]&lt;br&gt;find . -name “.svn” -exec rm -rf {} ;</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>makefile小技巧</title>
    <link href="https://yunpengzhang.github.io/2012/2012-02-16-makefile-tips/"/>
    <id>https://yunpengzhang.github.io/2012/2012-02-16-makefile-tips/</id>
    <published>2012-02-16T01:14:03.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>1.操作打文件makefile要加上宏</p><p>[code]</p><p>-D_FILE_OFFSET_BITS&#x3D;64 -D_LARGEFILE_SOURCE</p><p>[&#x2F;code]</p><p>2.如果要make时打印警告信息，又不输出有符号和无符号比较、变量定义未使用警告</p><p>[code]</p><p>-Wall -Wno-sign-compare -Wno-unused-variable</p><p>[&#x2F;code] </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.操作打文件makefile要加上宏&lt;/p&gt;
&lt;p&gt;[code]&lt;/p&gt;
&lt;p&gt;-D_FILE_OFFSET_BITS&amp;#x3D;64 -D_LARGEFILE_SOURCE&lt;/p&gt;
&lt;p&gt;[&amp;#x2F;code]&lt;/p&gt;
&lt;p&gt;2.如果要make时打印警告信息，又不输出</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>monitor上报技巧小结</title>
    <link href="https://yunpengzhang.github.io/2012/monitor%E4%B8%8A%E6%8A%A5%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/"/>
    <id>https://yunpengzhang.github.io/2012/monitor%E4%B8%8A%E6%8A%A5%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/</id>
    <published>2012-02-08T11:02:45.000Z</published>
    <updated>2024-07-20T15:19:39.355Z</updated>
    
    <content type="html"><![CDATA[<p>对于服务器程序部署运营后，监控程序健康情况，最主要手段的还是使用monitor观察上报属性。经过一段时间的开发，总结了一下开发程序时加上报的一些经验，希望对大家有所帮助，也希望能够有人提出建议，更好地完善。</p><span id="more"></span><h3 id="1-源程序中上报用枚举类型或宏"><a href="#1-源程序中上报用枚举类型或宏" class="headerlink" title="1.源程序中上报用枚举类型或宏"></a>1.源程序中上报用枚举类型或宏</h3><p>或 <strong>优点</strong>：个人比较喜欢枚举，可以把相同类型的上报放到一起，代码比较清晰。 最主要的是要有明确的注释，避免直接写Attr_API( 88888, 1);这样的语句不容易维护，也难查找问题。</p><h3 id="2-错误log中写入上报变量的名字"><a href="#2-错误log中写入上报变量的名字" class="headerlink" title="2.错误log中写入上报变量的名字"></a>2.错误log中写入上报变量的名字</h3><p><strong>优点</strong>：错误log量多时方便查找，用grep查上报变量，就能提取error log。</p><h3 id="3-在monitor申请上报名称时加上文件名和上报id的变量名"><a href="#3-在monitor申请上报名称时加上文件名和上报id的变量名" class="headerlink" title="3.在monitor申请上报名称时加上文件名和上报id的变量名"></a>3.在monitor申请上报名称时加上文件名和上报id的变量名</h3><p><strong>优点</strong>：收到告警短信时就知道上报的二进制文件和对应的源程序文件，同时可以直接用短信里的信息去运营机利用2里提到的方法查找log。</p><h3 id="4-视图按照源文件分类命名"><a href="#4-视图按照源文件分类命名" class="headerlink" title="4.视图按照源文件分类命名"></a>4.视图按照源文件分类命名</h3><p><strong>优点</strong>：方便查找问题，降低视图的耦合性，查看视图清晰。</p><h2 id="申请视图id技巧"><a href="#申请视图id技巧" class="headerlink" title="申请视图id技巧"></a>申请视图id技巧</h2><p>1.在excel中写入要申请的id描述内容 2.在属性列表中把上述内容一起粘贴进去 3.复制红框里的内容，提取id和变量名，写入到源程序枚举样式 上面的方法虽然很容易理解，但是上报信息多时操作还是很麻烦的，抛砖引玉写了个脚本，可以方便点，也希望<strong>脚本达人给提供个更人性化更方便的脚本</strong>，要是<strong>monitor****可以网站上直接下载宏或枚举形式的代码</strong>就更好了。 <strong>使用方法</strong>： 1.在attr_id.txt中写入要用的id和注释 格式为： 2.运行monitorid.sh， .&#x2F;monitorid.sh attr_id.txt havegetid.txt 3.把输出的文件（havegetid.txt）内容粘贴到excele中到monitor上申请id 4.申请到的id全部粘贴到新的havegetid.txt中， 运行 .&#x2F;expressmnt.sh havegetid.txt attr_id.txt</p><p>得到可以放到代码中的文件语句。</p><p> <a href="asset/monitor%E4%B8%8A%E6%8A%A5%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93.zip">monitor上报技巧小结.zip</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于服务器程序部署运营后，监控程序健康情况，最主要手段的还是使用monitor观察上报属性。经过一段时间的开发，总结了一下开发程序时加上报的一些经验，希望对大家有所帮助，也希望能够有人提出建议，更好地完善。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在pm和de之间生存</title>
    <link href="https://yunpengzhang.github.io/2011/2011-12-04-how-to-survive-between-pm-and-de/"/>
    <id>https://yunpengzhang.github.io/2011/2011-12-04-how-to-survive-between-pm-and-de/</id>
    <published>2011-12-04T07:29:09.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　在小项目中，通常人力不足时会让开发担任pm职务。一般情况下，担任pm的时候是不用编码参与开发的，但是也有特殊的时候，这时就会有既当教练，又当运动员的情况发生。<br>　　<br>　　其实原本这也没什么，但是经历后才发现，不容易，如果再给一次机会，还是会有很多提高的空间。<br>　　<br>　　如果想要做到游刃有余，那么必须去分好自己的角色，知道什么时候我是pm，什么时候我是de。即使在一个会议上，也要想清楚，我这段时间是从pm回答，这段时间是从de的角度阐述。有些左右互搏的意思，如果搞不定，也有个简单的办法，只扮演pm，de让另一个搭档来。<span id="more"></span><br>　　<br>　　那么pm应该管什么事情呢？pm关心的是项目的进度和资源的调度，总之就是要按时把活都干完。需求制定是产品的是，能不能实现按期交付是开发的事，开发采用什么框架方法都是开发的事。这点pm不用关心，关心也没用。需要的只是各部分给出时间点，按时收租。另外pm也要有一种气场，就是都听我的，开会时有权在会议“楼”的情况下，让大家shut up都听我的。当然这也是需要方法和技巧的。在de中关心的是如何实现，以及按时间实现。<br>　　<br>　　开会中经常遇到的一个场景就是de在叫苦，说这东西怎么实现都难，不好实现。作为de出身的pm千万不要多嘴，千万，一说话就“歪楼”，而且想回都回不来。产品们只有瞪眼的份。其实说了也白说，一般在开发眼中都是认定自己牛的，我说做不了，你说能做就做的了，那你来做啊。所以这是抛出的问题是我们还是要实现，难实现也要实现，那你开个价吧，要人还是多给时间。然后再找他leader或老一点的de来看他给的时间点是否对。<br>　　<br>　　做pm另外一个本领就是要脸皮硬。注意不是厚。你要每天都督促大家按进度进行，稍有风吹草动就要即使处理。因为和de不一样了，自己开发的时候，白天做不完，晚上我可以加班，晚上做不完，我周末加。但是在pm角度则不行，你做不完后面一堆拓扑路等着呢，都要延期。pm最怕的就是延期。<br>　　<br>　　当pm需要什么呢？1.一群给力的开发，不一定技术多强，但是一定要守信用，估时间准。答应的开发到时能交出来。2.不是很善变的产品。3.关键时刻提供支援的领导。4.没有比你重要的项目同时进行。这几项同时占有不说烧高香，也是运气极佳。通常是很难都满足的，这也是看一个人是否能把工作做好。领导给你的资源始终是不足的，就像家里的冰箱始终和菜谱的对不上。但是好的主妇还是能烧出让家人爱吃的菜。<br>　　<br>　　相当好pm任重道远，做de想兼职好pm更是难上加难，还有很多东西要学路要走。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　在小项目中，通常人力不足时会让开发担任pm职务。一般情况下，担任pm的时候是不用编码参与开发的，但是也有特殊的时候，这时就会有既当教练，又当运动员的情况发生。&lt;br&gt;　　&lt;br&gt;　　其实原本这也没什么，但是经历后才发现，不容易，如果再给一次机会，还是会有很多提高的空间。&lt;br&gt;　　&lt;br&gt;　　如果想要做到游刃有余，那么必须去分好自己的角色，知道什么时候我是pm，什么时候我是de。即使在一个会议上，也要想清楚，我这段时间是从pm回答，这段时间是从de的角度阐述。有些左右互搏的意思，如果搞不定，也有个简单的办法，只扮演pm，de让另一个搭档来。</summary>
    
    
    
    <category term="技巧" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>如何提高会议效率</title>
    <link href="https://yunpengzhang.github.io/2011/2011-11-20-how-to-improve-the-efficiency-of-meetings/"/>
    <id>https://yunpengzhang.github.io/2011/2011-11-20-how-to-improve-the-efficiency-of-meetings/</id>
    <published>2011-11-20T07:08:01.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　平时工作中，交流的方式很多，邮件、im、电话、会议。其中会议是最有效、直接的沟通方式，但是也存在着耗时成本高的问题。所以当会议来临，如何提高会议效率，是一件值得仔细考虑的事。<br>　　<br>　　一、要请和会议内容有关系的人<br>　　<br>　　可能看着是句废话，但是确实有需要我们注意的地方。一个项目，可能汇集了多方，但是我们的会议议题可能只是开发方案的问题，那么就不要把数据分析、运维的人都叫上。浪费的时间比较多，会让无关的同事受到影响，另外人数多了也增加了组织者的压力。<br>　　<br>　　二、要有主持人和决策人<br>　　<br>　　一般会议组织者作为主持人，或者会议的受益者。总之要有个人来主持会议，把握会议的发展和流程。这点很重要，主持人要知道会议的背景和议题，交代完背景后引导大家讨论。<br>　　<br>　　会议也要有决策人，否则无法确定最后结论，一定要有说得算的人在场。<br>　　<br>　　三、要确定会议需解决的问题<br>　　<br>　　会议开始时就要确定要解决的问题，越细越好，根据问题的具体情况决定会议流程。会议有明确的目的，不至于中间跑题，根据问题的解决多少来判断一次会议是否成功。<br>　　<br>　　四、把握会议流程和时间<br>　　<br>　　主持人要根据会议的解决问题来引导流程，当有人发散和跑提时，即使把议题引导回来。如果问题解决不了，根据时间判断，尽早去讨论下一个问题，不要在节外生枝的问题上花费太多时间。例如是过进度的会议，那么直接讨论上一期做了什么，下期准备做什么，有什么问题，最后讨论问题解决方法。尽量把能交代的问题交代后再发散。另外会议时间不要太长，人会疲劳，效果也不好。一个小时左右为宜。<br>　　<br>　　五、输出会议纪要<br>　　<br>　　会议结束后要及时输出会议纪要，把会议解决问题列出，写出会议解决方法。相关人都要收到或抄送到，另外也要把解决问题需要的人和时间明确写到纪要中，作为对后面工作的一个衡量方法。<br>　　<br>　　六、跟进结论<br>　　<br>　　会议只是商定方法，后面执行的效果，还是要跟进的。<br>　　<br>　　做到以上几点可以说会议的效率就很高了，会议的目的也达到了，但是说着简单，实现起来很难，还需要实践中多摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　平时工作中，交流的方式很多，邮件、im、电话、会议。其中会议是最有效、直接的沟通方式，但是也存在着耗时成本高的问题。所以当会议来临，如何提高会议效率，是一件值得仔细考虑的事。&lt;br&gt;　　&lt;br&gt;　　一、要请和会议内容有关系的人&lt;br&gt;　　&lt;br&gt;　　可能看着是句废话，但</summary>
      
    
    
    
    <category term="技巧" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员需要什么</title>
    <link href="https://yunpengzhang.github.io/2011/2011-11-07-what-programmers-need/"/>
    <id>https://yunpengzhang.github.io/2011/2011-11-07-what-programmers-need/</id>
    <published>2011-11-07T08:24:12.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　程序员需要什么？键盘、鼠标、编译器……虽然是必要的，但是今天要说的是对于程序员的职业来说，要想做好，需要的环境和素质到底是什么。<br>　　<br>　　<strong>一、一份热爱的工作</strong><br>　　<br>　　如果你喜欢windows开发，那么可以去做客户端，游戏。如果喜欢linux，可以去做嵌入式，后台。喜欢做手机应用，那么可以做苹果或android系统程序。总之，去做你喜欢并且擅长的领域，那么会自然有动力。投入的精力和取得的成绩也成正比的，你越喜欢投入的就越多，当然效果也会越好。如果正从事一个不喜欢的领域，那么快停。　　</p><span id="more"></span><p>　　除了用到的知识是擅长喜爱的，薪酬福利也是很重要的。人最基本的是要生存，从工作中得到的报酬决定了生活水平。当然，我觉得衡量的标准很简单，如果不买房，那么买什么东西都不成问题，去商店可以喜欢什么买什么。那样可以不为生活担心，专心地投入到工作中去。如果买房也游刃有余，那么可以无视我这篇文章，只能说你是一个已经知道需要什么的工程师了。不过程序员花费也不多，记得听一个程序员说过，每个月的工资都不知道多少，也不看多少钱。<br>　　<br>　　<strong>二、一群可以交流的同事</strong><br>　　<br>　　孤木不成林，软件行业和传统的建筑行业类似，更多的需要合作才能做好。所以有一群可以交流心得，志同道合的同事无疑是宝贵的财富。大家在一起可以交流评审架构，分享知识数据，讨论行业发展方向。彼此学到很多东西。而且相对来说程序员的生活简单些，同事无疑是交流最多的，能够成为好朋友是件很重要的事。<br>　　<br>　　<strong>三、一个信任的领导</strong><br>　　<br>　　信任包含你对领导的信任，还有领导对你的信任。如何建立信任，当然是工作积极主动，把每件事情都付出120%的努力去完成，想得不到信任都难。积极主动，对自己和团队还有项目都很重要。对于自己生活所依靠，并且是热爱的职业，能做到100分为什么要做90分，能做到极致一定不留遗憾。<br>　　<br>　　千里马常有，而伯乐不常有。能够由一个慧眼识英雄的领导也是三生有幸，否则做的再多也只能“骈死于槽枥之间”。百万富翁的朋友也是百万富翁，跟着能力强的领导也就成了能力强的人。<br>　　<br>　　<strong>四、对工作有责任感</strong><br>　　<br>　　对于工作要有责任感，有敬业心。对于有些人简单，有些人难。还是看工作在心中的地位和对于自己的重要程度吧。不过我觉得做一件事情就要做好，不留遗憾，工作也是。既然把大好的年华都投入到其中，当然要敬业，否则是浪费生命。<br>　　<br>　　<strong>五、学习能力</strong><br>　　<br>　　要想成为更高级的程序员，学习能力是必须的。因为软件行业发展迅速，产品日新月异，新技术也层出不穷，没有持之以恒的学习能力即使今天走在前端，也免不了在下一个浪潮的时候被冲走。<br>　　<br>　　时刻保持对行业的新形势的嗅觉，和对新知识新架构的兴趣，是不被淘汰的黄金法则。<br>　　<br>　　<strong>六、对效率的高要求</strong><br>　　<br>　　为什么要用程序实现？是因为可以提高效率。本身就是在做一件提高效率的事情，所以效率对程序员来说也是很重要的。从程序的执行效率，到实现方法的开发效率，都要求能提高尽量提高。高效率可以让我们的产品有好的市场，高效率可以让我们有更快的开发速度，也能让我们有更多的时间可以陪家人。<br>　　<br>　　<strong>七、理解程序员的家庭</strong><br>　　<br>　　程序员躲不开的一件事——加班。经常是早出晚归，一天也难陪家人吃顿饭，有时周末也要加班。虽然提高效率会减少工作时间，但是现在的大环境还是要加班的。能够有家人的理解和支持对程序员来说是无疑是强大的后盾。同时对职业的付出也是为了让家人生活得更幸福。家人的支持是最重要的，分享一个<a href="http://v.youku.com/v_playlist/f4410969o1p0.html">微软的广告</a>。<br>　　<br>　　如果具备了这些，那么是非常幸运的，没有理由不去把工作做好。上面只是现在想到的一些，真正也远不止这么简单。觉得现在自己还算幸运，希望能够作出些成绩。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　程序员需要什么？键盘、鼠标、编译器……虽然是必要的，但是今天要说的是对于程序员的职业来说，要想做好，需要的环境和素质到底是什么。&lt;br&gt;　　&lt;br&gt;　　&lt;strong&gt;一、一份热爱的工作&lt;/strong&gt;&lt;br&gt;　　&lt;br&gt;　　如果你喜欢windows开发，那么可以去做客户端，游戏。如果喜欢linux，可以去做嵌入式，后台。喜欢做手机应用，那么可以做苹果或android系统程序。总之，去做你喜欢并且擅长的领域，那么会自然有动力。投入的精力和取得的成绩也成正比的，你越喜欢投入的就越多，当然效果也会越好。如果正从事一个不喜欢的领域，那么快停。
　　&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>给我一首歌的时间</title>
    <link href="https://yunpengzhang.github.io/2011/2011-11-06-give-me-a-song-of-the-time/"/>
    <id>https://yunpengzhang.github.io/2011/2011-11-06-give-me-a-song-of-the-time/</id>
    <published>2011-11-06T06:52:38.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　平时做事情，总会遇到自己不喜欢做的情况。例如：这个数据提取好麻烦，根本不知道从何下手；这个bug已经出现了好久，很多人都没解决，还是不要看了；博客好久没更新了，要不要写一篇呢。好多事情都是想要去做，但是有困难在前面，而从心里还想逃避，不知道你遇到过没有。那我们怎么能克服这种心理，然后把要做的事情顺利地做完呢？答案是给自己一首歌的时间。<br>　　<br>　　万事开头难，难的就是开始这个阶段。可能没有入手的地方，不知道要做得方向，一旦开始，剩下的只是轻车熟路，按部就班，虽然过程会很麻烦，但是要做什么已经知道了。所谓的“给我一首歌的时间”就是给自己几分钟，即使再不想做，再困难的事情也坚持地开始做。在这段时间内不去想和这事无关的内容，专心思考要达到什么样的目标，达到目标时要如何做。把自己全身心的投入到事情之中，一会就有想法了，然后为了解决想到的问题就开始查资料，写测试。总之就开始知道要做什么了，给事情起了个好头，后面一步步都变得清晰，也知道要做什么，怎么做了。<br>　　<br>　　当然，也会有这段时间虽然过去了，但是还是没有头绪，不知道怎么做，还是厌烦去做。那么之后只有两条路要走：一、继续思考，如何解决遇到的问题；二、想为什么这事做不了，给一个可以不做的站得住的理由。剩下就没什么好办法了。<br>　　<span id="more"></span><br>　　从人的本能来讲，都是倾向于对自己有利的判断。一个事情很难，会让自己不好做，而且会花费很多时间和精力，从内心就会有抵触的。所以我们要尽量地劝自己，让自己能够投入进去。就像药很苦，放一些糖或者想些道理让自己喝下去一样。<br>　　<br>　　经本人多次测试，不管多不想做的事情在面前，只要用心专心地投入前几分钟。后面的事情就就相对简单了，因为在这几分钟内已经激起了对事物研究的兴趣，知道了要解决问题的方法，剩下的就是按照步骤，一步步找到问题的答案，问题都解决了，事情也做好了。<br>　　<br>　　写这篇博客的时候也觉得很难，但是专心开始写也发现想法和词语一步步的都从头脑中蹦出来，还起了一个歌的名字。大家可以欣赏下<a href="http://v.qq.com/video/play.html?vid=Z0090JRb38w">这首歌</a>。其实最开始想写给自己十分钟的时间，但是实践发现只要有两三分钟就能决定这个事情是否要做，能不能做下去，和一首歌的时间差不多。<br>　　<br>　　万事开头难，为了能够有个好的开头，能够坚持继续，给自己全身心开始的几分钟时间，会收获一个圆满的结局的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　平时做事情，总会遇到自己不喜欢做的情况。例如：这个数据提取好麻烦，根本不知道从何下手；这个bug已经出现了好久，很多人都没解决，还是不要看了；博客好久没更新了，要不要写一篇呢。好多事情都是想要去做，但是有困难在前面，而从心里还想逃避，不知道你遇到过没有。那我们怎么能克服这种心理，然后把要做的事情顺利地做完呢？答案是给自己一首歌的时间。&lt;br&gt;　　&lt;br&gt;　　万事开头难，难的就是开始这个阶段。可能没有入手的地方，不知道要做得方向，一旦开始，剩下的只是轻车熟路，按部就班，虽然过程会很麻烦，但是要做什么已经知道了。所谓的“给我一首歌的时间”就是给自己几分钟，即使再不想做，再困难的事情也坚持地开始做。在这段时间内不去想和这事无关的内容，专心思考要达到什么样的目标，达到目标时要如何做。把自己全身心的投入到事情之中，一会就有想法了，然后为了解决想到的问题就开始查资料，写测试。总之就开始知道要做什么了，给事情起了个好头，后面一步步都变得清晰，也知道要做什么，怎么做了。&lt;br&gt;　　&lt;br&gt;　　当然，也会有这段时间虽然过去了，但是还是没有头绪，不知道怎么做，还是厌烦去做。那么之后只有两条路要走：一、继续思考，如何解决遇到的问题；二、想为什么这事做不了，给一个可以不做的站得住的理由。剩下就没什么好办法了。&lt;br&gt;</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>互联网设计想法杂记</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-26-internet-design-ideas-miscellany/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-26-internet-design-ideas-miscellany/</id>
    <published>2011-10-26T07:15:58.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>睡觉前总结下最近对互联网项目设计的想法</p><ol><li><p>keep it simple and stupid.尽量的保证设计的简单，能把复杂的事情变简单才是最重要的，只要性能可以满足，那么哪个方法简单采用哪个方法，最好能够让心接项目的人在听你讲一遍就知道什么意思，哪怕不看代码也能够想到怎么实现。</p></li><li><p>用多少设计多少。设计最怕过度设计，一个需求如果看不到那么远，最好现在需要什么就设计什么，不要想我后面还加什么东西，保留一大堆保留字。这样会让开始设计就变得复杂，而且真到扩展的时候才发现，预留的那些功能是不够的，即使够也捉襟见肘。</p></li><li><p>架构就是把复杂的东西变简单。不要以为越复杂越庞大的架构越牛，真正好的架构是利用种种小的模块拼凑成高楼大厦，就像linux的设计哲学，很多小的组件拼凑成强大的功能，即使修改只要改变一小部分就可以了。</p></li><li><p>不要做假设。用数据说话，不要用自己的行为认为是用户的行为。可能你只是一小部分用户，真正用户要什么你是不知道的，你要经过调查才可以。另外别以为用户都是很规矩的，就是有输入特殊的用户来考验系统。特别是服务海量用户。</p></li><li><p>明确需求。知道你为什么要做这个系统，做这个系统有什么作用。技术再好，编码再优美，没有产品也没用。就好比建筑师建造了一座皇宫，但是没有人来参观居住也是无用的。需求明确了，那个方案好，哪个不好，一下子就比出来了。</p></li><li><p>保持一颗接受变化的心。这个系统做出来要称五年、十年。互联网的变化五年、十年是什么样，谁知道。想太久是没用的，应该想怎么能让系统有更好的扩展能力，或者如果有新变化怎么能迅速构建新系统。试想摩尔定律，硬件变化那么大，现在纠结的内存硬盘可能在几年之后都不是问题，还有互联网产品能撑十年那也是奇迹。</p></li><li><p>多想设计，少编码。设计的时间要充分，先想到各个角落。不要等编码的时候才想函数几个参数，应该返回什么。那注定会出现写一半发现不对重写的现象，加班救火也不奇怪。</p></li></ol><p>以上观点属睡前随笔，难免有重复和不足之处，欢迎补充！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;睡觉前总结下最近对互联网项目设计的想法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;keep it simple and stupid.尽量的保证设计的简单，能把复杂的事情变简单才是最重要的，只要性能可以满足，那么哪个方法简单采用哪个方法，最好能够让心接项目的人在听你讲一遍就知道什么意</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>等待</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-18-e7ad89e5be85/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-18-e7ad89e5be85/</id>
    <published>2011-10-18T07:48:06.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>坐车要塞车等，吃饭要排队等，坐在电视机前看广告等节目播放，薪水上调需要等……生活需要等的东西太多了，每天都在等待中迎来一件件好事，坏事，惊奇。等待，是通往结果的过程，是一段旅程的中间经历。是见到亲人前坐的火车，是高考前一页页的习题，是到达终点前的艰苦训练。等待，无处不在，大家都在某个期待结果之前便构成了等待。我们，都在等待死亡，不管你是愿意还是不愿意，也不管你体没体会到还是没发现。</p><p>那么，我们要用什么样的心态等待呢？因人而异，不过火急火燎，心急如焚什么都干不了是不行的。我们只是等吗？当然不是。如果站在原地，什么都不做，是等不到答案的，等到的只是失望和事与愿违。</p><p>等待，要有积极的行动。大雁等待过冬是不会收起翅膀的，人们等待愿望的实现也是需要行动才行。理想实现的过程大多是艰辛，令人痛苦，正是如此，也让人难忘。在通往终点的道路上要有积极的行动，想办法如何才能更加靠近目标，如何才能缩短于终点的距离，加强自己的能力，努力积极的行动，才是不二的选择，才能尽早的等来想要的结果，才能不浪费掉这段过程并培养自己。<span id="more"></span></p><p>等待，要有沉稳的耐心。等待的过程总是漫长。十分钟，在轻松娱乐面前总是很快，在塞车的时候度日如年。同样的刻度给了人们不同的感受。为什么有的人能坚持，有的人却让躁动的心来影响自己。还是心态问题，要有一颗沉稳的心，要有坚强的耐心。能经受住时间的折磨。“心急吃不了热豆腐”，“凉豆腐”都是给有耐心的人准备的，没耐心的只能吃了还要吐出来。好多东西是需要过程的，就像花开，果熟。我们已经努力，但是还要时间打磨，拼的就是心态，谁有耐心、稳的住才是赢家，也才配的上是赢家。</p><p>等待，要有抵御诱惑的能力和不畏困难的决心。等待的过程总会有各种诱惑和放弃的理由相伴。不要被安逸所诱惑，也不要为困难吓到。停下来只是一时轻松，夏天不努力等来的只有冬天。越是困难的事越要做到，越是竞争激烈越要去争，男儿本色既是如此，血液里流淌着拼搏的细胞。当然，要认清什么才是真正的目标，没有方向什么都是逆风，找对方向即使作出牺牲也值得。</p><p>等来了春，还有夏在等你，秋冬过后又是轮回。等到了长大独自走出家门，又有妻子儿女等着你进入家门。等到了一个项目结束，下个又开始。人生苦短，但是活着的时候感觉又是那么的长。只要有机会的绝不放过，耐心、努力、专心之后一定会得到的。不要局限于眼前，不要满足，后面还有更多精彩的在等你，都需要继续以更快的速度加快脚步。永远不要满足，也不要自大，成功属于有耐得住性子的人，机遇偏爱有准备的人，就像乔帮主所说——stay hungry，stay foolish。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;坐车要塞车等，吃饭要排队等，坐在电视机前看广告等节目播放，薪水上调需要等……生活需要等的东西太多了，每天都在等待中迎来一件件好事，坏事，惊奇。等待，是通往结果的过程，是一段旅程的中间经历。是见到亲人前坐的火车，是高考前一页页的习题，是到达终点前的艰苦训练。等待，无处不在，大家都在某个期待结果之前便构成了等待。我们，都在等待死亡，不管你是愿意还是不愿意，也不管你体没体会到还是没发现。&lt;/p&gt;
&lt;p&gt;那么，我们要用什么样的心态等待呢？因人而异，不过火急火燎，心急如焚什么都干不了是不行的。我们只是等吗？当然不是。如果站在原地，什么都不做，是等不到答案的，等到的只是失望和事与愿违。&lt;/p&gt;
&lt;p&gt;等待，要有积极的行动。大雁等待过冬是不会收起翅膀的，人们等待愿望的实现也是需要行动才行。理想实现的过程大多是艰辛，令人痛苦，正是如此，也让人难忘。在通往终点的道路上要有积极的行动，想办法如何才能更加靠近目标，如何才能缩短于终点的距离，加强自己的能力，努力积极的行动，才是不二的选择，才能尽早的等来想要的结果，才能不浪费掉这段过程并培养自己。</summary>
    
    
    
    <category term="思考" scheme="https://yunpengzhang.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>滚雪球 </title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-18-snowball/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-18-snowball/</id>
    <published>2011-10-18T01:50:54.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p><strong>案例</strong><br><strong>基本情况</strong><br>如下图，进程A是一个单进程系统，通过udp套接字接收前端请求进行处理。在处理过程中，需要访问后端系统B，是同步的方式访问后端系统B，根据后端系统B的SLA，超时时间设置是100ms。前端用户请求的超时时间是1s。</p><span id="more"></span><p>进程A的时序是：<br>Step1: 从socket接收缓冲区接收用户请求<br>Step2: 进行本地逻辑处理<br>Step3: 发送请求到后端系统B<br>Step4: 等待后端系统B返回<br>Step5: 接收后端系统B的应答<br>Step6: 应答前端用户，回到step1处理下一个请求</p><p><strong>正常情况下的负载</strong><br>正常情况下<br>1、前端请求报文大小约100Bytes。前端请求的峰值每分钟1800次，即峰值每秒30次。<br>2、后端系统B并行能力较高，每秒可以处理10000次以上，绝大多数请求处理时延在20ms内。<br>3、进程A在处理请求的时候，主要时延是在等待后端系统B，其他本地运算耗时非常少，小于1ms<br>这个时候，我们可以看出，系统工作良好，因为处理时延在20ms内，每秒进程A每秒中可以处理50个请求，足以将用户每秒峰值30个请求及时处理完。</p><hr><p><strong>导火索</strong><br>某天，后端系统B进行了新特性发布，由于内部逻辑变复杂，导致每个请求处理时延从20ms延长至50ms（每秒最多可以处理20个请求），根据sla的100ms超时时间，这个时延仍然在正常范围内。当用户请求达到峰值时间点时，灾难出现了，用户每次操作都是“服务器超时无响应”，整个服务不可用。</p><hr><p><strong>过载分析</strong><br>当后端系统B处理时延延长至50ms的时候，进程A每秒只能处理20个请求（1s &#x2F; 50ms &#x3D; 20 ）。小于正常情况下的用户请求峰值30次&#x2F;s。这个时候操作失败的用户往往会重试，我们观察到前端用户请求增加了6倍以上，达到200次&#x2F;s，是进程A最大处理能力（20次&#x2F;s）的10倍！<br>这个时候为什么所有用户发现操作都是失败的呢？ 为什么不是1&#x2F;10的用户发现操作能成功呢？ 因为请求量和处理能力之间巨大的差异使得5.6s内就迅速填满了socket接收缓冲区（平均能缓存1000个请求，1000&#x2F;(200-20)&#x3D;5.6s），并且该缓冲区将一直保持满的状态。这意味着，一个请求被追加到缓冲区里后，要等待50s（缓存1000个请求，每秒处理20个，需要50s）后才能被进程A取出来处理，这个时候用户早就看到操作超时了。换句话说，进程A每次处理的请求，都已经是50s以前产生的，进程A一直在做无用功。雪球产生了。</p><p><strong>启示</strong></p><ul><li><p>每个系统，自己的最大处理能力是多少要做到清清楚楚。例如案例一中的前端进程A，他的最大处理能力不是50次&#x2F;s，也不是20次&#x2F;s，而是10次&#x2F;s。因为它是单进程同步的访问后端B，且访问后端B的超时时间是100ms，所以他的处理能力就是1S&#x2F;100ms&#x3D;10次&#x2F;s。而平时处理能力表现为50次&#x2F;s，只是运气好。</p></li><li><p>当过载发生时，该拒绝的请求（1、超出整个系统处理能力范围的；2、已经超时的无效请求）越早拒绝越好。</p></li><li><p>当雪球发生了，直接清空雪球队列（例如重启进程可以清空socket 缓冲区）可能是快速恢复的有效方法。</p></li></ul><p><strong>拒绝请求越早越好的实现一般有几种：</strong><br><strong>（1）频率限制法</strong><br>应该在系统的入口处加上频率限制，超过频率限制的请求直接拒绝。频率限制的一般做法是：设置一个sum_req记录单位时间内的请求数量，来一个请求sum_req++，比较sum_req和单位时间的最大处理数量，小于继续处理，大于继续处理，超过单位时间时，sum_req清零。那么这个“单位时间”设置为多少是合理的呢？对上面的案例，前端的超时是1s，我觉得A上的频率控制的单位时间至少应该是1s（频率检查的单位时间设置为前端每个请求的超时时间——在socket缓冲区能放下的前提下）（更小的话更精确），如果A的频率检查的单位时间超过前端超时的时间，前端的请求不能得到及时的服务也不能立即发现，仍然会出现滚雪球的现象。</p><p><strong>（2）打时间戳法</strong><br>在该系统每个机器上新增一个进程：interface进程。Interface进程能够快速的从socket缓冲区中取得请求，打上当前时间戳，压入channel。业务处理进程从channel中获取请求和该请求的时间戳，如果发现时间戳早于当前时间减去超时时间（即已经超时，处理也没有意义），就直接丢弃该请求，或者应答一个失败报文。<br>Channel是一个先进先出的通信方式，可以是socket，也可以是共享内存、消息队列、或者管道，不限。<br>Socket缓冲区要设置合理，如果过大，导致interface进程都需要处理长时间才能清空该队列，就不合适了。建议的大小上限是：缓存住超时时间内interface进程能够处理掉的请求个数（注意考虑网络通讯中的元数据）。</p><p><strong>（3）暴力法</strong><br>直接改小内核的socket缓冲区大小。雪球其实是服务了大量已经超时的请求，及时清空服务队列是消灭雪球的方法。如果socket缓冲区比较小，就相当于服务队列比较短，原来应该排队的请求会直接被丢包，表现为机器丢包。这种方法其实不怎么友好，被丢弃的包不能立即被通知前端是超过频率限制了，前端只能等待超时。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;基本情况&lt;/strong&gt;&lt;br&gt;如下图，进程A是一个单进程系统，通过udp套接字接收前端请求进行处理。在处理过程中，需要访问后端系统B，是同步的方式访问后端系统B，根据后端系统B的SLA，超时时间设置是100ms。前端用户请求的超时时间是1s。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>《浪潮之巅》读后感</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-12-wave-the-summit-book/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-12-wave-the-summit-book/</id>
    <published>2011-10-12T06:29:07.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　十一期间有幸读完了吴军的《浪潮之巅》，最近一直比较忙，也比较懒，趁现在还能记住，写成读后感（注意和笔记的区别）。<br>　　<br>　　之前在网上也看过《浪潮之巅》，还每天看电子书，感觉写得很好。对于了解世界it发展史很有帮助，文字优美语言流畅。那些你能够耳熟能详的it公司都出现在了这本书里。从att一直分析到今天的google，facebook，和腾讯。<br>　　<br>　　有两种事情让你感觉这本书很牛：1.介绍了很多你不知道的东西。2.很多你以为你知道的东西，他讲得更多。你知道IBM是怎么起家的吗，在二战时期还做过枪；摩托原来在cpu领域很牛；思科是怎么快速发展并一直领先的……这本书让人看的很兴奋，很感兴趣。不过中间的内容不是很感兴趣，没有仔细看，后面对web2.0和云计算介绍的还是不错的。书中不会给你解释详细的技术，让你有个历史和大体的了解。<br>　　<br>　　对于web2.0的解释我还是很喜欢的，介绍了作者对2.0的理解和兴起过程，并且对于现在互联网的现象给了解释。<br>　　<span id="more"></span><br>　　书主要还是照应书名浪潮，一个个公司的崛起，一个个王朝的逝去，都是有着历史原因的。赶上了一波新技术的浪潮，那么只要顺着浪漂，那么就会发展的很顺利，占领霸主地位。新的时代不适合，那么不转变必然会逝去。科技和社会的大潮决定了发展的必然。所以选择行业和投资也很重要，要看到现在的浪潮是什么，还有没有希望。就像汽车兴起的时候不知道投资哪家公司，但是马车公司是绝对不能投资的。同时作者在经济方面的知识也很丰厚，也从经济的角度解释了很多现象，风投等。<br>　　<br>　　总的来说对这本书的印象非常好，看过也觉得学到了很多东西。不过看的匆忙，并且没有做笔记，一时半会还想不出什么详细的精彩内容，记忆需要唤醒。后面要买本收藏，好书要多读几遍。也发现个现象，在知识爆炸的年代，先大体了解，再深挖，是一个不错的选择。</p><p>　　据说《沸腾十五年》也不错，有机会读一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　十一期间有幸读完了吴军的《浪潮之巅》，最近一直比较忙，也比较懒，趁现在还能记住，写成读后感（注意和笔记的区别）。&lt;br&gt;　　&lt;br&gt;　　之前在网上也看过《浪潮之巅》，还每天看电子书，感觉写得很好。对于了解世界it发展史很有帮助，文字优美语言流畅。那些你能够耳熟能详的it公司都出现在了这本书里。从att一直分析到今天的google，facebook，和腾讯。&lt;br&gt;　　&lt;br&gt;　　有两种事情让你感觉这本书很牛：1.介绍了很多你不知道的东西。2.很多你以为你知道的东西，他讲得更多。你知道IBM是怎么起家的吗，在二战时期还做过枪；摩托原来在cpu领域很牛；思科是怎么快速发展并一直领先的……这本书让人看的很兴奋，很感兴趣。不过中间的内容不是很感兴趣，没有仔细看，后面对web2.0和云计算介绍的还是不错的。书中不会给你解释详细的技术，让你有个历史和大体的了解。&lt;br&gt;　　&lt;br&gt;　　对于web2.0的解释我还是很喜欢的，介绍了作者对2.0的理解和兴起过程，并且对于现在互联网的现象给了解释。&lt;br&gt;</summary>
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>一段喜欢的小程序</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-a-small-program-like/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-a-small-program-like/</id>
    <published>2011-10-09T22:13:45.000Z</published>
    <updated>2024-07-20T15:19:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>[code lang&#x3D;”cpp”]<br>#include <cstdio><br>using namespace std;</p><p>void I_Love_U ( void )<br>{<br>    printf(“    j&amp;&#x3D;   y+ y*    jv+   yy-v    v &amp;\n”);<br>    printf(“   wE!&quot;   j17$T   7MPC   NU$E-   Ej&amp;v-\n”);<br>    printf(“   O<em>K^  yHH:Ovm+ UMMk   BMNTO: H1&#x3D;&quot;7’\n”);<br>    printf(“  j0&amp;0H: &quot;OH7&quot;E~  U0H1   BB71&#96; jCf’U:\n”);<br>    printf(“  vM1H1   jB-j1  wHhHh</em>-&#x2F;$B)B-   BkJUk\n”);<br>    printf(“  ^HI’OH j&quot;&quot;^N1  &quot;OHOK~  H$H&quot;Da jP’N ^\n”);<br>    printf(“   &quot;‘  O|    &quot;    jvHT   T ~ &quot;&quot;    &quot;\n”);<br>}</p><p>int main()<br>{<br>    I_Love_U ( ) ;</p><p>    return 0;<br>}</p><p>[&#x2F;code] </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[code lang&amp;#x3D;”cpp”]&lt;br&gt;#include &lt;cstdio&gt;&lt;br&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;void I_Love_U ( void )&lt;br&gt;{&lt;br&gt;    printf(“    j&amp;amp;&amp;#x3D;   </summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记（四）</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-four/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-four/</id>
    <published>2011-10-09T21:00:52.000Z</published>
    <updated>2024-07-20T15:19:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>　　第三篇《跟波利亚学解题》<br>　　<br>　　这一章讲了很多数序的证明和对于排序的根髓的分析和讲解。虽然没有仔细看完，但是里面的对于好坏题目的分类——记住固有知识的掌握和考察推理知识的区别。<br>　　<br>　　分治的方法适合模块化。<br>　　<br>　　在书的后面让我知道了《如何走出软件作坊》这本书。<br>　　<br>　　手中有锤，心中无锤。任何工具都有其使用范畴和前提。始终别忘记自己要解决的问题是什么，why永远在how之前。<br>　　<br>　　不禁想起了工作中遇到的问题，有时容易拿到锤子看什么都是钉子，有的团队都存在这种状况，对于需求，我们先要想why，而不是how。编码没有那么急，你连要做的东西是干什么的，什么场景会用都不知道，那对这个产品就么有充分的了解，做出来的东西能适合才怪呢。即使适合，那也是充当了一个代码翻译机器。没有把热情和想法融入到设计和开发之中。<br>　　<br>　　如果你心中专注与你想要解决的问题，那么你所看到的东西就会呈现出以往你没有看到的一面。<br>　　<br>　　确实是，对一个问题不停的思考，在你的头脑中占用了很多空闲的时间，那么很多触类旁通的东西都会给你启发，遇到和这个技术有关的人你也会多多询问知其所以然。就像阿基米德洗澡时得到科学启发一样。这样的故事屡见不鲜。<br>　　<br>　　普通人遵守规则，牛人无视规则，伟人创造规则。<br>　　<br>　　知其然还要知其所以然，结论只是让我们能够使用，在研究的过程中，更关心的是发现的人一步步找到问题的思路是怎么找到的，是一个什么样的历程。所以要“授人以渔”，自己的发现和经历也要记录下来，因为人会忘记，会把做到的事情想得简单。<br>　　<br>　　后面对快排和贝叶斯公式给了很好的解释，让我收益非浅。从前大学里老师讲的吐沫横飞，还是很难理解，这本书三言两语，道出真谛，也是因为有从前的基础，但是让人印象深刻，重新拾起。单凭这一点，就觉得没有白看这本书。<br>　　<br>　　总结：<br>　　<br>　　最开始读这本书以为是一本时间管理的书，后来发现，更多介绍的是如何思考，如何解题。如何更好的利用大脑。对事物怎样才能分析到根源，找到原始的成因。中间用丰富的实验和心理学原理来解释。总之就是让我们跳出固有的思维，灵活思考各种现象场景，用大脑更好的解决遇到的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　第三篇《跟波利亚学解题》&lt;br&gt;　　&lt;br&gt;　　这一章讲了很多数序的证明和对于排序的根髓的分析和讲解。虽然没有仔细看完，但是里面的对于好坏题目的分类——记住固有知识的掌握和考察推理知识的区别。&lt;br&gt;　　&lt;br&gt;　　分治的方法适合模块化。&lt;br&gt;　　&lt;br&gt;　　在书的后</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记（三）</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-three/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-three/</id>
    <published>2011-10-09T20:56:12.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二篇-思维改变生活"><a href="#第二篇-思维改变生活" class="headerlink" title="第二篇 思维改变生活"></a>第二篇 思维改变生活</h2><p>这一篇主要说的是思维对人行动的作用，从科学的角度讨论了人的惰性和人的理智之间的关系。例如为什么明明是分散注意力或者对自己实现计划没好处的事情，人就是喜欢做，都是由于我们几十万年的固化基因的缘故，由于最近的几十年世界的变革太快，已经让人类逃离了从前饥饿、竞争的日子，但是我们的进化还没有适应。</p><p>既然是这样，就有办法来克服，多学习，多思考，多想事情背后的东西，认清自己和自然规律，这样才能改变生活。</p><p>这也是我觉得最宝贵的一篇，从中学习了很多东西，也有很多警醒，同样也需要后面再多多思考来完善自己。</p><p><strong>仁者见仁智者见智？从错觉到偏见</strong></p><p>本章的具体内容见</p><p><a href="http://mindhacks.cn/2009/03/15/preconception-explained/">http://mindhacks.cn/2009/03/15/preconception-explained/</a></p><p><a href="http://mindhacks.cn/wp-content/uploads/2009/03/ambi-sun-up.jpg"><img src="http://mindhacks.cn/wp-content/uploads/2009/03/ambi-sun-up-thumb.jpg" alt="ambi_sun_up"></a></p><p><a href="http://mindhacks.cn/wp-content/uploads/2009/03/ambi-sun-down.jpg"><img src="http://mindhacks.cn/wp-content/uploads/2009/03/ambi-sun-down-thumb.jpg" alt="ambi_sun_down"></a></p><p>同样两张图片，我们看第一幅图和第二幅图分辨的凹凸点就不同，因为我们的大脑形成的自然规律是光是从上方照来的，所以按照光照来推断凹凸点。而实际上图片就是图片，点就是二维空间的点，我们的描述是加入了自己想象的描述。</p><p>由于有了丰富的“经验”才能让我们在遇到问题时快速给出解决的方案，能够联想起从前解决过的一个个子问题的解，然后把他们给连接起来。有好处，也给我们带来了思维的局限，一个只是表面和从前解决过的问题相似的问题，也许就让我们轻而易举的下了结论。所以遇到重大问题，新问题，还是要跳出来多想想，避免鲜艳假设的干扰。</p><p>一个很深刻的例子：开发多用hash存储，查询速度快，程序成熟。只要有key满足库函数hash算法，那么就选hash是没错的。然而会遇到key虽然是数据，但是是全量，所有的key都有数据，而且key本身也是整数。那么就不用使用库里的函数，用bitmap或者数组全量存储就可以了。但是之前还是有人调用hash，虽然也解决了问题，但是不是最好的方法，都是先验假设造成的。可能一个没有看过库函数的新人，会想出用数组一一映射的下标的方法。</p><p>但是先验假设也给我们很多好处，经验丰富的工程师总是能在第一时间推算出系统使用的资源数量，运行时间……</p><p><strong>我们的大脑是原始进化来的——是以眼前利益最大化的。</strong></p><p>人们会在让自己愉悦的“游戏”“美食“面前忘记学习和身材。这不一定是人本身意志不坚定的问题，而是由于远古时期人类就觉得让自己马上愉快是最重要的，已经深入了我们的基因。</p><p>书中有罗列了种种例子，都是劝说我们要正确使用理性大脑。</p><p>发现人天生就喜欢拖拉，是要尽力克服的。”做一个办事爽快隐忍的男人是多么不容易！“</p><p><strong>理智与情感</strong></p><p>很多时候人们会把一件事情的表现牵强的作为这件事情的原因。</p><p>从前也发现，在解决很久也没解决的时候，总是发现了一个未被发现的点的时候，把所有原因都归纳到他的身上，”骗“自己去理解他，然后欣然接受。</p><p>在工作中，程序运行时间长，找了好久也找不到，突然发现了一个逻辑上的bug，那么这时这个bug是可怜的，他要为所有的超时负责。</p><p>在工作中，还是要保持一个理性的头脑，冷静地分析问题的本质，不要让几个”小兵“就掩护了”大部队“行进。</p><p><strong>书是更好地思考</strong></p><p>书写是对思维的备忘，思考问题犹如在黑夜里打着手电筒往前走，没推导一步就走一小步，但是光亮范围有限。</p><p>所以遇到问题和思考成果的时候要马上记录，及时记录。发现我这边博客就记晚了，有好多当时的思想都忘了，还有如果能早记些，不停地修改，会让这篇博文更好。</p><p>同事工作中也是，有好点子要记录到文档中，发现程序更新要及时记录文档，对于早记晚记，其实工作量是一样的，不同的是早记会记录的更丰富，有更多的时间后来润色，不会忘记。</p><p>后面映照“书写”，作者提出来要让大家写博客，把自己的思考记录下来，可以传播更广，吸引志同道合的朋友。</p><p>这点我双手赞同，之所以开这个博客，也是为了这个原因，把自己的点点滴滴见解写出来，和大家交流。既可以帮助网上的朋友，也可以给自己留一份历史。</p><p><strong>写博客可以激励自己去持续学习和思考。</strong>因为没有精彩内容是没有人看的，这也是我现在面临的问题，好像现在还没写什么“干货”，不过我在努力，现在是一个储藏的时期，会慢慢积累的。</p><p>不要间断更新博客，因为一间断就会死循环，慢慢的不知道写什么然后又不写，不知道。。。</p><p>所以现在给自己的量是一周一篇，希望能够坚持下去。</p><p><strong>学会持之以恒做一件事情</strong></p><p>这也是写博客的原因之一，希望能够连续写至少三年以上，写到我三十岁吧，这样我也不会觉得这段时间虚度，同时也会敬佩自己，另外最重要的是留给自己一段从前的故事记录。多年后我会忘记一些事的，通过博客会想起来。</p><p>作者在书中对博客的内容规定要写真正思考和总结的产物。对于碎碎念这些不要写到伯克利，可以发到twitter上。</p><p>这点我也很同意，从前的博客碎碎念比较多，其实没有什么意思，又不是名人，让人看了容易烦。主要是有的是自己无病呻吟，堪称微博体，自己再看也不感兴趣。</p><p>不过微博是一个更碎碎念的地方，特别是有了“分享”功能。所以我会在博客中专门有个“碎碎念”类别。用于定期的碎碎念，但是会保证这个念的质量和数量，并且不算在每周一篇里面。用来给以后的自己看当时的心情。</p><p>不停地看从前然后更改就像是在雕刻，越来越成熟，越来越接近精品。所以博文也好长回顾，常修改。</p><p><strong>“自力归因”</strong></p><p>好事留给自己，坏事怪就客观。这也是人经常犯的一个毛病，一样，要客观地思考问题，找到问题本质，用来给自己的经验库增加内容。</p><p>“用最小的代价解决手头的问题”——这里的问题在于，难道我们计算收益的时候仅仅考虑是否解决了手头的问题吗？如果解决的过程中得到了其他的收益呢？</p><p><a href="http://mindhacks.cn/wp-content/uploads/2009/07/paradoxoflearning.jpg"><img src="http://mindhacks.cn/wp-content/uploads/2009/07/paradoxoflearning-thumb.jpg" alt="paradox-of-learning"></a></p><p>平时工作可能总会遇到这样的状况，解决了一个简单的问题用了很久，觉得代码没写多少，今天的时间浪费掉了，但是其实不是的，你有没有发现在你找问题的时候你学习了几个新的系统命令，你把源代码熟悉了，你会对项目的整体框架有充分的了解。这都是那个“life is full of surprises”。可能那天在网上看到一个新的产品，日后就能用在自己程序的开发之上。</p><p>性格要素之重要的，要学会：专注、持之以恒、自行、好奇心、自信、谦卑。Keep an open mind.</p><p>《<a href="http://blog.csdn.net/pongba/archive/2008/12/18/3549560.aspx">如何清醒地思考</a>》也是一本好的参考资料。</p><p>以上是从第二篇学到的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二篇-思维改变生活&quot;&gt;&lt;a href=&quot;#第二篇-思维改变生活&quot; class=&quot;headerlink&quot; title=&quot;第二篇 思维改变生活&quot;&gt;&lt;/a&gt;第二篇 思维改变生活&lt;/h2&gt;&lt;p&gt;这一篇主要说的是思维对人行动的作用，从科学的角度讨论了人的惰性和人的理智之间</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记（二）</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-two/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-two/</id>
    <published>2011-10-09T20:54:29.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　第一篇 暗时间<br>　　<br>　　这一篇主要讲了如何更好地利用时间，运用很多例子来支撑观点。还用自己的经历作为例子展现给读者，不禁让人佩服，相比之下觉得大学过得很惭愧。想起朋友的一句话：看到XXX后，发现原来我一直都在浪费粮食。<br>　　<br>　　过早退出是一切失败的根源。——高德纳<br>　　<br>　　兴趣遍地都是，专注和持之以恒才是真正稀缺的。<br>　　<br>　　要延长自己循环的时间，不要过早退出。成功的人不只是拥有过于常人的兴趣，更主要是有坚持下去的毅力。在从事一件自己熟悉的事情，并且能够得到他人的佩服，是再好不过的了。之后又投入到更多的时间，良性循环。<br>　　<br>　　三分钟热血是不行的，更多是持之以恒。有的时候刚读一本书，恨不得两天都看完，可是过几天连书都不看了。直到过去的时间超过了书的页数，才发现还不如每天看一页，也早都看完了。<br>　　<br>　　现在开始写博客，刚开始写肯定写的多。为了不让自己后面乏力，细水长流，订了一个简单的目标，一周写一篇，相信如果坚持下去会有好的收益的。<br>　　<br>　　在生活和工作中，不管做什么，如果确定是一件有意义的事，那么一定要坚持下去，一曝十寒不如细水长流，切记切记。<br>　　<br>　　别把不知道当作没有<br>　　<br>　　信心，是这样一种奇怪的东西，就算你没有确切的证明未来会更好，你也会坚持下去，你不会过早退出循环；而来源于过来人的信息则是信心最靠谱的保障。<br>　　<br>　　人还是要有自信，对于现在的工作，并不是什么很难很需要天赋的。其实什么需求都会处理好，都会实现的，要对自己有信心，这样才能够游刃有余，创造出新东西，好东西。不要被自己吓破了胆，什么事情没做就先否定了自己。不知道不代表没有，没看过不是没发生。什么事情还是要勇于尝试，多找人询问，特别是经历丰富。平时工作要多向老人请教，多学习，多听，虚心接受。不要觉得就自己牛叉，什么都听不进去，那样是吃亏的。特别是要做的好，得到过来人的肯定，这样就证明现在的做法是正确的，能够坚持。<br>　　<br>　　《高效能人士的七个习惯》之一要事第一。<br>　　<br>　　这个之前读过，不过没有记过笔记，后面要复习。<br>　　<br>　　最后作者举了他在大学的七年是怎么度过的。让人很佩服，大二就开始学C++读外国作品，翻译。这些到现在也没做过，好让我惭愧啊。之前一直对外文书籍有所抵触和恐惧，看来现在要开始了，这样才能在十年后掌握读外文书籍的方法。<br>　　<br>　　总之，要做事坚持，善于发现生活中的暗时间，遇事要坚持持之以恒，专注并且长期投入，才是成功的保障。<br>　　<br>　　以上是从第一篇学到的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　第一篇 暗时间&lt;br&gt;　　&lt;br&gt;　　这一篇主要讲了如何更好地利用时间，运用很多例子来支撑观点。还用自己的经历作为例子展现给读者，不禁让人佩服，相比之下觉得大学过得很惭愧。想起朋友的一句话：看到XXX后，发现原来我一直都在浪费粮食。&lt;br&gt;　　&lt;br&gt;　　过早退出是一切</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记（一）</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-a/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-dark-time-reading-notes-a/</id>
    <published>2011-10-09T20:52:46.000Z</published>
    <updated>2024-07-20T15:19:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>　　之前有朋友介绍《暗时间》这本书，说是刘未鹏写的，印象中记得作者。记得上学的时候听说过，还去过他的博客，不过现在已经忘了当初上去都干什么了。读了也有一个月了（中间有断层）。今天早上读的时候觉得有总结的必要，就由笔记开始吧。之前把很多经典的地方都记录了下来。整个阅读下来，感觉整本书引用非常多，作者见识很广，很多例子<br>　　<br>　　我还来不及消化，很容易让人忘记最初要证明的观点。总之，是本好书，值得一读。<br>　　<br>　　序言《为什么人人都该学点心理学》<br>　　<br>　　有人宁可天天花时间剪报纸上的优惠券，却对于房价的1%的优惠无动于衷吗？（《别做正常的傻瓜》）<br>　　<br>　　在生活中，这种现象屡见不鲜，不妨回想下我们的生活和工作方面的事情，很多时候都是在捡芝麻，没有去考虑投入产出比。<br>　　<br>　　人喜欢从关联当中寻找因果。<br>　　<br>　　对于很多时候，人们并不是要弄懂一个事情的前因后果，更多的是快找到个答案来说服自己。生活就是在不断地“骗”自己，各种现象能够有个充分的解释，只要能接受就行了。<br>　　<br>　　就像说古代的迷信，古人用那套理论可以解释通罢了。若干年后的人们看今天的科学，也许也会觉得不可思议吧。<br>　　<br>　　在工作中，一个bug调了很久，终于找到了bug出现的地方。除了欣喜之外，和这个bug有关的罪名都推到要改进的地方了。因为这里有个问题，所以bug都是他产生的，殊不知那只是个小弟，冰山一角。所以在平时的思考中要分清什么是充分、必要条件，尽量客观地证明一件事的收益和代价。就像《教父》中的台词“不要恨你的仇人，它会干扰你冷静思考”。<br>　　<br>　　有多少捷径，就有多少谬误。<br>　　<br>　　每一条捷径都是一把双刃剑。<br>　　<br>　　一方面有助于迅速判断，另一方面导致把大脑里的理论当成放之四海而皆准的。<br>　　<br>　　经验多的人更容易犯严重错误，因为已经熟悉了，小的问题不能够干扰他，总能明察秋毫。但是遇到一些特殊的情况，就容易套用已有经验，导致分析错误，方法不对，最终犯下大错。就像打赌通常都是先让人赢一点，之后再遇到相同的局面的牌就认为可以多下注了。例如在运维项目中，可能发现存储满了，想到的马上是扩容，存储量变大了。这在大多数都是正确的，也是需要处理应急最重要的。但是不只这些，如果增长很快，还应该查询下程序是否正常，是不是bug导致写过多？或者重复请求。真的是业务过来的吗，能不能是攻击？<br>　　<br>　　其实上面想的这些多想的部分也是经验积累，也可能百密必有一疏。总之在遇到问题的时候，要先用已有的知识过滤问题。但不仅限于此，每次都要从新的角度对待，对比和之前情况有什么不同，是不是从前的积累库的情况只是当前现象的一个特例？<br>　　<br>　　人类的大脑是奇妙的，人类的心理变化也不只是大脑就能够掌握的。尽量做自己的主人，遇事情多想，多研究。借鉴书籍和前人的总结和经验，但不局限于此，善于发现事务的不同并分析解决。<br>　　<br>　　以上是从序言学到的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　之前有朋友介绍《暗时间》这本书，说是刘未鹏写的，印象中记得作者。记得上学的时候听说过，还去过他的博客，不过现在已经忘了当初上去都干什么了。读了也有一个月了（中间有断层）。今天早上读的时候觉得有总结的必要，就由笔记开始吧。之前把很多经典的地方都记录了下来。整个阅读下来，感</summary>
      
    
    
    
    <category term="读书" scheme="https://yunpengzhang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>find命令总结</title>
    <link href="https://yunpengzhang.github.io/2011/2011-10-10-find-command-summary/"/>
    <id>https://yunpengzhang.github.io/2011/2011-10-10-find-command-summary/</id>
    <published>2011-10-09T20:49:46.000Z</published>
    <updated>2024-07-20T15:19:39.315Z</updated>
    
    <content type="html"><![CDATA[<p>　　中午有个同事要使用find来查找删除文件，之前也查过不少次，这次把常用的功能记录下来，少做重复功。具体详细的可以参考man和《Linux文件查找命令find,xargs详述》。<br>　　<br>　　一、find命令的格式<br>　　<br>　　1.find命令一般格式<br>　　<br>　　find pathname -options [-print -exec -ok …]<br>　　<br>　　2.exec和ok命令区别<br>　　<br>　　-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和\；之间的空格。<br>　　<br>　　-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。<br>　　<br>　　exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号。<br>　　<br>　　二、应用场景<br>　　<br>　　1.在&#x2F;logs目录中查找更改时间在5日以前的文件并删除它们：<br>　　<br>　　$ find logs -type f -mtime +5 -exec rm {} ;<br>　　<br>　　注意：删除一定要小心，要先用ls或-print查看是否是要删的文件。<br>　　<br>　　2.find文件后在文件的集合中查找文件内容：<br>　　<br>　　# find &#x2F;etc -name “passwd*” -exec grep “sam” {} ;</p><p>　　sam:x:501:501::&#x2F;usr&#x2F;sam:&#x2F;bin&#x2F;bash<br>　　<br>　　3.让当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件；<br>　　<br>　　$ find . -type f -perm 644 -exec ls -l {} ;<br>　　<br>　　-perm mode:文件许可正好符合mode<br>　　<br>　　-perm +mode:文件许可部分符合mode<br>　　<br>　　-perm -mode: 文件许可完全符合mode<br>　　<br>　　4、find命令将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。<br>　　<br>　　该命令只检查三位数字，所以相应文件的后缀不要超过999。先建几个admin.log<em>的文件 ，才能使用下面这个命令<br>　　<br>　　$ find . -name “admin.log[0-9][0-9][0-9]” -atime -7  -ok rm {} ;<br>　　<br>　　&lt; rm … .&#x2F;admin.log001 &gt; ? n<br>　　<br>　　&lt; rm … .&#x2F;admin.log002 &gt; ? n<br>　　<br>　　&lt; rm … .&#x2F;admin.log042 &gt; ? n<br>　　<br>　　&lt; rm … .&#x2F;admin.log942 &gt; ? n<br>　　<br>　　5.查找有执行权限的文件（读写可能有也可能没有）<br>　　<br>　　$find . -perm +001<br>　　<br>　　6.查找所有大于1M的文件<br>　　<br>　　$find . -size +10000000c<br>　　<br>　　7.在当前目录查找，不进入子文件夹<br>　　<br>　　find . -maxdepth 1 -name “</em>.c”<br>　　<br>　　8.使用正则表达式<br>　　<br>　　# find . -regex ‘[a-z]+.c′</p><p>　　9.在当前目录查找，但不进入某些目录下<br>　　<br>　　$ find &#x2F;apps -path “&#x2F;apps&#x2F;bin” -prune -o -print<br>　　<br>　　find &#x2F;usr&#x2F;sam -path “&#x2F;usr&#x2F;sam&#x2F;dir1” -prune -o -print<br>　　<br>　　find [-path ..] [expression] 在路径列表的后面的是表达式<br>　　<br>　　find &#x2F;usr&#x2F;sam ( -path &#x2F;usr&#x2F;sam&#x2F;dir1 -o -path &#x2F;usr&#x2F;sam&#x2F;file1 ) -prune -o -print<br>　　<br>　　三、xargs<br>　　<br>　　xargs - build and execute command lines from standard input<br>　　<br>　　在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。<br>　　<br>　　而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。<br>　　<br>　　xargs使用例子<br>　　<br>　　#find . -name “file*” -print | xargs echo “” &gt; &#x2F;temp&#x2F;core.log<br>　　<br>　　# cat &#x2F;temp&#x2F;core.log</p><p>　　.&#x2F;file6<br>　　<br>　　用grep命令在所有的普通文件中搜索hostname这个词<br>　　<br>　　# find . -type f -print | xargs grep “hostname”</p><p>　　.&#x2F;httpd1.conf:#     different IP addresses or hostnames and have them handled by the<br>　　<br>　　.&#x2F;httpd1.conf:# VirtualHost: If you want to maintain multiple domains&#x2F;hostnameson your<br>　　<br>　　$ ls | xargs-t -i mv {} {}.bak<br>　　<br>　　-i 选项告诉xargs 用每项的名称替换 {}。<br>　　<br>　　-t是在执行之前把错误信息打印到标准输出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;　　中午有个同事要使用find来查找删除文件，之前也查过不少次，这次把常用的功能记录下来，少做重复功。具体详细的可以参考man和《Linux文件查找命令find,xargs详述》。&lt;br&gt;　　&lt;br&gt;　　一、find命令的格式&lt;br&gt;　　&lt;br&gt;　　1.find命令一般格式</summary>
      
    
    
    
    <category term="技术" scheme="https://yunpengzhang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
