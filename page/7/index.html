<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owenzhang的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/page/7/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2018/互联网服务线上数据迁移的原则和方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-06-29T06:12:00.000Z" itemprop="datePublished">2018-06-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%96%B9%E6%B3%95/">互联网服务线上数据迁移的原则和方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>互联网业务变更非常快，随着业务规模扩大，线上的业务也会涉及重构和迁移。比较难的就是存储迁移，可能从前的存储不适合新的业务模型了，例如从关系型数据库迁移到nosql，或者数据的存储格式发生了巨大的变化。</p>
<p>为什么说涉及数据迁移的业务最难呢？因为数据是有状态的，不像逻辑和接入层，方便灰度，即使出问题马上回滚就能恢复（如果涉及写数据也也有问题）。然而数据是有状态的，如果切换后发现新的写存储数据有问题，是很难修复的，也很难发现的。</p>
<p>任何迁移或更新，涉及到数据的，都有一个原则：要有验证比对和回滚能力。</p>
<h3 id="验证比对"><a href="#验证比对" class="headerlink" title="验证比对"></a>验证比对</h3><p>数据迁移后，要有办法验证这次迁移是成功的，没问题的。只是从代码上说，看，前后逻辑都一样，肯定没问题是靠不住的。我们要从结果，从用户的角度来验证，查看新老数据是否一致，是否有问题。</p>
<p>一般的方法是双写。老的数据库还对外服务，把写操作同步一份给新数据库，两个库一起写。把有改动的用户数据同步过来，然后再写一个同步程序，把所有用户的全量数据导过来。检测程序，能够根据每个key进行比对，定期把库里所有的数据进行新老比对，当比对率达到阈值以后。还要做一个数据比对层，用户读写的时候先走比对层，同时给新老两个逻辑层同步包，也接收回包。然后把回包进行二进制比对，保证返回给用户的数据也是一致的。</p>
<p>当都达到一致之后，就可以切换了，切换后以新层为主，老层为辅，也接收同步数据。</p>
<h3 id="回滚数据能力"><a href="#回滚数据能力" class="headerlink" title="回滚数据能力"></a>回滚数据能力</h3><p>为什么验证比对里最后老层还要接收新层的同步呢，直接切换不好吗？是因为万一切换后出现bug，发现其他地方有问题，可以马上回滚回老数据。保证线上服务正常，给开发修复bug留下充足的时间，不会有很大的时间压力。如果不能马上回滚，只能在线修bug。后续的每次发布修改，对开发的个人能力和状态依赖大，不可控因素太多。很难保证服务质量。</p>
<p>再多说一下，由于是重构，有时会发现从前数据里的错数据，或逻辑bug。不建议马上修复，新的要先和老的逻辑数据对齐，稳定后再修复老bug。否则bug改完后就没有一个标杆来验证数据是否一致了。</p>
<p>有人会说，弄这么多，得多久能完成迁移啊，效率太低。考试题目做的再快，不对也是白搭，之所以做这么多，就是保证万无一失。欲速则不达，如果数据错了再去修补，时间花费的更多，而且有时是补不回来的，只能回档，那时给用户造成的损失就大了。在QQ后台，每次数据迁移都要经过几周的发布比对才能切换，重大的数据层重构，没个一年半载达到六个9的一致性，根本不会切换的。这也是为什么一次次在行动的火车上换发动机能够成功的原因！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>涉及到数据的变更发布，要有比对能力，有从结果出发的方法，能够验证数据迁移后是正常的才可以。只从代码逻辑层面分析是不靠谱的。</p>
<p>要有plan B，如果真的有问题，要能够回滚，有回旋的余地。</p>
<p>做到以上所说，才能立于平滑迁移数据服务的不败之地！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E6%96%B9%E6%B3%95/" data-id="clyu70knd0050b0ooer1kam4e" data-title="互联网服务线上数据迁移的原则和方法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/关于排期的思考" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E5%85%B3%E4%BA%8E%E6%8E%92%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time class="dt-published" datetime="2018-06-27T15:24:33.000Z" itemprop="datePublished">2018-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E5%85%B3%E4%BA%8E%E6%8E%92%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83/">关于排期的思考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前一次例会，讨论到了排期，究竟怎样看待排期，如何能排得准，总结了一些内容。</p>
<h2 id="如何看待排期"><a href="#如何看待排期" class="headerlink" title="如何看待排期"></a>如何看待排期</h2><p>每个项目，都要有明确的deadline，越大的项目对deadline要求越明确，越不能延期。一些关乎于公司生死存亡的项目，更是上线时间点都不可变更的。 作为一个专业的程序员，给出的排期就是一份契约，答应的时间要做到，否则会影响信誉。如果中间评估时间不够，真的要延期，要提前说出来。而不要最后时刻，给人final surprise。没有按照约定完成，要反思。 项目经理要的排期既不是写代码的时间，也不是设计+实现代码的时间，而是项目上线的时间。太多的程序员把写完代码的时间，当作上线时间承诺出去，代码没上线就是不可用的，要把部署测试的时间都算进去。</p>
<h2 id="如何排期排得准"><a href="#如何排期排得准" class="headerlink" title="如何排期排得准"></a>如何排期排得准</h2><h3 id="正确地划分任务"><a href="#正确地划分任务" class="headerlink" title="正确地划分任务"></a>正确地划分任务</h3><p>大需求先分解为迭代和里程碑，再细分成小需求，分得越细，排得越准。 分成好几个迭代，有deadline的项目，要在开始前就把几个迭代的预估和需求做的范围都确定好，再排期。 防止边做边排，到最后几个迭代的时候发现有很多重要的工作没估准，导致回旋的余地很小，难以协调。因为前几个迭代把时间用光了，没有做最关键的事情。</p>
<h3 id="留有余地"><a href="#留有余地" class="headerlink" title="留有余地"></a>留有余地</h3><p>百密必有一疏，留有必要的缓冲时间（buffer），给突发情况。</p>
<h3 id="理解需求"><a href="#理解需求" class="headerlink" title="理解需求"></a>理解需求</h3><p>项目初期要讨论好需求，明确需求点，找到实现最小需求需要做的工作（核心需求），根据deadline中的时间资源，来决定能开发到什么程度。不要不可能而为之，最后又没完成。 需求点的明确是需要讨论和花费时间的，需要有类似流程图一样的东西来指导，开发和产品都要想自己部分的流程图，都要想清楚。开发有责任让产品想清楚，再给出准确排期。防止最后做出成品再返工。 在资源有限的情况下，要理出最小闭环需求，对需求进行取舍。 <strong>完成比完美更重要！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E5%85%B3%E4%BA%8E%E6%8E%92%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83/" data-id="clyu70kng005bb0oogiemczvh" data-title="关于排期的思考" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/改变对思考的想法——读《快思慢想》" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E6%94%B9%E5%8F%98%E5%AF%B9%E6%80%9D%E8%80%83%E7%9A%84%E6%83%B3%E6%B3%95%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E5%BF%AB%E6%80%9D%E6%85%A2%E6%83%B3%E3%80%8B/" class="article-date">
  <time class="dt-published" datetime="2018-06-18T10:00:03.000Z" itemprop="datePublished">2018-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E6%94%B9%E5%8F%98%E5%AF%B9%E6%80%9D%E8%80%83%E7%9A%84%E6%83%B3%E6%B3%95%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E5%BF%AB%E6%80%9D%E6%85%A2%E6%83%B3%E3%80%8B/">改变对思考的想法——读《快思慢想》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人类对于自己的思考了解吗？传统经济学里人都是理性的，人会理性作出决策，让利益最大化，真实的人类是这样吗？</p>
<p>心理学家，诺贝尔经济学奖得主卡尼曼的《快思慢想》，回答了以上疑问。虽然思考是习以为常的事，但是人类并不了解自己的思考方式。甚至觉得自己是懂的，但实际并清楚大脑作出决策的方式。</p>
<p>书中通过大量的示例，和严谨的实验推导，像我们展示了人类思考的方式。论证严谨，干货满满，是一本好书，值得反复阅读。</p>
<p>通过这本书，重新认识了思考，改变了对决策的认知。对于日常遇到的一些现象，也有了合理的解释。</p>
<p>下面是对本书的小结。</p>
<h2 id="系统一、系统二"><a href="#系统一、系统二" class="headerlink" title="系统一、系统二"></a>系统一、系统二</h2><p>为了理解思考方式，建立了两个虚拟的概念。系统一和系统二，是人类大脑中的两个进行思考的系统。</p>
<p>系统一是快思考，自动化运行，非常快，不费力气，不受自主控制，也关闭不掉。判断两个物体哪个更近，话语中是否有敌意，在宽广的马路上开车等场景，都是系统一在起作用。系统一不用专门控制，大脑快速反映并给出结论。</p>
<p>系统二是慢思考，用注意力去做费力的心智活动，包括复杂的计算。在人群中搜寻某个人，比较两个东西的性价比，在很窄的街道停车，这些场景都要用到系统二。要专心做要做的事情，不能分心。专注时也会忽略一些周围的事情。系统二运行会消耗人的能量。</p>
<p>系统一自动化运作，持续给系统二建议。系统二认可后转换为信念。当系统一碰到困难时，叫系统二用比较详细和特定的方式来处理问题。</p>
<p>使用系统二处理是有代价的，消耗的“能量”较大。系统二运行需要自我控制，自我控制太多会使精力损耗而且不愉快。</p>
<p><em>人的精力是有限的，把精力放到关键的事情上，事半功倍。如果放到鸡毛蒜皮的事情上，收到的效果就大打折扣。</em></p>
<p><em>人类的这种思考方式，是对人类应对自然环境，快速作出决策来生存是有利的。像《人类简史》里说的，随着人类的发展，我们所处的社会环境，自然环境和智人时代已经不同了，但是人类的身体进化却没有太大的变化。我们的思考方式也是远古时期遗传过来的方式，面对现在的经济，生活的决策，人类对概率、多维等，就没有先天优势，要不断地锻炼修改思考方式，才能在现代社会中表现的更好。</em></p>
<h2 id="注重因果，忽视统计"><a href="#注重因果，忽视统计" class="headerlink" title="注重因果，忽视统计"></a>注重因果，忽视统计</h2><p>未经过专业训练的人，对于事情的判断，很少会用统计和概率的知识，更多是基于因果关系。</p>
<h3 id="小数原则"><a href="#小数原则" class="headerlink" title="小数原则"></a>小数原则</h3><p>对一件事进行调查取样时，大样本会比小样本更值得相信。但是非专业人士没这个意识，对小样本得到结果后，系统一还会主动地编出各种原因，让自己信服，支持这个结论。</p>
<p>例如在小医院，每天生出男孩和女孩的比例，就会偏离1：1较大，因为样本太少，但是人还是会构造原因解释结论。</p>
<p>做互联网业务更要注意，要科学地取样分析，不能取太少（也不是样本取得越多越好，有合适的取样数量）。不能只看官方反馈的用户建议，也要通过多渠道去问券，防止幸存者偏差。</p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>给定一个数字，后面的谈判的结果会和这个数字差不太远，都是围绕着这个数字去谈。在谈判和砍价方面，经常有人运用这种方法。</p>
<p>书中给出了一个的例子，先给志愿者看一些无关的数字，然后再让他们估算一些事情结果的概率，发现志愿者明显被先前给的数字所影响。看较大数字的志愿者们平均估算值大，看较小数字的志愿者们平均估算值小。</p>
<h3 id="回归平均值"><a href="#回归平均值" class="headerlink" title="回归平均值"></a>回归平均值</h3><p>由于“运气”的存在，有些时候，人的表现会超乎平常。例如运动员某场比赛超常发挥，如果不是水平提高，后面会回归到自己的平均表现。但是人们却喜欢把这些归于因果，例如运动员后面的回归是太紧张了，最近没休息好等。</p>
<p>就像世界杯，冰岛队战平了阿根廷，门将扑出梅西的点球，后面比赛冰岛队也会回归平均的。但是媒体报道就会分析，冰岛门将研究了梅西，梅西状态不行了……看上去分析得头头是道。阿根廷是强队，冰岛应该是发挥超长，让我们拭目以待，看谁能走的更远。另外，媒体也不一定不懂“运气”成分，但归功于“运气”的分析，就不会更吸引观众。</p>
<h2 id="选择与风险"><a href="#选择与风险" class="headerlink" title="选择与风险"></a>选择与风险</h2><p>同样100万奖金，对于有100万，和900万的两个人，产生的效用是不一样的。对于有100万的人是20个效用，对于900万的人是4的效用。在做相同赌局的时候，两者的选择也不同。前者更倾向于风险小，即使少得一些钱，后者更倾向于风险多一点。</p>
<p>在伯努利实验里，是从期望来算的，哪个期望高选哪个，但实际人的心理是不一样的，拥有不同财产的人对下注的心理也不同。</p>
<p>现实中，不同财富拥有者选择的投资策略不同，也印证了这个观点。保险业也运用这种方法制定保费。</p>
<p>人们也会高估自己已经获得的物品价值，如果这个物品不是用来交易。例如：卖房者总是认为自己的房子是独一无二最好的，即便并不真的那么好，但是他心中是最好的。因为是他已获得的物品。</p>
<h2 id="两个自我"><a href="#两个自我" class="headerlink" title="两个自我"></a>两个自我</h2><p>人有两个自我，经验自我和记忆自我。医生检查我们的身体，按某些部位，问疼不疼，有什么反映，是经验自我。问最近怎么样，我们回答的是记忆自我。</p>
<p>对于一次一星期的旅行，结束以后，记忆里的时间只有一个半小时左右。大多数当时的体验都忘记了。除了照片能够回忆一些，很多过程中的体验都记不得了。</p>
<p>经验自我过程中经历的痛苦，在记忆自我中，可能就没那么痛苦了，因为痛苦的感觉不完全是由峰值痛苦决定的，也和结局有关。</p>
<p>遇到挫折，挺过去，就真的撑过去了。只要结局是好的，人类会忘记中间的痛苦的感觉，记忆自我中不会觉得那么痛苦。相反，对于好的体验也一样，经验自我已经很好了，但是结局不是很好，也会影响对过程幸福感的体验。例如欣赏唱片，过程很美，在最后听到了噪音也会让整段记忆毁掉。</p>
<p>幸福如何度量，也是个难题。就像在旅行中应多拍些照片，方便回忆。还是更注重过程中经验自我的体验，而尽量不让拍照影响观赏景观，要看个人选择了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>人类对于自己的思考，不是天生就了解。就像知道吃食物能够生长、健康，但并不了解身体吸收的原理。明白了蛋白质、脂肪、碳水化合物，和消化器官的原理后，就能更科学地摄取营养，控制健康。《快思慢想》对于思考的作用，也如同营养学、生物学之于身体。能够让人深入了解思考的本质，科学地做出决策。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E6%94%B9%E5%8F%98%E5%AF%B9%E6%80%9D%E8%80%83%E7%9A%84%E6%83%B3%E6%B3%95%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E5%BF%AB%E6%80%9D%E6%85%A2%E6%83%B3%E3%80%8B/" data-id="clyu70knl005ub0oo2shihzjc" data-title="改变对思考的想法——读《快思慢想》" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/XSS专题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/XSS%E4%B8%93%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2018-05-24T10:00:03.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/XSS%E4%B8%93%E9%A2%98/">XSS专题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="XSS专题"><a href="#XSS专题" class="headerlink" title="XSS专题"></a>XSS专题</h1><p>[TOC]</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>XSS（Cross-site scripting，跨站脚本）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</p>
<h2 id="2-成因"><a href="#2-成因" class="headerlink" title="2 成因"></a>2 成因</h2><h3 id="2-1-Html-JavaScript-是用户端可触达的解析性语言"><a href="#2-1-Html-JavaScript-是用户端可触达的解析性语言" class="headerlink" title="2.1 Html&#x2F;JavaScript 是用户端可触达的解析性语言"></a>2.1 Html&#x2F;JavaScript 是用户端可触达的解析性语言</h3><p>Html&#x2F;JavaScript 和 SQL 一样，都是用户端可触达的解析性语言。所以，用户可以改变最终的代码。（不同于 PHP 等，用户无法改变 PHP 的代码，只能改变数据）</p>
<p>用户可触达，所以用户就能改变代码来进行攻击。</p>
<h3 id="2-2-浏览器如何解析-html-javaScript"><a href="#2-2-浏览器如何解析-html-javaScript" class="headerlink" title="2.2 浏览器如何解析 html&#x2F;javaScript"></a>2.2 浏览器如何解析 html&#x2F;javaScript</h3><ul>
<li><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/9666.html">http://coolshell.cn/articles/9666.html</a></li>
<li><a target="_blank" rel="noopener" href="http://taligarsiel.com/Projects/howbrowserswork1.htm">http://taligarsiel.com/Projects/howbrowserswork1.htm</a><blockquote>
<p>自己的理解：浏览器接收到了后端返回的html原文件后，会生成一个DOM树，解析javaScript动作列表之类的，然后，javaScript 就在做自己的动作了。同时，浏览器会动态实时监控DOM树的变化，看是否有新的 javaScript 生成或旧的灭亡，有的话，就把其加入到动作列表或从列表中删除。</p>
</blockquote>
</li>
</ul>
<p><strong>直接插入标签是不会执行的。要创建script元素才可以。</strong><br><a target="_blank" rel="noopener" href="https://github.com/damoclesX/damoclesX.github.io/issues/17">https://github.com/damoclesX/damoclesX.github.io/issues/17</a></p>
<blockquote>
<p>结论：用户可控制的输入在前端形成了完整的 javaScript 语句，即可完成攻击。</p>
</blockquote>
<h2 id="3-分类"><a href="#3-分类" class="headerlink" title="3 分类"></a>3 分类</h2><h3 id="3-1-反射型（非持久性XSS）"><a href="#3-1-反射型（非持久性XSS）" class="headerlink" title="3.1 反射型（非持久性XSS）"></a>3.1 反射型（非持久性XSS）</h3><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">简单流程：</span><br><span class="line">    用户访问带有XSS代码的URL请求</span><br><span class="line">    服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器</span><br><span class="line">    浏览器解析带有XSS代码的数据后，最终造成XSS漏洞</span><br><span class="line">可能攻击流程：</span><br><span class="line">    • 用户aaa在网站www.xxx.com浏览网页</span><br><span class="line">    • 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码，代码功能为盗取用户Cookie并发送到指定站点www.xxser.com</span><br><span class="line">    • hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击</span><br><span class="line">    • 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com</span><br><span class="line">    • hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息</span><br></pre></td></tr></table></figure>


<h3 id="3-2-存储型（持久性XSS）"><a href="#3-2-存储型（持久性XSS）" class="headerlink" title="3.2 存储型（持久性XSS）"></a>3.2 存储型（持久性XSS）</h3><p>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">测试技巧：</span><br><span class="line">    • 首先确定输入点和输出点，比如留言，</span><br><span class="line">    如：&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot; /&gt;</span><br><span class="line">    • 确定输出点后根据相应的标签构造HTML代码来闭合，如：&quot; /&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;，最终在html中为：</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot; /&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;&quot; /&gt;</span><br><span class="line">测试步骤：</span><br><span class="line">    • 添加正常留言，用firebug快速查找显示标签，若显示区域不在html属性内则可以直接使用XSS代码注入</span><br><span class="line">    • 若不能得知内容输出的位置，可以使用模糊测试方案，XSS代码如下：</span><br><span class="line">        a. &lt;script&gt;alert(document.cookie)&lt;/script&gt;  //普通注入</span><br><span class="line">        b. &quot; /&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;   //闭合标签注入</span><br><span class="line">        c. &lt;/textarea&gt;&#x27;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;   //闭合标签注入</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="3-3-DOM-型"><a href="#3-3-DOM-型" class="headerlink" title="3.3 DOM 型"></a>3.3 DOM 型</h3><p>DOM型就完全与后端无关，是前端的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Welcome!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hi&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var pos=document.URL.indexOf(&quot;name=&quot;)+5;</span><br><span class="line">      document.write(document.URL.substring(pos,document.URL.length));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http://www.test.com/welcome.html?name=lihua</span><br><span class="line"></span><br><span class="line">http://www.test.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>








<h2 id="4-防护策略"><a href="#4-防护策略" class="headerlink" title="4 防护策略"></a>4 防护策略</h2><h3 id="4-1-危害"><a href="#4-1-危害" class="headerlink" title="4.1 危害"></a>4.1 危害</h3><blockquote>
<p>JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。</p>
</blockquote>
<ul>
<li>盗取管理员Cookie</li>
<li>XSS Worm</li>
<li>挂马(水坑攻击)</li>
<li>键盘记录(有局限性)</li>
<li>利用网站重定向</li>
<li>修改网页内容</li>
<li>等等</li>
</ul>
<h2 id="5-攻击策略"><a href="#5-攻击策略" class="headerlink" title="5 攻击策略"></a>5 攻击策略</h2><h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6 参考链接"></a>6 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://xss-game.appspot.com/">https://xss-game.appspot.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.google.com/about/appsecurity/learning/xss/">https://www.google.com/about/appsecurity/learning/xss/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/9b285eac9d60">http://www.jianshu.com/p/9b285eac9d60</a></li>
<li><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/web/40520.html">http://www.freebuf.com/articles/web/40520.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.firmianay.com/2016/03/27/xss-e5-88-9d-e5-ad-a6-e6-80-bb-e7-bb-93/">http://www.firmianay.com/2016/03/27/xss-e5-88-9d-e5-ad-a6-e6-80-bb-e7-bb-93/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/web/42727.html">http://www.freebuf.com/articles/web/42727.html</a></li>
</ul>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>Cookie可以使用httponly的方式来解决</p>
<h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://xss-game.appspot.com/">https://xss-game.appspot.com</a></p>
</blockquote>
<ol>
<li><script>alert(1)</script>
<p>反射型xss<br>后端收到来自用户的输入直接原样返回给前端</p>
</li>
<li><img src="/2018/XSS专题/undefined"  onerror="alert('1')">
单页面html已经加载完毕后，你再手动往html里面加入代码是没有意义的，因为此时的js已经编译完毕了，不再读取html中的js代码，要通过js的一个语句才能重新读取某段js，加入到js编译后的代码中。（这种情况类似于：页面通过json拿回来数据，再组装到dom中。）</li>
</ol>
<p>此时，我们可以通过标签的行为来运行时执行新的js语句。</p>
<p>参考说明：<a target="_blank" rel="noopener" href="https://github.com/damoclesX/damoclesX.github.io/issues/17">https://github.com/damoclesX/damoclesX.github.io/issues/17</a></p>
<ol start="3">
<li>.jpg’ onerror&#x3D;’alert(1)’ &#x2F;&gt;&lt;img src&#x3D;’&#x2F;static&#x2F;level3&#x2F;cloud<br>正如前面说的，运行时直接插入是不行的。要再运行时执行，必须借助于标签的属性。</li>
</ol>
<p>另外这里告诉我们可以通过组装的方式。</p>
<ol start="4">
<li>这个不行   1’);alert(‘1        要用这个  1%27)%3balert(%271<blockquote>
<p>When browsers parse tag attributes, they HTML-decode their values first. <foo bar='z'> is the same as &lt;foo bar&#x3D;’&#x7a;’ 标签中的内容，浏览器会自动作html转码</p>
</blockquote>
</li>
</ol>
<p>如果你能改变属性中的值，那即使输入被作了html转义也没有用。</p>
<ol start="5">
<li><pre><code>javascript:alert(1)%3b   javascript:alert(1) 都可以
</code></pre>
</li>
</ol>
<p>a标签的href可以这样用</p>
<h3 id="这里要理清html转义（编码解码）-和-url编码解码"><a href="#这里要理清html转义（编码解码）-和-url编码解码" class="headerlink" title="这里要理清html转义（编码解码） 和 url编码解码"></a>这里要理清html转义（编码解码） 和 url编码解码</h3><p>总结，如果我们不能有效地改变源码（插入不被转意的<script>到源码中），那么就只能考虑要通过标签。如何能改变源码，就两种方式都考虑。（构造script和构造标签）</p>
<h2 id="攻击用例"><a href="#攻击用例" class="headerlink" title="攻击用例"></a>攻击用例</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.lvtao.net/dev/xss.html">https://www.lvtao.net/dev/xss.html</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;img src=&quot;a.jpg&quot; onerror=&#x27;alert(1)&#x27; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="xss绕过与白名单机制"><a href="#xss绕过与白名单机制" class="headerlink" title="xss绕过与白名单机制"></a>xss绕过与白名单机制</h2><p>富文本，通常用白名单。但是，既然是写的程序，很有可能就会被绕过白名单。<br><a target="_blank" rel="noopener" href="http://blog.idhyt.com/2014/10/15/technic-xss-bypass/">http://blog.idhyt.com/2014/10/15/technic-xss-bypass/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.lvtao.net/dev/xss.html">https://www.lvtao.net/dev/xss.html</a></p>
<p>这个白名单绕过的机制，可以在前端可以自己过滤一遍收到的数据，后端必须要先过滤一下</p>
<h2 id="防御与监控"><a href="#防御与监控" class="headerlink" title="防御与监控"></a>防御与监控</h2><p><a target="_blank" rel="noopener" href="http://www.freebuf.com/articles/web/110583.html">http://www.freebuf.com/articles/web/110583.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/XSS%E4%B8%93%E9%A2%98/" data-id="clyu70kn2004ib0oo2lop9680" data-title="XSS专题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/两个解决并发问题的案例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A1%88%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2018-05-21T14:15:19.000Z" itemprop="datePublished">2018-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A1%88%E4%BE%8B/">两个解决并发问题的案例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近和zhiyong聊天，有两个关于并发的场景比较有意思，记录下思考的过程。</p>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>A和B在微信里发消息，如果A发的消息顺序是A1，A2，A3，B发的消息顺序是B1，B2，B3。</p>
<p>两个问题：</p>
<ol>
<li>如果A2由于网络原因，比A3后到服务器，B收到的消息是什么样的？</li>
<li>如果都不丢消息，A1和B1同时发出，几乎同时到服务器，再分别传给A和B，那么在聊天窗口的表现是什么？</li>
</ol>
<p>经过zhiyong的黑盒逆向测试，问题1的答案是B看到A1和A3，在A看到A2发送失败，有个红色叹号，如果点击重发，相当于发出了一个相同内容的A4。</p>
<p>问题2的答案是可能A看到的是A1，B1，B看到的是B1，A1，即在不同人之间的消息，没有严格的顺序，以客户端本地上屏的顺序为主。（在A来说，A1发完就上屏，B1是后来接收到的，就A1在上面，同理B也是）。如果这时打开一个新终端来同步，那么以服务器那份数据为主，按照时间线的顺序拉取。</p>
<p>分析</p>
<p>问题1中，在微信客户端上传消息时，应该给每条消息都加了序列号，按照发送的顺序升序，如果服务器发现序列号回跳缩小了，就丢弃掉，并返回客户端失败。这样做的好处是处理简单，不会造成用户收到一条消息，突然又蹦出一跳消息插在了前面，导致漏看消息，都是追加写。<br>当然也有另外的实现方式，就是没序号，你发什么服务器收什么，哪条先到就哪条在先，但是会有个新问题，用户本想发的是A1，A2，因为人的语言是有顺序的，但是看到的是A2，A1，有些语境乱掉的会引起歧义。</p>
<p>在丢消息和乱消息两者，选择了可以丢。</p>
<p>问题2也是，可以做到以服务器为准，纠正客户端的表现，做到强一致，但是微信认为这不是个问题，两个人同时发的哪个先哪个后不影响理解内容，以每个手机上屏时间为准。但是在同步新消息时，以服务器为准，因为此时根本没有冲突。</p>
<p>如果单纯从技术角度解决这两个问题，也有很直接的方法。对于问题一，发现漏了序号，服务器再下发一小消息，让客户端重传，然后等待重传成功再发给接收方，但这种方法复杂，出问题也不易调试，在产品需求上得不偿失。对于问题二，建立个全局id，每条消息都分个先后，对于全局id的一致和出错恢复的影响，要投入巨大精力来实现，能解决的还是个很少发生的场景问题，甚至真发生了，也不算个问题。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>用户从其他渠道拿到兑换码，然后在小米官网输入兑换码，兑换奖品，每个码只能用一次，每个用户一天只能兑换2次奖品。此时会有问题。兑换码标记失效，和给用户发奖，是两个动作，会有并发问题。两个动作的先后顺序，哪个先哪个后。是否要用事务。</p>
<p>也是两个问题：</p>
<ol>
<li>两个用户A和B用同一个兑换码同时兑换，怎么处理？</li>
<li>一个用户同时用两个兑换码兑换，发现当天只能有一次兑换机会时，两个码都失效吗，会多扣一个码吗？</li>
</ol>
<p>分析</p>
<p>方法一最简单方法，用事务，每次兑换前开启事务，兑换后结束事务。优点：代码简单。缺点：事务太重，在互联网高并发的场景中，性能不高。</p>
<p>方法二先扣兑奖次数，再失效兑换码。这种情况在两个用户用同一个码并发时，会判断都有兑换次数，都扣，但失效兑换码时，只有一个人成功，失败的那个人被多扣了一次抽奖机会。</p>
<p>方法三先失效兑换码，再扣抽奖次数。两个用户用同一个码时，后用的提示码已用过，没问题。一个用户用两个码并发时，先把两个码都失效，再根据兑奖次数，只有一个兑换码成功兑换了奖品，多扣了一个兑换码。</p>
<p>最后选择的方法三，因为两个用户用同一个码是存在的，但是一个用户同时用两个码的概率比较小，用户要输入码再点确定才行。还有如果给用户多扣了一个兑换码的情况，只有用户当天没有兑换次数的时候才出现，不会对用户造成更大的损失。后台根据告警，用修复脚本把多扣的券找出来恢复，用户第二天还能用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>并没有什么银弹，设计的那种方案的好坏，要结合具体需求，详细分析，深入思考需求的特点，在实现复杂度和满足需求找到平衡。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A1%88%E4%BE%8B/" data-id="clyu70knc004wb0ooaqm00sfb" data-title="两个解决并发问题的案例" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/理解依赖注入和控制反转" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" class="article-date">
  <time class="dt-published" datetime="2018-05-17T10:00:03.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/">理解依赖注入和控制反转</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="理解依赖注入和控制反转"><a href="#理解依赖注入和控制反转" class="headerlink" title="理解依赖注入和控制反转"></a>理解依赖注入和控制反转</h2><p>在了解lumen框架的时候有遇到这两个概念，当时看了觉得模模糊糊地明白了，但是上周在上课时发现还是没<br>理解透，又重新梳理了解了下，总算有点明白了。</p>
<h3 id="基本定义和关系"><a href="#基本定义和关系" class="headerlink" title="基本定义和关系"></a>基本定义和关系</h3><p>首先明白几个定义，然后理清他们之间的关系。</p>
<p><strong>依赖反转原则（Dependency inversion principle，DIP）</strong><br>是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p>
<p><strong>控制反转（Inversion of Control，缩写为IoC）</strong><br>是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
<p><strong>依赖注入</strong>：依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p>
<p><strong>依赖查找</strong>：依赖查找更加主动，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态</p>
<p><strong>容器</strong>：容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入（DI）”。</p>
<p><strong>反射</strong>：反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。</p>
<p>依赖反转、控制反转都是<strong>设计思想</strong>，是一种设计意识，指引方向。</p>
<p>依赖注入、依赖查找是<strong>设计模式</strong>，用来实现上面两个思想的实现方法。</p>
<p>容器可以理解为一种<strong>数据结构</strong>，是具体的编程方法。方便管理不同的类在一起管理。</p>
<p>反射是语言层面的特性，在代码运行的过程中，根据运行的中间状态来动态生成对象，让程序更灵活，简练。</p>
<blockquote>
<p>依赖反转、控制反转是设计思想，依赖注入、依赖查找是实现思想的设计模式，使用容器和反射功能，能够更好地实现两种设计模式。</p>
</blockquote>
<h3 id="用途和实例"><a href="#用途和实例" class="headerlink" title="用途和实例"></a>用途和实例</h3><p>上面理顺了几个定义和他们之间的关系，再看下知道这些关系能有什么用途呢？</p>
<p>明白了上面的关系，就知道控制反转是思想，其他下层的概念是实现这种思想的途径。这里说的用途就是这种思想的用途。</p>
<p>控制反转、依赖反转的用途，就是<strong>解耦</strong>，方便扩展，带来的好处就是代码易扩展、测试、功能更稳定等。</p>
<p>例如做日志组件，日志可以记录到磁盘、数据库、udp发包到远程。</p>
<p>按照最直观的想法，在日志类里建立一个磁盘、数据库、udp三个媒介类，根据传入参数的不同选用不同的类进行调用。</p>
<p>这样做使日志类依赖底层存储媒介的实现，如果底层增加了tcp媒介，那么要修改日志组件内的代码，造成了耦合，只要有修改，就有引入bug的风险，容易把已有的功能影响。</p>
<p>运用控制反转思想，把磁盘、数据库、udp三个媒介类在抽象出一层writer接口，每个类都按照接口的要求实现，在日志类里都和抽象的接口打交道，实现日志类时传入要实现的类的类型就可以了。</p>
<p>到这步就已经有了控制反转的思想了。</p>
<p>但怎么能更好地实现这种思想呢？</p>
<p>一种是日志的构造函数里new出每个媒体类，第二种是传递媒体类的引用，在外部new好后传进来。依赖注入说的就是第二种。以参数的形式传进来。</p>
<p>优点是新增类型不用修改构造函数；缺点是要做一些判空处理。</p>
<p>还有一种方法是依赖查找，就是在需要具体媒体类的时候，根据关键字找出一个类，实现的方法可以是在内部建立一个类的关键字和类实例的数据结构，通过关键字找到一个类的实例来执行。</p>
<p>容器可以是一个存储类的数据结构，可以用类的名字的字符串，来找到一个执行功能的类，来创建和执行。</p>
<p>反射是实现的一种方法，能够在程序运行过程中，根据程序运行中间的数据，灵活地产生出要执行的类，来实现依赖查找。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面的描述更多地是把几个概念分类，描述功能，要想应用自如，还要参考具体项目实现的代码，动手实践。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002424023">https://segmentfault.com/a/1190000002424023</a></p>
<p><a target="_blank" rel="noopener" href="https://www.insp.top/learn-laravel-container">https://www.insp.top/learn-laravel-container</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/" data-id="clyu70knn0064b0oo92v5ht64" data-title="理解依赖注入和控制反转" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/php小细节之switch中的continue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/php%E5%B0%8F%E7%BB%86%E8%8A%82%E4%B9%8Bswitch%E4%B8%AD%E7%9A%84continue/" class="article-date">
  <time class="dt-published" datetime="2018-05-04T10:00:03.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/php%E5%B0%8F%E7%BB%86%E8%8A%82%E4%B9%8Bswitch%E4%B8%AD%E7%9A%84continue/">php小细节之switch中的continue</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对于语言中的continue，大家都不陌生，是停止当前行的操作，继续下次循环。例如下面的C语言代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in case\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in case\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d in default\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d over for \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<pre><code> 1 in case
1 over for 
 2 in case
 3 in default
3 over for 
</code></pre>
<p>在case 2里遇到continue后直接跳出switch进行下一个循环，和我们平时的理解是一样的。但是在php里的时间就比较诡异了， <strong>swicth里的continue和break是相同的</strong> 。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt; <span class="number">4</span>; ++<span class="variable">$i</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">switch</span> (<span class="variable">$i</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in case\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in case\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> in default\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> over for \n&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<pre><code>1 in case
1 over for 
2 in case
2 over for 
3 in default
3 over for
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在php里switch中continue和break的实现是一样的，不要用其他语言的思维来思考，要多注意，否则会触发bug。</p>
<p>估计是设计php的时候没有参照其他语言的标准来实现，在新版本也没有修改，可能会导致老代码运行异常。</p>
<p>这个细节增加了大家学习php语言的负担，虽然不大，要专门记住。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12349826/should-i-ever-use-continue-inside-a-switch-statement">Should I ever use continue inside a switch statement?
</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/php%E5%B0%8F%E7%BB%86%E8%8A%82%E4%B9%8Bswitch%E4%B8%AD%E7%9A%84continue/" data-id="clyu70kn3004kb0oo07p8b9ok" data-title="php小细节之switch中的continue" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/如何计算在线时长" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/" class="article-date">
  <time class="dt-published" datetime="2017-12-06T12:36:11.000Z" itemprop="datePublished">2017-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/">如何计算在线时长</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>员工会登录一个内部服务系统，登录后可以选择休息或工作状态，下班时选择离开。有一个页面要实时展示员工当天休息和工作的累计时长。</p>
<p>有两个数据库表存储员工的数据。</p>
<p>员工状态表：存储员工的当前状态。</p>
<p>员工状态流水表：每次员工状态切换，存储一条日志，记录切换发生的时间，切换前状态，切换后状态。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>先建立问题的模型，一个状态图，是员工状态切换的本质。</p>
<p>如下，员工有三种状态，在状态切换时才会有时长被计算进去。其中红色的表示计算为休息时长，蓝色表示工作时长。即从休息状态转出的记录为休息时长，工作状态转出的记录为工作时长。</p>
<img src="/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/11090-20240718161055125.png" class="" title="员工状态图">

<p>建立一个新表，存储用户最近一次状态，和状态的获取时间点。还有用户当前的累计休息时长，累计工作时长。</p>
<p>用户请求到来时，通过员工状态表获取员工当前的状态，再根据新表最近的状态和时间点，计算出累计的市场，增加到累计“休息”或累计“工作”时长中。</p>
<p>如果中间有跨越每天切换的时间点，例如零点。那么先更新新表中最近一次状态为切换时间点的状态，清零累计时长，然后按状态机的方法计算累计时长。</p>
<p>计算在线时长如果每次都从日志里遍历，重复计算，是大错特错的。</p>
<p>这个问题要注意两点，已经计算过的，要存储累计数值，不要重复计算，否则后续数据增长会不可控，也消耗性能；清零时间点要做好判断，把清零时刻的状态推算出来然后再套用模型计算即可。</p>
<p>同理，计算游戏在线时长，IM隐身时长等都是一个原理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%BA%BF%E6%97%B6%E9%95%BF/" data-id="clyu70kn1004cb0oo578h12ea" data-title="如何计算在线时长" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/说说我们的负载均衡武器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2017-12-04T11:06:10.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/">说说我们的负载均衡武器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近发现，组内的小伙伴对负载均衡组件有哪些还不清楚，总结了下，希望对大家能有写用处。</p>
<p>当用户点击了一次页面，到后端server执行完返回，经过了好几次传递，每次上游调用下游，都要使用负载均衡组件。</p>
<p>使用负载均衡组件有什么好处？</p>
<ol>
<li>自动选择存活的服务器，剔除掉“死掉”的服务。</li>
<li>保证请求能够按照分配均匀地分给服务端。</li>
<li>服务端增减机器，修改配置，对客户端透明。</li>
</ol>
<p>以上几点最深的体会就是。</p>
<p>作为服务端，不必急急忙忙地恢复死掉的服务，只要有存活的节点存在即可。因为有时你可能正在吃饭或睡觉。</p>
<p>作为客户端，服务端更换你不必配合发布，减少工作量，代码不用做业务外的特殊逻辑。</p>
<p>下面我们从前到后一次看看都有哪些组件供我们使用。</p>
<img src="/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/10971-20240718184248954.jpeg" class="" title="image">


<p>如图所示，用户发起请求时，先从dns获取域名的真实ip，然后用真实ip来访问web服务器。用到了<code>tgw</code>组件。tgw对外是一个外网ip，后端挂载了多个内网实体ip。tgw会定期检测后端真实ip的服务是否存活，通过负载算法，选择存活的ip来进行访问。用户的请求会经过tgw，但是对用户来说是透明的。tgw的好处是节约外网ip，一个ip可以把一个机房的机器都挂载上。增减web server速度快，正常dns刷新要几小时到几天才全更新。</p>
<p>请求到了web server后，需要使用后端server提供的接口服务。通过CMLB组件来拉取后端的所有ip和负载分配配置，调用sdk来选择出一个最合适的ip，然后web server使用这个ip来访问后端。要接入CMLB，需要使用CMLB的sdk，在请求之前获取一次ip。虽然多加了几行代码，但是这种方式简单直观，还是web sever直接链接的后端。组件只起到了更新配置的作用。</p>
<p>但是在链接数据库，redis这些场景中，有些时候ip是写到php配置文件，或者框架配置文件中的。没有办法“多加几行选择ip的代码”。这时LB组件出现了，和tgw类似，只是都是内网ip。对服务调用方来说就是一个ip，只是在调用的过程中经过了LB的服务器做代理，他来透明的把请求转到后端适合的数据库服务器上。<br>用LB还有个注意的地方，通常LB为了节约资源，定3小时如果链接不使用，那么会自动断掉链接，对于客户端和服务器都是没有感知的，只有在下次调用时发现链接不存在了。所以要监控链接的返回值，发现连不上要重连。</p>
<p>又有个问题，CMLB和LB功能类似，是否可以互相替代呢？</p>
<p>答案是可以互相替代。LB是后来腾讯云出品的，如果没有CMLB完全可以用LB来实现同样的功能。CMLB在内部已经使用很多，相应的组件和监控也非常成熟。对于能控制代码获取ip的地方，使用CMLB。对于在配置中等写死ip的场景，使用LB。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>组件名称</th>
<th>使用场景和方法</th>
</tr>
</thead>
<tbody><tr>
<td>tgw</td>
<td>服务外网域名服务使用，同一个机房的服务器挂载到一个tgw的虚ip上。如果有提供https服务，需要把证书上传到tgw配置网页。在nginx上只提供http服务就可以。tgw会帮助做ssl校验和转换成http服务给后端。</td>
</tr>
<tr>
<td>CMLB</td>
<td>使用agent拉取远端配置ip列表，本地调用sdk获取最适合的ip和程序。</td>
</tr>
<tr>
<td>LB</td>
<td>和tgw类似，是内网版。可以给数据库、队列挂载LB的虚ip。要监控链接断开。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/%E8%AF%B4%E8%AF%B4%E6%88%91%E4%BB%AC%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AD%A6%E5%99%A8/" data-id="clyu70kn2004gb0oo9glc6njc" data-title="说说我们的负载均衡武器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/CORS（跨站资源共享）介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/CORS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2017-12-03T08:14:36.000Z" itemprop="datePublished">2017-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/CORS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E4%BB%8B%E7%BB%8D/">CORS（跨站资源共享）介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>有同学在nginx站点配置中加了一行<code>Access-Control-Allow-Origin *</code>,导致微信中业务数据异常，抓包看http头有两个Access-Control-Allow-Origin字段，一个是站点自己的域名，一个是*。 为了实现跨域资源访问，在代码和nginx配置中都加了Access-Control-Allow-Origin字段，但是浏览器有个原则，如果有两个Access-Control-Allow-Origin字段，那么都失效，哪个都不信。最终导致了微信中打开异常。 也引出了CORS。</p>
<h2 id="定义和原理"><a href="#定义和原理" class="headerlink" title="定义和原理"></a>定义和原理</h2><p>什么是CORS跨站资源共享？</p>
<blockquote>
<p>跨站源资源共享（CORS）是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略[1]，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS[2]。</p>
</blockquote>
<p>简单说，就是为了实现跨站访问资源的遍历，同时保护浏览器使用者的安全，提出的一种规范。如何保护的安全，在下一结做介绍。 在html中的图片、css、js等静态引用，和ajax发起的动态请求，都受同源策略影响。如果有跨域，都可以用CORS来实现(也有其他方法，CORS是标准)。 跨域请求主要用于： - 调用XMLHttpRequest或fetchAPI通过跨站点方式访问资源 - 网络字体，例如Bootstrap（通过CSS使用@font-face 跨域调用字体） - 通过canvas标签，绘制图表和视频。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><h3 id="CORS怎么保护安全"><a href="#CORS怎么保护安全" class="headerlink" title="CORS怎么保护安全"></a>CORS怎么保护安全</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>保护用户访问网站的安全。防止用户在A站登录授权后，在访问恶意网站B时，B站在ajax中请求A站，获取A站的信息。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>保护服务器的静态资源、接口数据等，都被自己信任的域名访问，不被其他未授权的网站拉走数据。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>在header中带上Origin字段，标明是跨域请求。如果需要发送带凭证的数据（cookie、Http认证和客户端SSL证明等），将WithCredentials设为true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>

<p>如果请求服务器是非简单请求，浏览器会发出一个OPTION请求，和服务器协商信息。</p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器处理流程： 1 http头部是否有origin字段 2 没有，当成普通请求处理。 3 有，是否method是OPTIONS（preflight） 4 不是OPTIONS（简单请求），返Allow-Origin、Allow-Credentials等，并返回正常内容。 5 是，返回Allow-Headers、Allow-Methods等，内容为空。 nginx参考配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;xxxx&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, DELETE, PUT, OPTIONS&#x27;;</span><br><span class="line">add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Accept, Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;</span><br><span class="line">if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;xxxx&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, DELETE, PUT, OPTIONS&#x27;;</span><br><span class="line">  add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Accept, Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;;</span><br><span class="line">  add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;;</span><br><span class="line">  add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line">  return 204;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、在代码或nginx一个地方修改，不要在一个http头中有多个Access-Control-Allow-Origin字段，否则会触发“起因”中的问题。 2、修改配置最好在nginx配置中修改，其次在代码中修改，但是一定不要两侧都改，容易造成两侧混乱不容易维护。 3、业务站点不要为了省事给Access-Control-Allow-Origin设置为*，权限太开会有安全隐患。 4、按规范实现的浏览器，会做拦截。如果没有填写Access-Control字段或填写错误，即使服务端返回了全部数据，浏览器也会拦截不给页面。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/69313">CORS——跨域请求那些事儿</a> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003710973#articleHeader0">浏览器和服务器实现跨域（CORS）判定的原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/CORS%EF%BC%88%E8%B7%A8%E7%AB%99%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E4%BB%8B%E7%BB%8D/" data-id="clyu70kmy0042b0oo3w0dfj3v" data-title="CORS（跨站资源共享）介绍" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>