<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owenzhang的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/page/2/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2019/Leetcode 第134场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第134场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。</p>
<p>第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。</p>
<p>通过第四题发散想一下，还是能够发现很多有意思的结论，在题解中会详细分析。</p>
<p>思考到最后，甚至想到了极限，量变引起质变。烧脑，头疼，感觉数学知识好匮乏，我要去学习了。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>今天比赛的地址 Weekly Contest 134</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134">https://leetcode-cn.com/contest/weekly-contest-134</a></p>
<h2 id="1-动石子直到连续"><a href="#1-动石子直到连续" class="headerlink" title="1. 动石子直到连续"></a>1. 动石子直到连续</h2><p>题目：移动石子直到连续(Moving Stones Until Consecutive)</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/">https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/</a></p>
<p>题意：</p>
<blockquote>
<p>三枚石子放置在数轴上，所在位置必须是整数。位置分别为 a，b，c。<br>每一回合，假设三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z &gt; 且 k !&#x3D; y。<br>当这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，可以执行的最小和最大移动次数分别是多少？</p>
</blockquote>
<p>思路：<br>每次只能移动最左侧，或者最右侧的石子往中间移动。所以z-x的值是逐渐收敛的。</p>
<p>最大次数就是一步一步往中间挪，所需的步数是z-x-2。因为z和x之间能移动的空间是z-x-1，还要去掉一个y占的位置，所以最终移动的最多步数是<code>z-x-2</code>。</p>
<p>最小步数呢？</p>
<p>最小值为0：如果x,y,z三个值本身就挨着，那么不用移动就游戏结束了。</p>
<p>最小值为1：如果x和y之间只有一个位置，那么z移动到这个空位，只移动1次也就结束了。</p>
<p>最小值为2：除了上面两种情况，每次都把x移动到y-1或把z移动到y+1，那么只要两步就结束了。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numMovesStones(int a, int b, int c) &#123;</span><br><span class="line">        if(a&gt;b)</span><br><span class="line">            swap(a,b);</span><br><span class="line">        if(a&gt;c)</span><br><span class="line">            swap(a,c);</span><br><span class="line">        if(b&gt;c)</span><br><span class="line">            swap(b,c);</span><br><span class="line">        int mx = c-b-1+b-a-1;</span><br><span class="line">        int mi = 0;</span><br><span class="line">        if(abs(c-b)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(abs(b-a)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(b-a==2||c-b==2)</span><br><span class="line">            mi=1;</span><br><span class="line">        return vector&lt;int&gt;&#123;mi,mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-边框着色"><a href="#2-边框着色" class="headerlink" title="2. 边框着色"></a>2. 边框着色</h2><p>题目：边框着色（Coloring A Border）</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/">https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/</a></p>
<p>题意：给一个二维网格，网格被分成几种区域，每个区域都被涂上了不同的颜色。然后给定一个点（x,y）和一种颜色值c。要求把这个点所在的区域边缘涂上颜色c,最后返回新的网格图。</p>
<p>思路：</p>
<p>先根据点找到整个区域的点的集合，然后判断哪些点是边缘，如果是边缘，给边缘涂色。</p>
<p>找到区域点集合可以用深度优先搜索或广度优先搜索。判定边缘，就看和二位网格的边界是否相连，还有是否上下左右有其他颜色。</p>
<p>为了方便判断，减少干扰。可以再建两个网格，一个网格标识哪些点被搜索过，一个网格标识最终涂色的网格。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    bool isEdge(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; grid, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]!=ocolor)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; visited,vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int pcolor, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isEdge(i,j,grid,ocolor))</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j]=pcolor;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j]=1;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]==ocolor&amp;&amp;!visited[x][y])</span><br><span class="line">                    dfs(grid,visited,res,x,y,pcolor,ocolor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123;</span><br><span class="line">        m=grid.size();</span><br><span class="line">        n=grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(m,vector&lt;int&gt;(n,0));</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(grid);</span><br><span class="line">        dfs(grid,visited,res,r0,c0,color,grid[r0][c0]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-不相交的线"><a href="#3-不相交的线" class="headerlink" title="3. 不相交的线"></a>3. 不相交的线</h2><p>题目：不相交的线（Uncrossed Lines）</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/">https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/</a></p>
<p>题意：</p>
<blockquote>
<p>在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
</blockquote>
<p>思路：</p>
<p>我们设函数f(x,y)标识A的前x个数字和B的前y个数字，能绘制出的最大连接数。假设A、B都是从下标1开始。</p>
<p>则f(0,y)&#x3D;0,f(x,0)&#x3D;0;</p>
<p>情况1：</p>
<p>如果<code>A[x]!=B[y]</code>，那么<code>f(x,y)=max(f(x-1,y),f(x,y-1))</code>;</p>
<p>情况2：</p>
<p>如果<code>A[x]==B[y]</code>，那么<code>f(x,y)=f(x-1,y-1)+1</code>;</p>
<p>可以看出，是一个标准的递推公式，利用两层循环就能得出答案，最后求<code>f(A.size(),B.size())</code>就是答案。</p>
<p>公式的推导如下：</p>
<p>如果两个长度为0的整数串连线，最大值肯定为0。</p>
<p>如果出现情况1，在合法的解答中，不可能出现A[x],B[y]都参与连线的情况。如果他们两个点都被别的点连线了，那么一定会出现直线相交。因为与B[y]连线的点一定小于A[x]，与A[x]连线的点的位置也一定小于B[y]。</p>
<p>如果出现情况2, 那么一定A[x]和B[y]连是最优解，其他没有比这个情况更大的解。否则A[x]和B[y]一定只有一个点参与连线（看情况1中的说明，否则会有相交）。</p>
<p>例如只有B[y]参与了连接，连了A[z]，那么A[z]一定小于A[x]，所以f(z,y)&#x3D;f(x,y)，和A[x]连B[y]的情况值一样。所以把这两个点去除得到f(x-1,y-1)再加上这两个点连上的情况，就是f(x,y)的值了。</p>
<p>看这个公式也有点眼熟原来是最长公共子序列（Longest Common Subsequences)。就是求两个字符串公共子序列的长度。例如<strong>A</strong>B<strong>C</strong>E<strong>D</strong>和<strong>A</strong>XY<strong>CD</strong>的最长公共子序列就是ACD，和上面的递推是一样的。因为子序列能够保证他们的连线不相交。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">        int m=A.size();</span><br><span class="line">        int n=B.size();</span><br><span class="line">        int v[501][501]=&#123;0&#125;;</span><br><span class="line">        for(int i=1;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i-1]==B[j-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    v[i][j]=v[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v[i][j]=max(v[i-1][j],v[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-逃离大迷宫"><a href="#4-逃离大迷宫" class="headerlink" title="4. 逃离大迷宫"></a>4. 逃离大迷宫</h2><p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/">https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/</a></p>
<p>题目：逃离大迷宫（Escape a Large Maze）</p>
<p>题意：<br>在一个10^6 乘 10^6的二维网格上，标识两个点S和T，还有最多200个障碍点。问S和T是否连通。<br>连通的定义为，从S出发，只通过上下左右移动，且障碍点是不能移动到的，最终能够移动到T。</p>
<p>思路：<br>如果网格很小比较简单，就和第二题一样，通过深搜或广搜，看是否能到达终点T即可。但是网格空间太大了。直接搜肯定超时。</p>
<p>可以从最多200个点来思考。到不了的情况就是S或T被这200个点给围住了。只要能判断是否被围住就可以了。</p>
<p>原题200个点是在最下面数据范围里写的，很隐藏，很难注意到。</p>
<p><strong>怎么判断S或T被障碍点围住呢？</strong> </p>
<p>找到200个点能够围住的最大范围包括的点数Total，从S广搜，如果已经搜到Total个空白点，还有路可走，那么这200个点肯定包围不了S点。</p>
<p>同理再判断下是否有包围住T点，两个都没被包围，则一定能走到。</p>
<p>当然，也可能两个点都被包围了，那么在搜的时候判断能直达，直接返回true就可以了。</p>
<p>200个点能够包围的最大空白部分是多少？答案是19900&#x3D;(200-1)*200&#x2F;2。</p>
<p>为什么是这个值呢？<br>如果要200个障碍点得到充分利用，包围最多的范围，那么一定要借助网格自身的边界。</p>
<p>如果是直线，相同周长，面积最大的是圆，所以围成个1&#x2F;4圆可能是答案。但是网格上的点是离散的，围成个三角形，200个点做斜边，是围成区域最大的。为什么不是圆呢，因为两个正方形，只有斜着连接，在二维表围的面积才最大。如图</p>
<p><img src="https://www.owenzhang.net/blog/wp-content/uploads/2019/04/a6bacec19fccfc0d0c64facc89919cd4.png"></p>
<p>如上图，最开始是黄色的布局障碍。此时有1、3、5三个点是在统一垂直方向，这时让1移动到2会更好，多围一个点，把3移动到4也会多一个点。同理5-&gt;6,4-&gt;7,2-&gt;8最终形成一个斜线，达到蓝色部分。就能围住的点最多了。那点有多少个呢？设斜边的长度为n个方块。则围住的总面积块数等于1+2+3+…+n-n&#x3D;n*(n-1)&#x2F;2。</p>
<p>有两个问题：</p>
<p><strong>1. 为什么连续区间周长最大的是圆，而在二位方块中最大的是三角形？</strong></p>
<p>因为对于每个小方块，能够贡献的长度只有自己的边长和内部的斜对角线长度，没有圆的弧线。这样斜对角线就是获取最长长度的最优解。</p>
<p><strong>2. 一个3×3方块围成的图形，面积是9，周长是12。但是周长上的边的方块一共有多少个？</strong></p>
<p>这个问题的第一反应是3×3&#x3D;9，但实际围成外围的方块数是2×4&#x3D;8。就像题目中说的200个点，如果围个正方形，那么肯定不是边长为50的，而是51。因为四个角的方块是两个边公用的，如果在连续空间中，只是一个点，但是在离散中，这个点就是个面积了。</p>
<p>上面说的这些有什么用呢？</p>
<p>生活中，家里铺地砖，不理解会算错。</p>
<p>工作中，做计算机图形展示程序，或者做显示器上的运算，都是离散像素点，理解好会有有助于实现。</p>
<p>又衍生了几个问题需要研究：</p>
<p>现实世界中有绝对的圆吗?世界是离散的还是连续的?微分到一定的量就出现了无理数π。这个值是怎么得出来的，他和自然有什么关系，在宇宙中是什么存在？有没有的时空，或者什么情况下又出现新的无理数替代掉π？？？</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int,unordered_map&lt;int, int&gt;&gt; position;</span><br><span class="line">    const int kBlock = 1;</span><br><span class="line">    const int kSource = 2;</span><br><span class="line">    const int kTarget = 3;</span><br><span class="line">    const int kMaxPosNum = (1+200)*200/2-200;</span><br><span class="line">    int R=1e6;</span><br><span class="line">    int C=1e6;</span><br><span class="line">    bool bfs(int sx, int sy, int sourceFlag, int targetFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;sx,sy&#125;);</span><br><span class="line">        int total = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int i = p.first;</span><br><span class="line">            int j = p.second;</span><br><span class="line">            if(position[i][j]==targetFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            total++;</span><br><span class="line">            if(total&gt;kMaxPosNum)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            int dx[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">            int dy[]=&#123;0,0,-1,1&#125;;</span><br><span class="line">            for(int k=0;k&lt;4;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = dx[k]+i;</span><br><span class="line">                int y = dy[k]+j;</span><br><span class="line">                if(x&gt;=0&amp;&amp;x&lt;R&amp;&amp;y&gt;=0&amp;&amp;y&lt;C&amp;&amp;position[x][y]!=sourceFlag&amp;&amp;position[x][y]!=kBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    position[x][y] = sourceFlag;</span><br><span class="line">                    q.push(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) &#123;</span><br><span class="line">        for(int i=0;i&lt;blocked.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            position[blocked[i][0]][blocked[i][1]]=kBlock;</span><br><span class="line">        &#125;</span><br><span class="line">        position[source[0]][source[1]]=kSource;</span><br><span class="line">        position[target[0]][target[1]]=kTarget;</span><br><span class="line">        return bfs(source[0], source[1], kSource, kTarget)</span><br><span class="line">            &amp;&amp; bfs(target[0], target[1], kTarget, kSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knv006sb0oobettbt7d" data-title="Leetcode 第134场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第135场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第135场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这周比赛的题目很有特点。几道题都需要找到一定的技巧才能巧妙解决，和以往靠数据结构的题目不太一样。</p>
<p>就是如果懂原理，代码会很简单，如果暴力做，也能做出来，但是十分容易出错。</p>
<p>第四题还挺难想的，想了好久才想明白。这次先讲第四题，然后再讲其他的题目。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 135 </p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-135">https://leetcode-cn.com/contest/weekly-contest-135</a> </p>
<h2 id="移动石子直到连续-II"><a href="#移动石子直到连续-II" class="headerlink" title="移动石子直到连续 II"></a>移动石子直到连续 II</h2><p><strong>题目：</strong>移动石子直到连续 II(Moving Stones Until Consecutive II)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-135/problems/moving-stones-until-consecutive-ii/">https://leetcode-cn.com/contest/weekly-contest-135/problems/moving-stones-until-consecutive-ii/</a></p>
<p><strong>题意：</strong></p>
<p>在数轴上摆放了n个石子，石子位置都是整数，并且不能重叠。游戏规则是：每个回合，将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。无法移动时游戏停止。</p>
<p>问最小和最大移动次数分别是多少。</p>
<p><strong>思路：</strong></p>
<p>题目是上周第一题的扩展，但是有点不同。</p>
<p>由题意可知，每进行一轮操作，石子的左右端点的距离会缩短，一轮一轮收敛。最后会石子都紧邻游戏结束。</p>
<p>举个例子：</p>
<p>初始时有8颗石子，在数轴上的有石子的刻度为：</p>
<p>4，6，8，9，15，16，19，20</p>
<p><strong>最大值求解方法：</strong></p>
<p>石子可以放置的空间，等于左右两端石子之间的未占用位置。在例子中，一共有20-4+1-8个位置。</p>
<p>石子覆盖的线段长度是20-4个，加上一个端点的位置即20-4+1，再减去已经占用的8个位置。</p>
<p>用公式表示为</p>
<p><code>s1=stones[n-1]-stones[0]+1-n</code>。</p>
<p>但是第一次移动的左端点或右端点的石子后，这个移动的石子和它相邻的那颗石子之间的空间，后面就不能被放置了，因为与他相邻的那个点变为端点，他们之间的位置不可以被放置了。</p>
<p>例如第一步移动了4，那么5这个位置就不可能放置石子了。所以要计算不能被访问的空间</p>
<p><code>s2=min(stones[n-1]-stones[n-2]-1, stones[1]-stones[0] -1)</code>。</p>
<p>最大值为<code>s1-s2</code>。因为在后面的步骤里，我们都可以做出策略，让每一轮左右端点的差值只减1。</p>
<p><strong>最小值求解方法：</strong></p>
<p>如果最后游戏结束，那么一定有n个连续坐标摆满了石子。如果我们要移动最少，必定要找一个石子序列，使得在n大小连续的坐标内，初始时有最多的石子。</p>
<p>设想有个尺子，上面有n个刻度点，我们用这个尺子在石子从最左边到最右边移动，每动一次都查看下在尺子范围内有m个石子，那么要使这个区间填满，就需要移动n-m次。</p>
<p>只要在尺子外部有石子，就有策略填满尺子内的。</p>
<p>这些次数中最小的就为虽少次数。</p>
<p>但是有一种特例：</p>
<p>1，2，3，4，7</p>
<p>这种1-4是最好的序列，但是7不能移动到端点，只能1先移动到6，然后7移动到5解决，这种情况要用2步。就是尺子内的石子都是连续的，中间没空洞，只在边上有空，要用2次。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numMovesStonesII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(stones.<span class="built_in">begin</span>(),stones.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mx = stones[n - <span class="number">1</span>] - stones[<span class="number">0</span>] + <span class="number">1</span> - n;</span><br><span class="line">        mx -= <span class="built_in">min</span>(stones[n<span class="number">-1</span>]-stones[n<span class="number">-2</span>] - <span class="number">1</span>, stones[<span class="number">1</span>]-stones[<span class="number">0</span>] <span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> mi = mx;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j + <span class="number">1</span> &lt; n &amp;&amp; stones[j + <span class="number">1</span>] - stones[i] + <span class="number">1</span> &lt;= n)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="type">int</span> cost = n - (j - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j - i + <span class="number">1</span> == n - <span class="number">1</span> &amp;&amp; stones[j] - stones[i] + <span class="number">1</span> == n - <span class="number">1</span>)</span><br><span class="line">                cost = <span class="number">2</span>;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;mi, mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="有效的回旋镖"><a href="#有效的回旋镖" class="headerlink" title="有效的回旋镖"></a>有效的回旋镖</h2><p><strong>题目：</strong>有效的回旋镖(Valid Boomerang)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-135/problems/valid-boomerang/">https://leetcode-cn.com/contest/weekly-contest-135/problems/valid-boomerang/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。<br>给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>题目说是回旋镖，其实就是三角形。只要能判断三点不共线就可以。</p>
<p>方法一：简单的想法可以用斜率和截距的方法，判断三点共线。</p>
<p>缺点：要用到除法，可能有精度问题，而且要考虑和坐标轴平行的特殊情况。</p>
<p>方法二：利用三角形变长的性质，两边之和大于第三边。</p>
<p>缺点：也存在用开方的操作，可能有精度问题。</p>
<p>方法三：最优的方法。利用向量叉积。因为a×b&#x3D;|a|.|b|sinθ。如果共线sinθ为0。</p>
<p>向量叉积后还是的向量，这个向量的长度是两个向量所组成平行四边形的面积。如果共线，这个值为0。</p>
<p>具体可以参考维基百科：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF">https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF</a></p>
<p><img src="https://www.owenzhang.net/blog/wp-content/uploads/2019/05/cross.png" alt="叉乘公式"></p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBoomerang</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x1=points[<span class="number">0</span>][<span class="number">0</span>],y1=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x2=points[<span class="number">1</span>][<span class="number">0</span>],y2=points[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x3=points[<span class="number">2</span>][<span class="number">0</span>],y3=points[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cross = (y3-y1)*(x2-x1) - (y2-y1)*(x3-x1);</span><br><span class="line">        <span class="keyword">return</span> cross != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="从二叉搜索树到更大和树"><a href="#从二叉搜索树到更大和树" class="headerlink" title="从二叉搜索树到更大和树"></a>从二叉搜索树到更大和树</h2><p><strong>题目：</strong></p>
<p>从二叉搜索树到更大和树(Binary Search Tree to Greater Sum Tree)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-135/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/contest/weekly-contest-135/problems/binary-search-tree-to-greater-sum-tree/</a></p>
<p><strong>题意：</strong></p>
<p>修改树的每个节点的值，为访问的所有节点的和，包括当前节点。<br>访问的次序是先访问右子树，再访问根节点，再访问左子树。</p>
<p><strong>思路：</strong></p>
<p>代码比较简单，递归实现。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">bstToGst</span>(root-&gt;right);</span><br><span class="line">        ans+=root-&gt;val;</span><br><span class="line">        root-&gt;val=ans;</span><br><span class="line">        <span class="built_in">bstToGst</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a>多边形三角剖分的最低得分</h2><p><strong>题目：</strong>多边形三角剖分的最低得分(Minimum Score Triangulation of Polygon)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-135/problems/minimum-score-triangulation-of-polygon/">https://leetcode-cn.com/contest/weekly-contest-135/problems/minimum-score-triangulation-of-polygon/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p>
<p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>选定凸多边形的一条边为底（A[0]A[N-1]组成的线段），和A[i]为顶点，可以把凸多边形分为三部分，左侧A[0]A[1]…A[i]组成的凸多边形，右侧A[i]A[i+1]…A[N-1]组成的凸多边形，还有A[0]A[i]A[N-1]组成的三角形。</p>
<p>两个凸多边形还可以再递归分解，最后比较出最优解。递归算过的形状不用重复计算，可以用记忆化搜索，记录中间结果。</p>
<p>如果凸多边形只有两个点，那么组成不了三角形，可以直接返回权值为0。</p>
<p>递推公式为：</p>
<p>设w(i,k,j)为i,j,k三个点组成的三角形的权值。</p>
<p><code>v[i][j]=0</code> (当i+1&#x3D;&#x3D;j时)</p>
<p><code>v[i][j]=v[i][k]+v[k][j]+w(i,k,j)</code> </p>
<p>（当i + 1 &lt; j时, i &lt; k &lt; j)</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">51</span>][<span class="number">51</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">w</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A[i]*A[j]*A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;<span class="type">int</span>&gt;&amp; A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==j<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(memo[i][j]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        memo[i][j]=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i<span class="number">+1</span>; k &lt; j; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">dfs</span>(i, k, A) + <span class="built_in">w</span>(i, k, j, A) + <span class="built_in">dfs</span>(k, j, A);</span><br><span class="line">            memo[i][j] = <span class="built_in">min</span>(ans, memo[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n<span class="number">-1</span>, A);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knv006ub0oo133septi" data-title="Leetcode 第135场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第136场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC136%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC136%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第136场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>周日的比赛的时候正在外面办事，没有参加。赛后看了下题目，几道题除了表面要考的内容，还是有些能发散扩展的地方。</p>
<p>做题目不是最终目的，通过做题发现知识盲区，去研究学习，才能不断提高。</p>
<p>理论和实际是有关系的，一些题目也都有现实意义。计算机的一些模拟操作，通过数学算法，能够大大减轻代码量和算法复杂度。</p>
<p>第一题是机器人在坐标系上直走和转弯，通过简单的模拟就能实现。但是仔细思考发现还能通过线性代数，坐标变换的方式做，这样在实际中计算更快。甚至还可以用复数来做。</p>
<p>实际扫地机器人可能就用到了类似的算法。让他能够不至于始终原地打转。</p>
<p>第四题是典型的后缀树、后缀数组应用，找字符串最长重复子串。在搜索引擎，或DNA检测中，都是有实际使用场景的。在70年代就已经有应用了，是一个很经典的算法。而且在90年代至今，一直有科学家提升创建后缀树和后缀数组的时间复杂度。这个算法也是在不断发展的。而且在2016年中国的<code>李志泽，李建和霍红卫</code>三位科学家提出了线性时间复杂度，常数空间的最优构造算法。是中国人对算法的贡献。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 136</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-136">https://leetcode-cn.com/contest/weekly-contest-136</a> </p>
<h2 id="困于环中的机器人"><a href="#困于环中的机器人" class="headerlink" title="困于环中的机器人"></a>困于环中的机器人</h2><p><strong>题目：</strong></p>
<p>困于环中的机器人(Robot Bounded In Circle)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/">https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/</a></p>
<p><strong>题意：</strong></p>
<p>在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：</p>
<p>“G”：直走 1 个单位<br>“L”：左转 90 度<br>“R”：右转 90 度</p>
<p>机器人按顺序执行指令 instructions，并一直重复它们。</p>
<p>只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。</p>
<p><strong>思路：</strong></p>
<p>假设机器人重复走N次指令后，面朝北：</p>
<p>此时如果坐标在原点，则N次循环后就会重复从前的路径。</p>
<p>如果坐标不在原点，此时把当前位置当作原点，就会每N次移动远离一段和当前原点的距离。距离最初的（0，0）位置越来越远。就不存在循环会最原始原点的问题。</p>
<p>其实至多经过四次，机器人就会面朝北。</p>
<p>经过一次指令后，机器人面朝西或东，相当于逆时针或顺时针转了90度，则再经过三次，就面朝北了。</p>
<p>经过一次指令后，朝南则转了180度，共移动两次指令后朝北。</p>
<p>数学方法：</p>
<p>还可以把指令集先计算一遍，得出经过一个指令集后的相对移动位置和方向转角。用矩阵计算，就不用每次都运行一大堆指令模拟，加快运算速度；</p>
<p>还可以用复数来运算，复数对于转90度有简单的运算方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRobotBounded</span><span class="params">(string instructions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dir[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch : instructions)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x+=dir[i][<span class="number">0</span>];</span><br><span class="line">                y+=dir[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                i%=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">                i--;</span><br><span class="line">                i%=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;<span class="keyword">while</span>(i!=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="不邻接植花"><a href="#不邻接植花" class="headerlink" title="不邻接植花"></a>不邻接植花</h2><p><strong>题目：</strong></p>
<p>不邻接植花(Flower Planting With No Adjacent)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/">https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/</a></p>
<p><strong>题意：</strong></p>
<p>在一个无向图中，每个点的出度都不超过3。有四种颜色，给每个点着色，要求有边相连的点颜色不同。</p>
<p>给出着色方案。</p>
<p><strong>思路：</strong></p>
<p>由于每个点出度不超过3，四个颜色，肯定可以有解。暴力枚举即可。由于图的点很多，边少。在寻找和点相连的点时，不要按点遍历，要按边遍历，否则会超时。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; mr;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; N)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> color=<span class="number">1</span>;color&lt;=<span class="number">4</span>;++color)</span><br><span class="line">        &#123;</span><br><span class="line">            res[index<span class="number">-1</span>] = color;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp; tmp = mr[index];</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it=tmp.<span class="built_in">begin</span>();it!=tmp.<span class="built_in">end</span>();++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res[it-&gt;first<span class="number">-1</span>]==color)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">dfs</span>(index<span class="number">+1</span>, N);</span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="type">int</span> N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        res.<span class="built_in">resize</span>(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;paths.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = paths[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = paths[i][<span class="number">1</span>];</span><br><span class="line">            mr[x][y] = <span class="number">1</span>;</span><br><span class="line">            mr[y][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分隔数组以得到最大和"><a href="#分隔数组以得到最大和" class="headerlink" title="分隔数组以得到最大和"></a>分隔数组以得到最大和</h2><p><strong>题目：</strong></p>
<p>分隔数组以得到最大和(Partition Array for Maximum Sum)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/">https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/</a></p>
<p><strong>题意：</strong></p>
<p>给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。</p>
<p>返回给定数组完成分隔后的最大和。</p>
<p><strong>思路：</strong></p>
<p>该问题可以划分为子问题求解。</p>
<p>设数组有N个元素A[0]A[1]…A[N-1]，sum(i)表示从A[i]~A[N]求解的最大和。</p>
<p>则sum(i) &#x3D; max( max(A[i]-A[i+m-1])*m + sum(m) )  其中i&lt;&#x3D;m&lt;&#x3D;k;</p>
<p>就是每个从i开始到数组结尾的最大和，等于前m个元素单独划分，再加上剩下元素的最大和。这k中划分方案最大的，就是从i开始到数组结尾最大和最大的。</p>
<p>依次计算到第0个位置结束。</p>
<p>为了计算统一，会用到sum(n),实际没有这个元素，初始化零计算即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&lt;i+K &amp;&amp; j &lt; n ;++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    ma = <span class="built_in">max</span>(ma, A[j]);</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], ma*(j - i + <span class="number">1</span>) + dp[j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长重复子串"><a href="#最长重复子串" class="headerlink" title="最长重复子串"></a>最长重复子串</h2><p><strong>题目：</strong></p>
<p>最长重复子串(Longest Duplicate Substring)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/">https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/</a></p>
<p><strong>题意：</strong></p>
<p>给出一个字符串 S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。</p>
<p>返回任何具有最长可能长度的重复子串。（如果 S 不含重复子串，那么答案为 “”。）</p>
<p><strong>思路：</strong></p>
<p>后缀数组教科书般的例题。</p>
<p>后缀数组是后缀树的一种变种，能够节省空间。构造的方法有「倍增算法」，「DC3算法」。</p>
<p>主要思想：</p>
<p>设字符串为S(1-n)由n个字符组成。则字符串有n个相同后缀的子串。分别为s(1-n),s(2-n),…,s(n-n)。</p>
<p>然后构建一个SA数组，每个数组存储这些后缀的子串，存储后进行字典序排序。</p>
<p>最后构造出一个height数组，表示SA数组每个元素和前一个元素相同前缀的字符个数。</p>
<p>那么，最长重复子串的长度就是height数组的最大值。</p>
<p>因为最长重复子串一定是两个不同后缀的公共前缀，而且这两个不同后缀的字典序排列后一定是相连的。否则一定有比他更长的。</p>
<p>所以height的最大值能够找到那两个后缀，然后提取公共前缀就找到答案。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SA</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">da</span><span class="params">(<span class="type">int</span> str[], <span class="type">int</span> sa[], <span class="type">int</span> rank[], <span class="type">int</span> height[], <span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i, j, p, *x = t1, *y = t2;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        c[x[i] = str[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        sa[--c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = n - j; i &lt; n; i++)</span><br><span class="line">            y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt;= j)</span><br><span class="line">                y[p++] = sa[i] - j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        p = <span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            x[sa[i]] = <span class="built_in">cmp</span>(y, sa[i - <span class="number">1</span>], sa[i], j) ? p - <span class="number">1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            k--;</span><br><span class="line">        j = sa[rank[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (str[i + k] == str[j + k])</span><br><span class="line">            k++;</span><br><span class="line">        height[rank[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num_rank[MAXN], height[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="type">int</span> sa[MAXN];</span><br><span class="line">&#125; <span class="comment">// namespace SA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> SA;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = S[i]&amp;<span class="number">0x3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">da</span>(num, sa, num_rank, height, n, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; len)</span><br><span class="line">            &#123;</span><br><span class="line">                pos = sa[i];</span><br><span class="line">                len = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S.<span class="built_in">substr</span>(pos, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC136%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knw006wb0ood2xmanie" data-title="Leetcode 第136场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第137场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC137%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC137%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第137场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天的比赛的题目相对来说比较「直白」，不像前几周都是一些特定的算法，如果你没学过不可能想出来。</p>
<p>做了这些周，对leetcode比赛的题目也发现了一些「规律」。 <strong>一般前两道题都很「简单」</strong>，只要有想法，直接敲代码就能解出来。更多考察的是结果是否正确，速度其次。</p>
<p><strong>后两道题有些难度</strong> ，不同场次难度不一样，也可能和不同人的水平感受不同。但是肯定比前两道要难。</p>
<p>一般在做后两道题的时候，只要复杂度是对的，一些细节也不用考虑太多。例如数组开的空间大小，一些线性的提前剪枝判断，写不写都可以过。<strong>最主要的是复杂度是同一个量级的。</strong></p>
<p>相信leetcode这么设计是为了「人性化」，让选手更关注比赛题目核心，能够在一个半小时内完成比赛题目。</p>
<p>总之leetcode的比赛还是很人性化，很注重主要考点，不纠结于细节。利用这些特性，可以在比赛中排除一些错误想法。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 137</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-137">https://leetcode-cn.com/contest/weekly-contest-137</a></p>
<h2 id="1-最后一块石头的重量"><a href="#1-最后一块石头的重量" class="headerlink" title="1. 最后一块石头的重量"></a>1. 最后一块石头的重量</h2><p><strong>题目：</strong></p>
<p>最后一块石头的重量(Last Stone Weight)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight/">https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>一个数组，每次把最大的两个数拿出来相减，然后把绝对值放回原数组。一直重复到最后只剩下一个元素，输出即可。</p>
<p>典型的模拟题，按照题目的意思写即可。可以用堆来实现，每次拿堆顶的两个最大元素。</p>
<p>由于是第一题，每次都排序一遍，也能通过。不过在日常工程中，还是老老实实用堆来实现吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt; <span class="type">int</span> &gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;stone : stones)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(stone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> z = <span class="built_in">abs</span>(x-y);</span><br><span class="line">            q.<span class="built_in">push</span>(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除字符串中的所有相邻重复项"><a href="#2-删除字符串中的所有相邻重复项" class="headerlink" title="2. 删除字符串中的所有相邻重复项"></a>2. 删除字符串中的所有相邻重复项</h2><p><strong>题目：</strong></p>
<p>删除字符串中的所有相邻重复项(Remove All Adjacent Duplicates In String)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-137/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode-cn.com/contest/weekly-contest-137/problems/remove-all-adjacent-duplicates-in-string/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>类似于游戏「爱消除」，相同的两个字母抵消掉，形成的新字符串再接着抵消，直到稳定为止。</p>
<p>用栈来实现，遍历字符串的每个字符。如果栈为空，则插入字符，否则比较字符和栈顶元素，相同则弹出栈顶元素，不同则压栈。</p>
<p>最后输出栈内的字符串即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">top</span>()==ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-最长字符串链"><a href="#3-最长字符串链" class="headerlink" title="3. 最长字符串链"></a>3. 最长字符串链</h2><p><strong>题目：</strong></p>
<p>最长字符串链(Longest String Chain)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-137/problems/longest-string-chain/">https://leetcode-cn.com/contest/weekly-contest-137/problems/longest-string-chain/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出一个单词列表，其中每个单词都由小写英文字母组成。</p>
<p>如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，”abc” 是 “abac” 的前身。</p>
<p>词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;&#x3D; 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。</p>
<p>从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>这道题本质是图算法。</p>
<p>分两步解：</p>
<p>第一步先构造出每个单词之间的关系，判断任意两个单词是为前身后继关系。构造完关系就能画出了图。</p>
<p>第二步就是求解这个图中最长路径。由于是单向有向图，而且没有环。</p>
<p>构造一个集合，每次给集合放入新的点A，都判断集合中其他的点到该点的距离，取最大值为集合内部到新点A的最大距离L。下次再加入新的点A1，如果A和A1连通，则集合到A1的距离为L+1。</p>
<p>由于终点有多个，最后要遍历所有点的最长距离。</p>
<p>其实这道题的思想和Dijkstra算法是一样的。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string&amp; s1, string&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = s<span class="number">1.l</span>ength();</span><br><span class="line">        <span class="type">int</span> len2 = s<span class="number">2.l</span>ength();</span><br><span class="line">        <span class="keyword">if</span>(len1<span class="number">+1</span>!=len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string&amp; w1, string&amp; w2)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">return</span> w<span class="number">1.l</span>ength()&lt;w<span class="number">2.l</span>ength();</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">canChange</span>(words[i], words[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lcnt</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[j][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = lcnt[j]<span class="number">+1</span>;</span><br><span class="line">                    lcnt[i] = <span class="built_in">max</span>(tmp, lcnt[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(lcnt.<span class="built_in">begin</span>(), lcnt.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-最后一块石头的重量-II"><a href="#4-最后一块石头的重量-II" class="headerlink" title="4. 最后一块石头的重量 II"></a>4. 最后一块石头的重量 II</h2><p><strong>题目：</strong></p>
<p>最后一块石头的重量 II(Last Stone Weight II)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight-ii/">https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight-ii/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>和第一题的题意只有一句差别，就是每次拿石头是「任意」的。问最后能消掉剩余的最小值是多少。</p>
<p>一般最开始可能想到用贪心，但实际上没有这种算法的。</p>
<p>由于石头碎掉之后还能放回去，类似于把石头分成两堆来看。只要依次拿两堆的石头互相粉碎，最后剩下的就是最小整数。</p>
<p>最多有100个石头，每个石头最多300的重量。所以两个集合最大的差值不会超过30000。</p>
<p>用数组构造结果。</p>
<p>在加入第n个石头重量为m时，查找n-1个石头能够组成的两堆石头的差值的绝对值为diff。</p>
<p>该石头两个选择，放入多的堆，则差值更大，为diff+m；<br>放入小的堆，则差值为|diff-m|。这时更新n个石头能组成的所有重量。</p>
<p>最后输出最后一个石头能组成的最小重量即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diff[<span class="number">101</span>][<span class="number">30001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        diff[<span class="number">0</span>][stones[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum;++j)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>(diff[i<span class="number">-1</span>][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    diff[i][j+stones[i]] = <span class="number">1</span>;</span><br><span class="line">                    diff[i][<span class="built_in">abs</span>(j-stones[i])] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diff[n<span class="number">-1</span>][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC137%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knx006yb0oodp15ef8x" data-title="Leetcode 第137场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第138场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC138%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC138%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第138场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天的比赛的题目难度没有区分开，考察的不是很全面。题目描述也有些晦涩，考察的点却很简单。</p>
<p>例如第1题题目描述的让人看不清，看懂后发现就是考察个排序，真不知道这种题目出来有什么用途。面试中肯定不会出这种题。</p>
<p>第3题的用例也是错的，为了过掉题目，还要按照「错误的解」来修改程序。</p>
<p>做题的时候还有个插曲，外面下雨了，出去收了会衣服。回来还有时间把所有题目都AC掉。建议后面的比赛要难易结合，考点尽量宽泛些。</p>
<p>不过站在leetcode的角度来说，众口难调，组织这么多次比赛，偶尔出现几次问题也正常，希望后面的比赛越办越好。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 138</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-138">https://leetcode-cn.com/contest/weekly-contest-138</a></p>
<h2 id="1-高度检查器"><a href="#1-高度检查器" class="headerlink" title="1. 高度检查器"></a>1. 高度检查器</h2><p><strong>题目：</strong></p>
<p>高度检查器(Height Checker)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-138/problems/height-checker/">https://leetcode-cn.com/contest/weekly-contest-138/problems/height-checker/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p>
<p>请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。<br>输入：[1,1,4,2,1,3]<br>输出：3<br>解释：<br>高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。</p>
</blockquote>
<p><strong>思路：</strong><br>本质就是求一个数组，排序后，要有多少个位置的数字不在从前的位置上。</p>
<p>排序后比较即可，代码很简单。</p>
<p>这题在做的时候以为是最少移动次数呢，例如输入[5,1,2,3,4]，可以把5直接放到最后。如果是这样的话题目难度就增加了，有兴趣可以再想想。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(heights)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i]!=heights[i])</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-爱生气的书店老板"><a href="#2-爱生气的书店老板" class="headerlink" title="2. 爱生气的书店老板"></a>2. 爱生气的书店老板</h2><p><strong>题目：</strong></p>
<p>爱生气的书店老板(Grumpy Bookstore Owner)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-138/problems/grumpy-bookstore-owner/">https://leetcode-cn.com/contest/weekly-contest-138/problems/grumpy-bookstore-owner/</a></p>
<p><strong>题意：</strong></p>
<p>给出两个长度都为n的数组customers和grumpy，grumpy每个元素只能是0或1，最后求和sum为</p>
<p>sum&#x3D;customers[i]*（1-grumpy[i] ） (0 &lt;&#x3D; i &lt; n)</p>
<p>然后给定一个数X（1&lt;&#x3D;X&lt;&#x3D;n）,可以把grumpy数组中连续X长度的元素的值从1变为0。问在确定X值后sum的最大值是多少？</p>
<p><strong>思路：</strong></p>
<p>上面的题意是我翻译的，实际上原题用的老板和顾客，还有生气值。有点和生活脱节，不是很好理解。</p>
<p>如果理解了题意，题目的做法就大概知道了。</p>
<p>先计算出来没有X时的原始sum值。然后使用一个长度X的区间，在customers数组从前到后扫描n-X次。更新每个扫描区间增加的值，增加的最大值和sum的原始值相加，就是结果。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; customers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            sum += customers[i]*(<span class="number">1</span>-grumpy[i]);</span><br><span class="line">        <span class="type">int</span> delt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; X; ++i)</span><br><span class="line">            delt += customers[i]*grumpy[i];</span><br><span class="line">        <span class="type">int</span> dt = delt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = X; i &lt; customers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dt += customers[i]*grumpy[i] - customers[i-X]*grumpy[i-X];</span><br><span class="line">            delt = <span class="built_in">max</span>(dt, delt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + delt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-交换一次的先前排列"><a href="#3-交换一次的先前排列" class="headerlink" title="3. 交换一次的先前排列"></a>3. 交换一次的先前排列</h2><p><strong>题目：</strong></p>
<p>交换一次的先前排列(Previous Permutation With One Swap)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-138/problems/previous-permutation-with-one-swap/">https://leetcode-cn.com/contest/weekly-contest-138/problems/previous-permutation-with-one-swap/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给你一个正整数的数组 <code>A</code>（其中的元素不一定完全不同），请你返回可在 <strong>一次交换</strong>（交换两数字 <code>A[i]</code> 和 <code>A[j]</code> 的位置）后得到的、按字典序排列小于 <code>A</code> 的最大可能排列。</p>
<p>如果无法这么操作，就请返回原数组。</p>
<p><strong>示例 4：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路：</strong></p>
<p>题目简单直白，题意也比较好理解。直交换两个数值，得到小于当前字典序的集合中，最大的那个字典序排列。</p>
<p>简直是把题目又复述了一遍。</p>
<p>处理方式为：</p>
<p>第一步：从当前序列的后往前找，找到第一个降序的位置（A[i]&gt;A[i+1]），则必存在能构造比当前小的序列。</p>
<p>第二步：把A[i]后面的数字中，小于A[i]且最接近A[i]的值的数字找出来，和A[i]交换。</p>
<p>为什么第一步不再往前找，因为往前找更换，会让小的值出现在高位，导致不是最大字典序。</p>
<p>为什么第二步要找最接近的且小的，因为大的更换就超过当前序列，只能找小的。从小的里面找个最大值更换才能字典序最大，且不会超过当前序。</p>
<p>题目中的示例4是有问题的，答案应该是比[3,1,1,3]小的最大字典序是[1,3,1,3]，而不是[1,1,3,3]。</p>
<p>但是为了把题目过了，只能把18行改为<code>if(A[i]&gt;=A[t] &amp;&amp; A[i]&lt;A[f])</code>，多加个等号。</p>
<p>因为可能是官方生成用例的时候也多加个等号，做题还要考虑官方的思路。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">+1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                f = i;</span><br><span class="line">                t = f<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = f<span class="number">+2</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=A[t] &amp;&amp; A[i]&lt;A[f])<span class="comment">//如果题目修改了，把&gt;=换成&gt;即可</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(A[f],A[t]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-距离相等的条形码"><a href="#4-距离相等的条形码" class="headerlink" title="4. 距离相等的条形码"></a>4. 距离相等的条形码</h2><p><strong>题目：</strong></p>
<p>距离相等的条形码(Distant Barcodes)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-138/problems/distant-barcodes/">https://leetcode-cn.com/contest/weekly-contest-138/problems/distant-barcodes/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p>
<p>请你重新排列这些条形码，使其中两个相邻的条形码 <strong>不能</strong> 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>数组的已有元素重新排列，保证相邻元素不相同。由于题目保证存在答案，直接用贪心的方法就可以实现。</p>
<p>先统计出每个元素的个数，按照个数排序分配。按元素个数多少，从头到尾间隔放到数组的偶数下标位置中。然后第二轮把剩余元素放到奇数下标，构造出最后答案。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = barcodes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m : barcodes)</span><br><span class="line">            cnt[m]++;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&gt;<span class="number">0</span>)</span><br><span class="line">                v.<span class="built_in">push_back</span>(&#123;cnt[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( i=k ; i &lt; n; i+=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[j].first == <span class="number">0</span>)</span><br><span class="line">                    --j;</span><br><span class="line">                ans[i] = v[j].second;</span><br><span class="line">                --v[j].first;</span><br><span class="line">            &#125;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC138%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knx0070b0oohi39e714" data-title="Leetcode 第138场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第139场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC139%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC139%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第139场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天的比赛考固定算法的不多，只有最后一道动态规划的题目稍难一点。其他的题目花些心思，也可以想出来。在面试中如果考察一个人的脑力，前三道题目比较好。都能答出来一些，但是也有优化的空间。</p>
<p>第三题用了很多时间，导致第四题时间都不够了。做比赛和工程还是有差别，应该有思路就敲代码，先把题目过了再说，一些细节不用考虑太多。有些地方不优化也可以过掉。但是在工程上就要考究些，因为代码是在服务器24小时跑，能优化一点点，在海量服务中也能节省很多计算资源。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 139</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-139">https://leetcode-cn.com/contest/weekly-contest-139</a></p>
<h2 id="1-字符串的最大公因子"><a href="#1-字符串的最大公因子" class="headerlink" title="1. 字符串的最大公因子"></a>1. 字符串的最大公因子</h2><p><strong>题目：</strong></p>
<p>字符串的最大公因子(Greatest Common Divisor of Strings)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-139/problems/greatest-common-divisor-of-strings/">https://leetcode-cn.com/contest/weekly-contest-139/problems/greatest-common-divisor-of-strings/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>对于字符串 S 和 T，只有在 S &#x3D; T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p>
<p>返回字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>返回的公共字符串X就是经过n1次重复为Str1，经过n2次重复为Str2的最长字符串。</p>
<p>那么X一定是S和T的公共前缀字符串的子串。</p>
<p>先计算出S和T的公共前缀字符串str，然后从str的最长前缀到最短前缀依次判断，是否满足能「除尽」str1和str2。</p>
<p>要求的X的字符串长度，一定是str1和str2长度的公约数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStr</span><span class="params">(string &amp; str1, string &amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = str<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len1%len2!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> repeat = len1/len2;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span>(repeat--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp == str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> len1 = str<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1 &amp;&amp; i &lt; len2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                str.<span class="built_in">push_back</span>(str1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> b1 = <span class="built_in">isSubStr</span>(str1, str);</span><br><span class="line">            <span class="type">bool</span> b2 = <span class="built_in">isSubStr</span>(str2, str);</span><br><span class="line">            <span class="keyword">if</span>(b1 &amp;&amp; b2)</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-按列翻转得到最大值等行数"><a href="#2-按列翻转得到最大值等行数" class="headerlink" title="2. 按列翻转得到最大值等行数"></a>2. 按列翻转得到最大值等行数</h2><p><strong>题目：</strong></p>
<p>按列翻转得到最大值等行数(Flip Columns For Maximum Number of Equal Rows)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-139/problems/flip-columns-for-maximum-number-of-equal-rows/">https://leetcode-cn.com/contest/weekly-contest-139/problems/flip-columns-for-maximum-number-of-equal-rows/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给定由若干 0 和 1 组成的矩阵 matrix，从中选出任意数量的列并翻转其上的 每个 单元格。翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。</p>
<p>返回经过一些翻转后，行上所有值都相等的最大行数。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>两行数字，经过对一些列的反转，最后都达到这一行的值相同。那么这两行数字的关系有两种情况：</p>
<ol>
<li>两行数字的值都相同；</li>
<li>两行数字的值都相反；</li>
</ol>
<p>其他任何情况，一定有一列始终都不满足相等。</p>
<p>所以题目的结果为看满足两种情况的行的集合最多有多少？</p>
<p>只要两两枚举就能算出来，曾经加入过其他集合的可以后面就不比较了。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> k;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(a[i][k]+a[j][k]!=<span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k==n)</span><br><span class="line">                        tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-负二进制数相加"><a href="#3-负二进制数相加" class="headerlink" title="3. 负二进制数相加"></a>3. 负二进制数相加</h2><p><strong>题目：</strong></p>
<p>负二进制数相加(Adding Two Negabinary Numbers)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-139/problems/adding-two-negabinary-numbers/">https://leetcode-cn.com/contest/weekly-contest-139/problems/adding-two-negabinary-numbers/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。</p>
<p>数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr &#x3D; [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 &#x3D; -3。数组形式 的数字也同样不含前导零：以 arr 为例，这意味着要么 arr &#x3D;&#x3D; [0]，要么 arr[0] &#x3D;&#x3D; 1。</p>
<p>返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>-2进制的算法和2进制算法是一样的。都是先模-2得到当前位的值，然后再除-2得到高位的进位值。</p>
<p>但是由于题目中要求每位必须是0或者是1，所以在模-2等于-1时，要进行特殊处理。</p>
<p>如果取模的结果是-1表示当前位的值为-1，要变成正数才能正常表示。要把当前位变为1，要把除数加1。</p>
<p>如果想不明白，请思考下公式 <code>(x*-2)+(-1) = (x-1)*-2 + 1</code>。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addNegabinary</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = arr<span class="number">1.</span><span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = arr<span class="number">2.</span><span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> divid = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>||j &gt;= <span class="number">0</span>||carry)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">                carry += arr1[i];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">                carry += arr2[j];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mod = carry % divid;</span><br><span class="line">            carry /= divid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(mod &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mod -= divid;</span><br><span class="line">                carry += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(mod);</span><br><span class="line">            </span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">back</span>()==<span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-元素和为目标值的子矩阵数量"><a href="#4-元素和为目标值的子矩阵数量" class="headerlink" title="4. 元素和为目标值的子矩阵数量"></a>4. 元素和为目标值的子矩阵数量</h2><p><strong>题目：</strong></p>
<p>元素和为目标值的子矩阵数量(Number of Submatrices That Sum to Target)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-139/problems/number-of-submatrices-that-sum-to-target/">https://leetcode-cn.com/contest/weekly-contest-139/problems/number-of-submatrices-that-sum-to-target/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 x1, y1, x2, y2 是满足 x1 &lt;&#x3D; x &lt;&#x3D; x2 且 y1 &lt;&#x3D; y &lt;&#x3D; y2 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 (x1, y1, x2, y2) 和 (x1’, y1’, x2’, y2’) 两个子矩阵中部分坐标不同（如：x1 !&#x3D; x1’），那么这两个子矩阵也不同。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>先对每行数据进行处理，求出每行开始到当前位置的和。<code>sum[i][j] = matrix[i][0]+matrix[i][0]+...+matrix[i][j]</code>。</p>
<p>这样一行中j，k两个之间的区间和可以表示为<code>sum[i][j]-sum[i][k-1]</code>，很快能求出。</p>
<p>之后枚举两列c1,c2，对于每一次枚举，行数从上到下扫描。</p>
<p>每扫描到一行r1，先计算出当前行与两列，还有第0行形成的矩阵的和S。</p>
<p>然后查找是否有之前的行r0的和为S-target。</p>
<p>如果有，则r0，r1，c1，c2形成的和为target。</p>
<p>最后再把S存起来，留给后面的行扫描时查找。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i][j] += matrix[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; n; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                mp.<span class="built_in">clear</span>();</span><br><span class="line">                mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                        sum += matrix[i][k] - matrix[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sum += matrix[i][k];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(mp.<span class="built_in">find</span>(sum-target)!=mp.<span class="built_in">end</span>())</span><br><span class="line">                        ans += mp[sum-target];</span><br><span class="line">                    </span><br><span class="line">                    mp[sum]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC139%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70kny0072b0ooe4de7ey0" data-title="Leetcode 第139场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第140场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC140%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC140%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第140场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天的题目难度适中。第二道题计算排列数，实际上是有优化方法的，但是题目的测试数据比较宽松，暴力就可以过掉。</p>
<p>今天比赛的主题可以归纳为「暴力」，都用最直白，最直接的方法，都可以过掉题目。</p>
<p>在实际编程工作中，大多数是把一个模型实现为程序，用所谓「直白」的方法。</p>
<p>有一种方法论，叫做先实现，再优化。先想办法实现，保证正确性，然后再逐渐优化，让性能越来越好。性能优化到什么样才停止呢？满足当前要求就可以停止。因为性能优化也是要付出代价和成本的，「够用」最好。当然要有技术储备，当需要进一步优化的时候能够立刻去做。</p>
<p>做比赛也是一样，能够在有限的时间内，在题目的要求下，过掉题目是最好的。至于最优算法，可以比赛结束后慢慢研究。</p>
<p>上面的方法论第一步有时也叫做原型。做原型类似于做个demo，用现有工具快速实现。在语言侧python有很大优势，库很全。既有类似shell的语法简洁功能强大，又有类似C的语法约束，不至于看不懂。缺点当然是性能了。但是能够让人专注于实现逻辑，本身已经很强大了。</p>
<p>例如许多字符串操作，像把文本按空格分成单词，在python中只要一句话，这些在C++中就只能干捉急了，没个三五行，再加上些检查和约束，根本写不出来。</p>
<p>语言都是工具，没有高低贵贱之分，要看应用场景。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 140</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-140">https://leetcode-cn.com/contest/weekly-contest-140</a></p>
<h2 id="1-Bigram-分词"><a href="#1-Bigram-分词" class="headerlink" title="1. Bigram 分词"></a>1. Bigram 分词</h2><p><strong>题目：</strong></p>
<p>Bigram 分词(Occurrences After Bigram)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-140/problems/occurrences-after-bigram/">https://leetcode-cn.com/contest/weekly-contest-140/problems/occurrences-after-bigram/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出第一个词 <code>first</code> 和第二个词 <code>second</code>，考虑在某些文本 <code>text</code> 中可能以 “<code>first second third</code>“ 形式出现的情况，其中 <code>second</code> 紧随 <code>first</code> 出现，<code>third</code> 紧随 <code>second</code> 出现。</p>
<p>对于每种这样的情况，将第三个词 “<code>third</code>“ 添加到答案中，并返回答案。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>题目比较直白，就是给出两个单词，和一段文本，让返回所有的出现在这两个单词组成的短语后挨着的第三个单词。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">输出：[&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure>

<p>把两个单词先拼成一个短语，然后在文本中查找该短语。找到后，输出短语后的下一个单词。然后从上次查找到的短语的尾部继续上面的操作，直至找到文本结尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findOcurrences</span><span class="params">(string text, string first, string second)</span> </span>&#123;</span><br><span class="line">        string str = first + <span class="string">&quot; &quot;</span> + second + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string::size_type start = <span class="number">0</span>;</span><br><span class="line">        string::size_type pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((pos = text.<span class="built_in">find</span>(str, start))!=text.npos)</span><br><span class="line">        &#123;</span><br><span class="line">            string::size_type spacepos = text.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, pos + str.<span class="built_in">length</span>());</span><br><span class="line">            string tmp = text.<span class="built_in">substr</span>(pos + str.<span class="built_in">length</span>(), spacepos - (pos + str.<span class="built_in">length</span>()));</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            start = pos + str.<span class="built_in">length</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-活字印刷"><a href="#2-活字印刷" class="headerlink" title="2. 活字印刷"></a>2. 活字印刷</h2><p><strong>题目：</strong></p>
<p>活字印刷(Letter Tile Possibilities)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-140/problems/letter-tile-possibilities/">https://leetcode-cn.com/contest/weekly-contest-140/problems/letter-tile-possibilities/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>你有一套活字字模 <code>tiles</code>，其中每个字模上都刻有一个字母 <code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;AAB&quot;</span><br><span class="line">输出：8</span><br><span class="line">解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路：</strong></p>
<p>给定一个字母集合，然后求用这些字母，可以组成的字母排列的个数。</p>
<p>这是一道数学题，如果用手算，最好的方法是计算出全排列的数量，然后再除以每个重复的排列个数。例如”AAABBC”组成的6个字母的排列数为A（6，6）&#x2F;[A(3,3)*A(2,2)]。</p>
<p>但是做这个题目用这个方法有点难写，最简单的方法，就是枚举所有的排列，然后汇总结果。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt; width)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = mp.<span class="built_in">begin</span>(); iter!=mp.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> key = iter-&gt;first;</span><br><span class="line">            <span class="type">int</span> value = iter-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            iter-&gt;second--;</span><br><span class="line">            sum += <span class="built_in">dfs</span>(width, pos<span class="number">+1</span>);</span><br><span class="line">            iter-&gt;second++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTilePossibilities</span><span class="params">(string tiles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : tiles)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tiles.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">            res += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-根到叶路径上的不足节点"><a href="#3-根到叶路径上的不足节点" class="headerlink" title="3. 根到叶路径上的不足节点"></a>3. 根到叶路径上的不足节点</h2><p><strong>题目：</strong></p>
<p>根到叶路径上的不足节点(Insufficient Nodes in Root to Leaf Paths)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-140/problems/insufficient-nodes-in-root-to-leaf-paths/">https://leetcode-cn.com/contest/weekly-contest-140/problems/insufficient-nodes-in-root-to-leaf-paths/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给定二叉树的根 <code>root</code>，考虑所有<strong>从根到叶的路径</strong>：从根到任何叶的路径。 （叶节点是没有子节点的节点。）</p>
<p>如果交于节点 <code>node</code> 的<strong>每个</strong>根到叶路径的总和严格小于限制 <code>limit</code>，则该节点为不足节点。</p>
<p>同时删除所有不足节点，并返回生成的二叉树的根。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>题目的意思是，从根节点到每个叶子节点所经过的路径的节点和，如果大于等于limit，则这条路径上所有的节点都留下来。最终没留下来的节点删掉。</p>
<p>如果这样理解题意，做起来会简单些。</p>
<p>方法一：</p>
<p>最简单的方法，进行深度优先搜索，例如先序遍历。到达叶节点，统计从根到叶子所经过的路径和。如果大于limit则把路径经过的节点都染色「保留」，否则染色「删除」。</p>
<p>最后保存所有「保留」的节点，就是答案。</p>
<p>方法一最好想，也容易实现，但是要辅助存储和经过两次遍历。对于这道题是可以过掉的。</p>
<p>在方法一的基础上可以优化下，达到一次遍历就能够得到最终结果。</p>
<p>对于一个节点，最终是否要删掉，满足的条件是：所有经过该节点的路径和都是小于limit的。</p>
<p>虽然有多个子节点，有多条路径，但是我们只要考虑和最大的哪条路径是否小于limit就可以了。因为只要有一条路径大于等于limit的值，就可以保留该节点。</p>
<p>方法二：</p>
<p>采用后序遍历，父节点到该节点的路径和，获取左右两个儿子节点路径和的最大值。求出经过该节点的路径和的最大值，如果最大值小于limit，则让父节点删掉当前节点，否则让父节点保留当前节点。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;TreeNode* , <span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> limit, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        pair&lt;TreeNode* , <span class="type">int</span>&gt; l, r;</span><br><span class="line">        l = <span class="built_in">dfs</span>(root-&gt;left, limit, sum+root-&gt;val);</span><br><span class="line">        r = <span class="built_in">dfs</span>(root-&gt;right,limit, sum+root-&gt;val);</span><br><span class="line">        root-&gt;left = l.first;</span><br><span class="line">        root-&gt;right = r.first;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> maxsum = <span class="built_in">max</span>(l.second, r.second);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxsum + sum + root-&gt;val &lt; limit)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, maxsum + root-&gt;val&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;root, maxsum + root-&gt;val&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        pair&lt;TreeNode* , <span class="type">int</span>&gt; ans;</span><br><span class="line">        ans = <span class="built_in">dfs</span>(root, limit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-不同字符的最小子序列"><a href="#4-不同字符的最小子序列" class="headerlink" title="4. 不同字符的最小子序列"></a>4. 不同字符的最小子序列</h2><p><strong>题目：</strong></p>
<p>不同字符的最小子序列(Smallest Subsequence of Distinct Characters)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-140/problems/smallest-subsequence-of-distinct-characters/">https://leetcode-cn.com/contest/weekly-contest-140/problems/smallest-subsequence-of-distinct-characters/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>返回字符串 <code>text</code> 中按字典序排列最小的子序列，该子序列包含 <code>text</code> 中所有不同字符一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;cdadabcc&quot;</span><br><span class="line">输出：&quot;adbc&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路：</strong></p>
<p>用贪心的方法。</p>
<p>对于每个text中的字符，如果该字符已经出现在最终的结果中，则不必再处理。</p>
<p>对于还没出现在最终结果中的字符<code>text[i]</code>。如果该字符只剩下一个，那么该字符要马上加入到结果中。如果该字符还有多个，那么查看在该字符右侧出现的字符中，是否有小于该字符的字符<code>text [ j ] (j &gt; i)</code> 出现。如果选择text[j]作为本轮输出的字符，还要满足在i到j-1中所有未出现在结果的字符的数量，都要是大于1的。否则不能满足相对顺序和text中的一致。因为如果小于等于1，在j的右侧，就不会再有该字符出现了，那么最终结果也不会包含该字符了。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(string text, <span class="type">int</span> startpos, <span class="type">int</span> n, string cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch=<span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = startpos; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[text[i]] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(text[i]&lt;ch)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = text[i];</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[text[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(mp[text[i]]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = pos + <span class="number">1</span>; j &lt;=i; ++j)</span><br><span class="line">                    <span class="keyword">if</span>(mp[text[j]]!=<span class="number">-1</span>)</span><br><span class="line">                        mp[text[j]]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        mp[ch] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(text, pos<span class="number">+1</span>, n, cur+ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : text)</span><br><span class="line">            mp[ch]++;</span><br><span class="line">        string res;</span><br><span class="line">        res = <span class="built_in">dfs</span>(text, <span class="number">0</span>, text.<span class="built_in">size</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC140%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70kny0074b0oodvgvhs3e" data-title="Leetcode 第140场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第157场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC157%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC157%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第157场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好久没有写解题报告了，今天做了一下比赛，这场比赛的题目比较简单。一二题代码很短，题意明白会很快写完，第三题看着很难，但是测试数据简单，直接暴力就可以过。</p>
<p>第四题也是一道简单的动态规划题，只是模拟规则比较复杂。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 157</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-157">https://leetcode-cn.com/contest/weekly-contest-157</a></p>
<h2 id="1-玩筹码"><a href="#1-玩筹码" class="headerlink" title="1. 玩筹码"></a>1. 玩筹码</h2><p><strong>题目：</strong></p>
<p>玩筹码(Play with Chips)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-157/problems/play-with-chips/">https://leetcode-cn.com/contest/weekly-contest-157/problems/play-with-chips/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。</p>
<p>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：</p>
<p>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。<br>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。<br>最开始的时候，同一位置上也可能放着两个或者更多的筹码。</p>
<p>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。<br>示例 1：</p>
<p>输入：chips &#x3D; [1,2,3]<br>输出：1<br>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>所有奇数位的筹码，经过多次移动两格都能移动到坐标1位置，所有偶数位筹码都能移动到坐标0位置。<br>最后合成一堆的时候，最小代价就是坐标0或1筹码的总数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostToMoveChips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; chips)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : chips)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                a++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-最长定差子序列"><a href="#2-最长定差子序列" class="headerlink" title="2. 最长定差子序列"></a>2. 最长定差子序列</h2><p><strong>题目：</strong></p>
<p>最长定差子序列(Longest Arithmetic Subsequence of Given Difference)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-157/problems/longest-arithmetic-subsequence-of-given-difference/">https://leetcode-cn.com/contest/weekly-contest-157/problems/longest-arithmetic-subsequence-of-given-difference/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。</p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [1,2,3,4], difference &#x3D; 1<br>输出：4<br>解释：最长的等差子序列是 [1,2,3,4]。</p>
</blockquote>
<p><strong>思路：</strong><br>只需要三个元素：等差差值，数列长度，等差数列最后一个数的大小，就可以表示一个等差数列。</p>
<p>对于整数数组arr遍历，对于每个arr[i]，设arr[i]-diff表示的等差数列长度为m，则arr[i]表示的等差数列大小为m+1。<br><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> diff)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[n]=mp[n-diff]<span class="number">+1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mp[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-黄金矿工"><a href="#3-黄金矿工" class="headerlink" title="3. 黄金矿工"></a>3. 黄金矿工</h2><p><strong>题目：</strong></p>
<p>黄金矿工(Path with Maximum Gold)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-157/problems/path-with-maximum-gold/">https://leetcode-cn.com/contest/weekly-contest-157/problems/path-with-maximum-gold/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>在一个m*n的地图中，每个格子都用个整数表示，为0的格子不能走，只能走正整数的格子，只能上下左右相邻格子移动，移动过的格子不能再回头经过。<br>要求移动路径和最大的值是多少。</p>
<p>1 &lt;&#x3D; grid.length, grid[i].length &lt;&#x3D; 15<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100<br>最多 25 个单元格是正整数。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>由于题目的测试数据很简单，直接暴力深搜就能过。还可以做下记忆化搜索，搜过的位置和状态下次直接返回。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dirx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> diry[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; pos2num;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calHash</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        hash = pos2num[&#123;r, c&#125;];</span><br><span class="line">        hash &lt;&lt;= N;</span><br><span class="line">        hash |= status;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash = <span class="built_in">calHash</span>(r, c, status);</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(hash)!=memo.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> memo[hash];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> value = grid[r][c];</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = dirx[i]+r;</span><br><span class="line">            <span class="type">int</span> y = diry[i]+c;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;grid.<span class="built_in">size</span>()&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;grid[x].<span class="built_in">size</span>()&amp;&amp;grid[x][y]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[r][c] = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="built_in">dfs</span>(x, y, grid, status | (<span class="number">1</span>&lt;&lt;pos2num[&#123;x, y&#125;]));</span><br><span class="line">                ret = <span class="built_in">max</span>(tmp, ret);</span><br><span class="line">                grid[r][c] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[hash] = ret + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaximumGold</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &amp;&amp; pos2num.<span class="built_in">find</span>(&#123;i, j&#125;) == pos2num.<span class="built_in">end</span>())</span><br><span class="line">                    pos2num[&#123;i, j&#125;] = N++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> status = <span class="number">1</span> &lt;&lt; pos2num[&#123;i, j&#125;];</span><br><span class="line">                    <span class="type">int</span> get = <span class="built_in">dfs</span>(i, j, grid, status);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, get);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-统计元音字母序列的数目"><a href="#4-统计元音字母序列的数目" class="headerlink" title="4. 统计元音字母序列的数目"></a>4. 统计元音字母序列的数目</h2><p><strong>题目：</strong></p>
<p>统计元音字母序列的数目(Count Vowels Permutation)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-157/problems/count-vowels-permutation/">https://leetcode-cn.com/contest/weekly-contest-157/problems/count-vowels-permutation/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：</p>
<p>字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）<br>每个元音 ‘a’ 后面都只能跟着 ‘e’<br>每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’<br>每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’<br>每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’<br>每个元音 ‘u’ 后面只能跟着 ‘a’<br>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>典型的动态规划，长度为n的字符串的个数可以从n-1长度字符串的个数中计算出来。</p>
<p>例如：长度为n-1的以a结尾的字符串，可以转换成长度为n的以’e’结尾的字符串。</p>
<p>通过搜索枚举出所有符合要求的字符串，每个加一，最后记忆搜索即可。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">char</span>, vector&lt;<span class="type">char</span>&gt;&gt; relation;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; letter = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    map&lt;pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt;, <span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(&#123;i, ch&#125;)!=memo.<span class="built_in">end</span>())</span><br><span class="line">           <span class="keyword">return</span> memo[&#123;i, ch&#125;];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : relation[ch])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(i<span class="number">+1</span>, n, c);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[&#123;i, ch&#125;] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        relation[<span class="string">&#x27;a&#x27;</span>] = &#123;<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;e&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;i&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;o&#x27;</span>] = &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">        relation[<span class="string">&#x27;u&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : letter)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(<span class="number">1</span>, n, ch);</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC157%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knz0076b0oo3mg7cv7x" data-title="Leetcode 第157场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第158场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC158%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC158%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第158场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这场比赛不需要太多特定的算法，只要能把问题分析清楚，认真思考，就能够解决掉。几个题目都非常适合当面试题。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>比赛的地址 Weekly Contest 158</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-158">https://leetcode-cn.com/contest/weekly-contest-158</a></p>
<h2 id="1-分割平衡字符串"><a href="#1-分割平衡字符串" class="headerlink" title="1. 分割平衡字符串"></a>1. 分割平衡字符串</h2><p><strong>题目：</strong></p>
<p>分割平衡字符串(Split a String in Balanced Strings)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-158/problems/split-a-string-in-balanced-strings/">https://leetcode-cn.com/contest/weekly-contest-158/problems/split-a-string-in-balanced-strings/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>只要保证R和L的数目相同，就是一个平衡字符串。所以从头遍历，符合平衡就计数，最终遍历完就贪心出答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">balancedStringSplit</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-可以攻击国王的皇后"><a href="#2-可以攻击国王的皇后" class="headerlink" title="2. 可以攻击国王的皇后"></a>2. 可以攻击国王的皇后</h2><p><strong>题目：</strong></p>
<p>可以攻击国王的皇后(Queens That Can Attack the King)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-158/problems/queens-that-can-attack-the-king/">https://leetcode-cn.com/contest/weekly-contest-158/problems/queens-that-can-attack-the-king/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>
<p>「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。</p>
<p>「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。</p>
<p>请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。</p>
</blockquote>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-2.jpg" alt="可以攻击国王的皇后的例子"></p>
<p><strong>思路：</strong></p>
<p>上图红色的就是符合答案的「黑皇后」。</p>
<p>题目可以利用逆向思维，「白国王」所在的位置，遍历横竖斜八个方向，第一次碰到的「黑皇后」就是答案。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">queensAttacktheKing</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queens, vector&lt;<span class="type">int</span>&gt;&amp; king) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> q : queens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = q[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = q[<span class="number">1</span>];</span><br><span class="line">            v[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = king[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y = king[<span class="number">1</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = x;</span><br><span class="line">            <span class="type">int</span> c = y;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r+=dir[i][<span class="number">0</span>];</span><br><span class="line">                c+=dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r&lt;<span class="number">8</span>&amp;&amp;r&gt;=<span class="number">0</span>&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;<span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(v[r][c]==<span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(&#123;r, c&#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-掷骰子模拟"><a href="#3-掷骰子模拟" class="headerlink" title="3. 掷骰子模拟"></a>3. 掷骰子模拟</h2><p><strong>题目：</strong></p>
<p>掷骰子模拟(Dice Roll Simulation)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-158/problems/dice-roll-simulation/">https://leetcode-cn.com/contest/weekly-contest-158/problems/dice-roll-simulation/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p>
<p>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。</p>
<p>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。</p>
<p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。</p>
<p>输入：n &#x3D; 2, rollMax &#x3D; [1,1,2,2,2,3]</p>
<p>输出：34</p>
<p>解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 &#x3D; 36 种可能的组合。</p>
<p>但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。</p>
<p>因此，最终答案是 36-2 &#x3D; 34。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>可以换种方式理解，要形成一个n长度的数字字符串，包括1-6这几个数字。每种数字要求连续不能超过rollMax的数量。</p>
<p>可以利用递归构造出符合要求的数字，构造出一次就加一。从第一位开始构造，一直构造到第n位后结束。</p>
<p>构造当前位时，需要知道前一位数字是什么，以及这个数字累积连续了几次。</p>
<p>所以递归函数需要三个参数，当前要构造的位序号，上一位数字，上一位数字连续出现的次数。</p>
<p>最后用记忆化搜索优化。</p>
<p>ps：一种通用的解法叫数位dp，本题比较简单，还可以构造更复杂的题目。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">5001</span>][<span class="number">7</span>][<span class="number">16</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> pre, <span class="type">int</span> state, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; rollMax)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == n<span class="number">+1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[index][pre][state]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[index][pre][state];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==pre<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rollMax[i]==state)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans += <span class="built_in">dfs</span>(index<span class="number">+1</span>, i<span class="number">+1</span>, state<span class="number">+1</span>, n, rollMax), ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += <span class="built_in">dfs</span>(index<span class="number">+1</span>, i<span class="number">+1</span>, <span class="number">1</span>, n, rollMax) % MOD, ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[index][pre][state]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dieSimulator</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; rollMax)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="built_in">sizeof</span>(memo));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, n, rollMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-最大相等频率"><a href="#4-最大相等频率" class="headerlink" title="4. 最大相等频率"></a>4. 最大相等频率</h2><p><strong>题目：</strong></p>
<p>最大相等频率(Maximum Equal Frequency)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-158/problems/maximum-equal-frequency/">https://leetcode-cn.com/contest/weekly-contest-158/problems/maximum-equal-frequency/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>给出一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回其长度：</p>
<p>从前缀中 删除一个 元素后，使得所剩下的每个数字的出现次数相同。</p>
<p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p>
<p>输入：nums &#x3D; [2,2,1,1,5,3,3,5]</p>
<p>输出：7</p>
<p>解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4]&#x3D;5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>不使用高级的数据结构，只要做好统计，分析出能够产生的条件，就可以解决。</p>
<p>用两个数组统计每个数字的出现次数<code>number_size</code>，和每种出现次数相同的有多少种数字<code>size_count</code>。</p>
<p>例如：[2,2,1,1,5,3,3,5]</p>
<p>如果全部统计，那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">number_size[1]=2, </span><br><span class="line">number_size[2]=2,</span><br><span class="line">number_size[3]=2,</span><br><span class="line">number_size[5]=2,</span><br><span class="line">每种数字都出现了2次</span><br><span class="line"></span><br><span class="line">size_count[2]=4</span><br><span class="line">出现2次的数字，有4种</span><br></pre></td></tr></table></figure>
<p>利用上面两个数组的统计，满足以下四种情况，就是符合条件的答案：</p>
<ol>
<li>前缀中只包含一种数字（number_size.size()&#x3D;&#x3D;1）;</li>
<li>前缀中包含多种数字，每种数字都只包含一个（只有size_count[1]有元素，其他下标都没有），删掉任何一个数字，剩下数字出现次数都为1;</li>
<li>前缀中，数字出现的次数只有两种，除了一个元素出现次数是1次，其他元素的出现次数都相同。删掉出现1次的那个元素；</li>
<li>前缀中，出现次数只有两种a和b，满足a&#x3D;b+1，并且a次数只有一种数字，剩下的数字都出现b次。删掉出现a次数字一个，所有数字出现b次。</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEqualFreq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; number_size; <span class="comment">//每个数字有多少次出现</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; size_count;  <span class="comment">//出现次数的计数</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">if</span>(number_size.<span class="built_in">find</span>(num)==number_size.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                number_size[num] = <span class="number">1</span>;</span><br><span class="line">                size_count[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> old_size = number_size[num];</span><br><span class="line">                number_size[num]++;</span><br><span class="line">                size_count[old_size]--;</span><br><span class="line">                size_count[old_size<span class="number">+1</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(size_count[old_size]==<span class="number">0</span>)</span><br><span class="line">                    size_count.<span class="built_in">erase</span>(old_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number_size.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">                    ans = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(size_count.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> iter = size_count.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;first == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(size_count.<span class="built_in">size</span>()==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> iter = size_count.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">auto</span> riter = size_count.<span class="built_in">rbegin</span>();</span><br><span class="line">                <span class="keyword">if</span>((riter-&gt;first-iter-&gt;first)==<span class="number">1</span> &amp;&amp; (<span class="number">1</span> == riter-&gt;second))</span><br><span class="line">                    ans = i;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;first==<span class="number">1</span>&amp;&amp;iter-&gt;second==<span class="number">1</span>)</span><br><span class="line">                    ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC158%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70ko00078b0oof8xr33wm" data-title="Leetcode 第158场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第159场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC159%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC159%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第159场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本周做完比赛收获比较大，对二分查找还有滑动窗口有了更新的认识。也深深感到要想达到一定的高度，刻意练习是一定要做的。有些题目别人两分钟写完代码，但是不会的即使一天也没思路。看看排名前面的，十几分钟搞定四道题，一定是经过了不少练习，再加上先天智商达到的。</p>
<p>第三题可以用二分查找在Nlog(N)解答，还可以用滑动窗口在O(N)情况下解答。赛后看别人代码，理解好半天才看明白滑动窗口解答，想到的证明感觉也不太严谨。通过这个题目拓宽了思路，以后遇到类似问题，应该能解答的好一些。</p>
<p>第一题是判定三点共线，之前比赛有遇到。所以很快就搞定了。也算是练习有点成果。</p>
<p>现在做题还是靠灵感，做多了，思考多了才能靠经验。靠灵感发挥是不稳定的，靠经验稳定性要比靠灵感强。高手和普通人之间的差别，就是在稳定性上。</p>
<hr>
<p>比赛的地址 Weekly Contest 159</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-159">https://leetcode-cn.com/contest/weekly-contest-159</a></p>
<h2 id="1-缀点成线"><a href="#1-缀点成线" class="headerlink" title="1. 缀点成线"></a>1. 缀点成线</h2><p><strong>题目：</strong></p>
<p>缀点成线(Check If It Is a Straight Line)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-159/problems/check-if-it-is-a-straight-line/">https://leetcode-cn.com/contest/weekly-contest-159/problems/check-if-it-is-a-straight-line/</a></p>
<p><strong>题意：</strong></p>
<p>直角坐标系上有一堆点，判断这些点是否在同一条直线上。</p>
<p><strong>思路：</strong></p>
<p>两点确定一条直线，任意找两个点A、B。然后遍历判断其他点，是否和A、B共线即可。<br>判断方法利用向量叉乘，参考之前写的135场文章解法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">checkStraightLine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x1 = c[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y1 = c[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> x2 = c[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y2 = c[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; c.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x3 = c[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y3 = c[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> cross = (y2-y1)*(x3-x1)-(y3-y1)*(x2-x1);</span><br><span class="line">            <span class="keyword">if</span>(cross != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除子文件夹"><a href="#2-删除子文件夹" class="headerlink" title="2. 删除子文件夹"></a>2. 删除子文件夹</h2><p><strong>题目：</strong></p>
<p>删除子文件夹(Remove Sub-Folders from the Filesystem)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-159/problems/remove-sub-folders-from-the-filesystem/">https://leetcode-cn.com/contest/weekly-contest-159/problems/remove-sub-folders-from-the-filesystem/</a></p>
<p><strong>题意：</strong></p>
<p>输入是一个文件名绝对路径的字符串数组，要求输出所有父目录。</p>
<pre><code>输入：folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]
输出：[&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]
解释：&quot;/a/b/&quot; 是 &quot;/a&quot; 的子文件夹，而 &quot;/c/d/e&quot; 是 &quot;/c/d&quot; 的子文件夹。
</code></pre>
<p><strong>思路：</strong></p>
<p>对字符串数组排序，父目录和其子目录一定是相邻的，并且父目录在最前面。</p>
<p>从前往后遍历，判断目录是否是已有的最后一个父目录的子目录，如果不是子目录，则为新的父目录。</p>
<p>也可以用trie树，先全部插入到树中。然后深度优先遍历，遍历到某个节点有结尾符，就不再遍历它为<code>/</code>的子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSubDir</span><span class="params">(<span class="built_in">string</span>&amp; sub, <span class="built_in">string</span> &amp; str)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub.push_back(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> len = sub.size();</span><br><span class="line">        <span class="type">bool</span> isSub = str.substr(<span class="number">0</span>, len) == sub;</span><br><span class="line">        sub.pop_back();</span><br><span class="line">        <span class="keyword">return</span> isSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">removeSubfolders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; folder)</span> &#123;</span><br><span class="line">        sort(folder.begin(), folder.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        ans.push_back(folder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; folder.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSubDir(ans.back(), folder[i]) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(folder[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-替换子串得到平衡字符串"><a href="#3-替换子串得到平衡字符串" class="headerlink" title="3. 替换子串得到平衡字符串"></a>3. 替换子串得到平衡字符串</h2><p><strong>题目：</strong></p>
<p>替换子串得到平衡字符串(Replace the Substring for Balanced String)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-159/problems/replace-the-substring-for-balanced-string/">https://leetcode-cn.com/contest/weekly-contest-159/problems/replace-the-substring-for-balanced-string/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p>
<p>假如在该字符串中，这四个字符都恰好出现 n&#x2F;4 次，那么它就是一个「平衡字符串」。</p>
<p>给你一个这样的字符串 s，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p>
<p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p>
<p>请返回待替换子串的最小可能长度。</p>
<p>如果原字符串自身就是一个平衡字符串，则返回 0。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>如何判断一段字串替换后是否已能平衡？</p>
<p>由于子串内的字符可以任意变换。整个字符串的长度n又是4的倍数。</p>
<p>所以，子串外的四个字符，每个的个数都不大于n&#x2F;4就能变换成功。</p>
<p>如何找到哪段子串能替换是难点。</p>
<p>有两种方法：</p>
<p>方法一：二分枚举替换字符串长度，然后验证每个长度的替换子串，是否能满足提议。</p>
<p>如果满足，则减少最大值。</p>
<p>如果不满足，则增大最小值。</p>
<p>最后左右区间会落在满足的最小值上。</p>
<p>方法二：滑动窗口，在滑动的过程中找到最小值。</p>
<p>以0为最左侧窗口边缘，然后枚举最右侧边缘。如果满足条件，则不断缩小左侧。</p>
<p>假设<code>i1&lt;j1, i2&lt;j2, j1&lt;j2, i2&lt;j1</code>,[i1,j1],[i2,j2]两条线段有交集有，他们两个是最接近的满足条件的区间。</p>
<p>如果[i2, j2]是最优解，那么一定i1 &lt; i2。因为[i1,j1]一定比[i2,j2]短。</p>
<p>当在[i1, j1]的时候成立时，移动i1的时候，一定会移动到i1+1的位置让条件不成立。这时再扩大右侧时，</p>
<p>在(j1, j2)过程中，不会有满足条件的，到右侧达到j2的时候，会满足条件，而且会逐步缩小到i2。</p>
<p>就是在枚举右侧边际的时候，左侧边缘不会再减小，只会逐渐增大。</p>
<p>方法一代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">string</span> letter = <span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            count[ch]++;</span><br><span class="line">        <span class="type">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">auto</span> isBalance = [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : letter)</span><br><span class="line">                <span class="keyword">if</span>(count[ch] &gt; n / <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; bak = count;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> isOk = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">char</span> ch = s[i];</span><br><span class="line">                count[ch]--;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= mid)</span><br><span class="line">                    count[s[i - mid]]++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= mid - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isBalance()) &#123;</span><br><span class="line">                        isOk = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isOk) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            count = bak;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="built_in">string</span> letter = <span class="string">&quot;QWER&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            count[ch]++;</span><br><span class="line">        <span class="type">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">auto</span> isBalance = [&amp;]()-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : letter)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count[ch] &gt; n / <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            count[s[r]]--;</span><br><span class="line">            <span class="keyword">while</span>(isBalance() &amp;&amp; l &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                count[s[l]]++;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-规划兼职工作"><a href="#4-规划兼职工作" class="headerlink" title="4. 规划兼职工作"></a>4. 规划兼职工作</h2><p><strong>题目：</strong></p>
<p>规划兼职工作(Maximum Profit in Job Scheduling)</p>
<p><strong>地址：</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-159/problems/maximum-profit-in-job-scheduling/">https://leetcode-cn.com/contest/weekly-contest-159/problems/maximum-profit-in-job-scheduling/</a></p>
<p><strong>题意：</strong></p>
<blockquote>
<p>有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。</p>
<p>给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。</p>
</blockquote>
<blockquote>
<p>输入：startTime &#x3D; [1,2,3,3], endTime &#x3D; [3,4,5,6], profit &#x3D; [50,10,40,70]<br>输出：120<br>解释：<br>我们选出第 1 份和第 4 份工作，<br>时间范围是 [1-3]+[3-6]，共获得报酬 120 &#x3D; 50 + 70。</p>
</blockquote>
<p><strong>思路：</strong></p>
<p>先给工作按结束时间排序。每项工作，要么做，要么不做。</p>
<p>动态规划公式dp[n]表示前n项工作的最优解。v[n]表示第n份工作的价值。</p>
<p>再算dp[n+1]时，分两种情况。</p>
<ol>
<li>不选择第n+1份工作，则dp[n+1]&#x3D;dp[n];</li>
<li>选择第n+1份工作，则dp[n+1]&#x3D;v[n]+dp[j];(做完第j份工作，就做第n份工作。所以j的选取从小于等于第n+1份工作开始时间中，最大的工作序号)</li>
</ol>
<p>两种情况的最大值，就为dp[n+1]的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Job</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">int</span> cost;</span><br><span class="line">        <span class="type">bool</span> operator &lt; (Job &amp;other) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> end &lt; other.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; endTime, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; profit)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Job&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; startTime.size(); ++i)</span><br><span class="line">            v.push_back(&#123;startTime[i], endTime[i], profit[i]&#125;);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        <span class="type">int</span> n = v.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dp</span><span class="params">(n, <span class="number">0</span>)</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = v[<span class="number">0</span>].cost;</span><br><span class="line">        Job job&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> not_with = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> with = v[i].cost;</span><br><span class="line">            job.end = v[i].start;</span><br><span class="line">            <span class="type">int</span> j = upper_bound(v.begin(), v.begin() + i, job) - v.begin() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">                with += dp[j];</span><br><span class="line">            dp[i] = max(with, not_with);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>第三题</p>
<pre><code>class Solution
&#123;
public:
    int balancedString(string str)
    &#123;
        int n = str.size();
        unordered_map&lt;char, int&gt; cnt, slide;
        for(auto &amp;ch : &quot;QWER&quot;)
            cnt[ch] = 0;
        for(auto &amp;ch : str)
            cnt[ch]++;
        for(auto &amp;ch : &quot;QWER&quot;)
            cnt[ch] -= n / 4;
            
        int s = 0;
        int t = 0;
        int ret = n;
        auto isOk = [&amp;]()
        &#123;
            for(auto ch : &quot;QWER&quot;)
            &#123;
                if(slide[ch] &lt; cnt[ch])
                    return false;
            &#125;
            return true;
        &#125;;
        //if(isOk())
            //return 0;
        
        //s,t是左闭右开区间[s, t)，所以for循环要判断s不能超过n，但是循环里要判断isOk是否不满足
        //不能判断t==n退出循环
        for( ; s &lt; n; ) &#123;
            //cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt;  endl;
            while(t &lt; n &amp;&amp; !isOk()) &#123;
                slide[str[t++]]++;
            &#125;
            //bool ok = isOk();
            //cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ok &lt;&lt; endl;
            if(!isOk())
                break;
            ret = min(t - s, ret);
            slide[str[s++]]--;
        &#125;
        return ret;
    &#125;
&#125;;

/*
&quot;QWER&quot;
&quot;QQWE&quot;
&quot;QQQW&quot;
&quot;QQQQ&quot;
&quot;WQWRQQQW&quot;
*/
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC159%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70ko0007ab0oo4w3zbezl" data-title="Leetcode 第159场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>