<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owen的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/page/10/index.html">
<meta property="og:site_name" content="owen的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owen的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2013/2013-06-26-gcc-fno-strict-aliasing-options-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-06-26-gcc-fno-strict-aliasing-options-note/" class="article-date">
  <time class="dt-published" datetime="2013-06-26T01:53:13.000Z" itemprop="datePublished">2013-06-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-06-26-gcc-fno-strict-aliasing-options-note/">gcc -fno-strict-aliasing 选项注意</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在做CRO的时候发现好多makefile都使用了“-fno-strict-aliasing”选项，仔细查看了一下他的含义，发现在使用优化的时候，大家应该多注意。</p>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<p>If optimization level is &gt;&#x3D; 2 in gcc-4.1, strict-aliasing is used, and this could cause probelms when a pointer is referencing to a different type of object and the object is refered there after by using this pointer. That is the case in this example. So you should force the compiler to not use strict-aliasing by a argument “-fno-strict-aliasing” if you want to use “-O2” or “-O3”.</p>
<p>在gcc4.1版本以上，如果多种类型的指针指向同一块内存，使用-O2或-O3优化时，会把不同类型指针的操作给优化掉，认为不会有不同类型的指针操作同一块内存。</p>
<p>举个例子</p>
<pre><code>#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/time.h&gt;
#include 

int n;
int foo(unsigned long *ptr) &#123;        
    n=1;
    *ptr=3;
    return n;
&#125;
int main() &#123;
    fprintf(stdout, &quot;%d\n&quot;, foo(&amp;n));
    return 0;
&#125;
</code></pre>
<p>代码编译</p>
<p>​<br>     gcc main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    3</p>
<p>如果优化</p>
<p>​<br>     gcc -O2 main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    1</p>
<p>加入参数</p>
<p>​<br>     gcc -O2 -fno-strict-aliasing main.c &amp;&amp; .&#x2F;a.out<br>    main.c: In function ‘main’:<br>    main.c:15: warning: passing argument 1 of ‘foo’ from incompatible pointer type<br>    main.c:9: note: expected ‘long unsigned int *’ but argument is of type ‘int *’<br>    3</p>
<p>综上，得出结论：</p>
<p>1.重视编译告警，根据告警修复代码。</p>
<p>2.编译优化是否真的重要，对性能提升是否明显，如果不需要尽量不要提早优化，gcc的优化参数很多，有些坑没踩过是不会hold住的。</p>
<p>3.尽量减少不同类型指针强转的操作，可以使用同类型指针或者union操作等方法。</p>
<p>4.编译优化加上“-fno-strict-aliasing”选项，让编译器不优化这里。</p>
<p><a target="_blank" rel="noopener" href="http://www.dutor.net/index.php/2012/07/gcc-strict-aliasing/">http://www.dutor.net/index.php/2012/07/gcc-strict-aliasing/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.zeali.net/entry/454">http://www.zeali.net/entry/454</a></p>
<p><a target="_blank" rel="noopener" href="http://hi.baidu.com/rsjdsibkwtnrxyr/item/b04e86dbdc8351de241f40cc">http://hi.baidu.com/rsjdsibkwtnrxyr/item/b04e86dbdc8351de241f40cc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-06-26-gcc-fno-strict-aliasing-options-note/" data-id="clyu6o6zn0039arq50zrf0ry8" data-title="gcc -fno-strict-aliasing 选项注意" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-06-18-tcp-and-udp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-06-18-tcp-and-udp/" class="article-date">
  <time class="dt-published" datetime="2013-06-18T03:14:31.000Z" itemprop="datePublished">2013-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-06-18-tcp-and-udp/">tcp和udp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>tcp适合对流量敏感的应用，tcp的窗口机制可以很好的利用带宽。</p>
<p>udp适合对时延敏感的应用。</p>
<p>mtu尺寸576bit（包括ip和udp包头）否则太大会出现路由器组分包的时候错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-06-18-tcp-and-udp/" data-id="clyu6o6zn0037arq5b4dw8dg9" data-title="tcp和udp" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name/" class="article-date">
  <time class="dt-published" datetime="2013-06-13T23:11:25.000Z" itemprop="datePublished">2013-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name/">两种修改主机名方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、修改redhat类机器</p>
<blockquote>
<p>cat &#x2F;etc&#x2F;sysconfig&#x2F;network<br>NETWORKING&#x3D;yes</p>
</blockquote>
<p>HOSTNAME&#x3D;myservice</p>
<p>二、修改suse机器</p>
<blockquote>
<p>&#x2F;etc&#x2F;HOSTNAME</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-06-14-two-kinds-of-methods-to-modify-the-host-name/" data-id="clyu6o6zm0035arq533mabcbd" data-title="两种修改主机名方法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-06-04-traces-of-life-have" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-06-04-traces-of-life-have/" class="article-date">
  <time class="dt-published" datetime="2013-06-04T07:01:39.000Z" itemprop="datePublished">2013-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-06-04-traces-of-life-have/">生命要有痕迹</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>时光飞逝，白驹过隙。致即将逝去的青春。生命还有多少值得我们去浪费，对于时间不可再生的财产，要规划下了。生命就如焰火，绚烂一阵，遍飞逝了。然而并不是每个人都能在天空划出一道美丽的光彩，生命究竟应该怎样度过？活过，就要有痕迹。</p>
<p>如果感觉生活是乏味的，那么不是生活乏味，而是你把生活给过得乏味了。遇到问题并不可怕，要改变现状，让生活更美好。</p>
<p>重复，单调是浪费时间，如果有重复单调的事情，要想办法让他不再来，来了有自动的应对方法。人生苦短，我们要陪家人，要赚钱，还要拯救世界，时间对我们太重要了，不要浪费。要知道自己要的是什么，而不是做的过程，不是埋头干。有了目标，朝着目标前行。做个有观点的人，有目标的人才为人。</p>
<p>不屈服、不随流，最终达到目标，就如焰火飞向高空，划出最美的曲线，给人留下印象，然后结束一生，不枉此行。</p>
<p>不同年龄做不同的事，莫压抑，莫张狂，活过，就要有痕迹。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-06-04-traces-of-life-have/" data-id="clyu6o6zm0033arq5comdb05s" data-title="生命要有痕迹" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-05-29-glibc-random-function" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-05-29-glibc-random-function/" class="article-date">
  <time class="dt-published" datetime="2013-05-28T22:11:33.000Z" itemprop="datePublished">2013-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-05-29-glibc-random-function/">glibc随机函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、如何使用随机函数<br>查看man可以找到<br>#include &lt;stdlib.h&gt;</p>
<p>int rand(void);</p>
<p>int rand_r(unsigned int *seedp);</p>
<p>void srand(unsigned int seed);</p>
<p>rand返回0~RAND_MAX之间的整数，是“伪随机”<br>srand()用来设置rand函数的随机种子，随机种子相同产生的随机数序列也是相同的。<br>如果没调用srand那么rand函数自动使用1作为种子。</p>
<p>在函数初始化的时候srand()调用设置一次随机种子就可以里，不必每次调用rand都使用srand调用。</p>
<p>随机函数原理<br>RAND_MAX的值为32767<br>原理是使用Linear-Congruential-Random-Number-Generator算法产生伪随机数。（具体的我还没弄明白）弄明白再补一篇。<br>函数如下</p>
<pre><code>static int32_t randtbl[DEG_3 + 1] =
  &#123;
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  &#125;;
/* Initialize the random number generator based on the given seed.  If the
   type is the trivial no-state-information type, just remember the seed.
   Otherwise, initializes state[] based on the given &quot;seed&quot; via a linear
   congruential generator.  Then, the pointers are set to known locations
   that are exactly rand_sep places apart.  Lastly, it cycles the state
   information a given number of times to get rid of any initial dependencies
   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
   for default usage relies on values produced by this routine.  */
int
__srandom_r (seed, buf)
     unsigned int seed;
     struct random_data *buf;
&#123;
  int type;
  int32_t *state;
  long int i;
  int32_t word;
  int32_t *dst;
  int kc;

  if (buf == NULL)
    goto fail;
  type = buf-&gt;rand_type;
  if ((unsigned int) type &gt;= MAX_TYPES)
    goto fail;

  state = buf-&gt;state;
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  if (seed == 0)
    seed = 1;
  state[0] = seed;
  if (type == TYPE_0)
    goto done;

  dst = state;
  word = seed;
  kc = buf-&gt;rand_deg;
   for (i = 1; i &lt; kc; ++i)
     &#123;
       /* This does:
        state[i] = (16807 * state[i - 1]) % 2147483647;
      but avoids overflowing 31 bits.  */
       long int hi = word / 127773;
       long int lo = word % 127773;
       word = 16807 * lo - 2836 * hi;
       if (word &lt; 0)
     word += 2147483647;
       *++dst = word;
     &#125;

   buf-&gt;fptr = &amp;state[buf-&gt;rand_sep];
   buf-&gt;rptr = &amp;state[0];
   kc *= 10;
   while (--kc &gt;= 0)
     &#123;
       int32_t discard;
       (void) __random_r (buf, &amp;discard);
     &#125;

  done:
   return 0;

  fail:
   return -1;
 &#125;




int
__random_r (buf, result)
     struct random_data *buf;
     int32_t *result;
&#123;
  int32_t *state;

  if (buf == NULL || result == NULL)
    goto fail;

  state = buf-&gt;state;

  if (buf-&gt;rand_type == TYPE_0)
    &#123;
      int32_t val = state[0];
      val = ((state[0] * 1103515245) + 12345) &amp; 0x7fffffff;
      state[0] = val;
      *result = val;
    &#125;
  else
    &#123;
      int32_t *fptr = buf-&gt;fptr;
      int32_t *rptr = buf-&gt;rptr;
      int32_t *end_ptr = buf-&gt;end_ptr;
      int32_t val;

      val = *fptr += *rptr;
      /* Chucking least random bit.  */
      *result = (val &gt;&gt; 1) &amp; 0x7fffffff;
      ++fptr;
      if (fptr &gt;= end_ptr)
    &#123;
      fptr = state;
      ++rptr;                                              
    &#125;
      else
    &#123;
      ++rptr;
      if (rptr &gt;= end_ptr)
        rptr = state;
    &#125;
      buf-&gt;fptr = fptr;
      buf-&gt;rptr = rptr;
    &#125;
  return 0;

 fail:                  
  __set_errno (EINVAL);
  return -1;
&#125;
</code></pre>
<p>可以看到，设置随机种子的时候操作很复杂，如果每次rand都调用srand是非常耗时，而且没有用途的。特别是有人总是用srand(time(NULL))，那样一秒钟产生的随机数都是相同的，根本没有作用。</p>
<p>二、使用场景</p>
<p>如果只是为了使用随机得到尽量乱平均的数字，可以使用rand函数，或者使用自己写的</p>
<pre><code>static unsigned long next = 1;

/* RAND_MAX assumed to be 32767 */
int myrand(void) &#123;
next = next * 1103515245 + 12345;
return((unsigned)(next/65536) % 32768);
&#125;

void mysrand(unsigned seed) &#123;
next = seed;
&#125;
</code></pre>
<p>也能达到效果，例如在寻址函数中随机挑选一个服务器，为的就是平均，即使轮询影响也不大。</p>
<p>如果是为了加密，构造随机数，那么rand函数不适合你，还是用硬件的函数吧<br>参考硬件相关的安全随机数：<a target="_blank" rel="noopener" href="http://yunpengzhang.com/articles/202.html">&#x2F;dev&#x2F;random和&#x2F;dev&#x2F;urandom</a></p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/flyoxs/article/details/5331718">http://blog.csdn.net/flyoxs/article/details/5331718</a></p>
<p><a target="_blank" rel="noopener" href="http://hi.baidu.com/tlogin/item/e619169c2c0dfdc9b6253149">http://hi.baidu.com/tlogin/item/e619169c2c0dfdc9b6253149</a></p>
<p><a target="_blank" rel="noopener" href="http://hi.baidu.com/g0t3n/item/c3508beaa9a903b22f140baf">http://hi.baidu.com/g0t3n/item/c3508beaa9a903b22f140baf</a></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Linear_congruential_generator">http://en.wikipedia.org/wiki/Linear_congruential_generator</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-05-29-glibc-random-function/" data-id="clyu6o6zl0031arq5hxb4br0r" data-title="glibc随机函数" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions/" class="article-date">
  <time class="dt-published" datetime="2013-05-27T04:59:01.000Z" itemprop="datePublished">2013-05-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions/">随机端口复用导致丢包的问题及解决方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>因为redhad随机分配端口和suse策略不同，导致有随机分配端口的业务迁移到redhad上会</p>
<p>出现端口被抢占而丢包的问题。</p>
<p><strong>解决方法：</strong></p>
<p><strong>【方法一】</strong>创建socket的时候，setsockopt函数设置绑定端口socket的属性为不可重用的。</p>
<p><strong>【方法二】</strong>控制绑定端口范围在32768以下。</p>
<p>**0.**<strong>抢占的原则是什么？</strong></p>
<p>**      **   顺序和系统实现有关，我们公司的suse和redhad都是后启动绑定的socket抢占先绑定的。</p>
<p>**1.**<strong>为什么会出现tlinux上而suse没事？</strong></p>
<p>因为suse随机绑定端口时会绕过已经被绑定的端口，而tlinux不会，会完全</p>
<p>随机。但是已经绑定的端口如果设置成not reuse，就不会被绑定。</p>
<p>**2.**<strong>都什么程序会出现这种问题？</strong></p>
<p>有随机绑定端口，而且设置成reuse的都可能会遇到。</p>
<p>例如：</p>
<p>如果初始化函数地址填0，会随机绑定端口。</p>
<p>一些老的agent进程也是随机创建端口，而且也是允许reuse。</p>
<p>一些程序内部的api会随机创建端口发包收取。</p>
<p>**3.**<strong>为什么要缩小绑定端口范围在32768以下？</strong></p>
<p>**     **    因为系统的配置随机范围在32768——61000范围。</p>
<blockquote>
<p>sysctl -a | grep ip_local_port_range<br>net.ipv4.ip_local_port_range &#x3D; 32768 61000</p>
</blockquote>
<p>我们的老库创建socket函数，框架都设置udp是socket在创建时是reuse的，</p>
<p>所以迁移tlinux都会出现这些问题。</p>
<p>对于udp，不用设置reuse，因为只有多播的时候才需要，但是我们的</p>
<p>业务并不使用多播。可能是框架和库出于对tcp的统一，都设置成了reuse。</p>
<p>深度参考</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/dog250/article/details/5303572">http://blog.csdn.net/dog250/article/details/5303572</a></p>
<p>vi &#x2F;etc&#x2F;sysctl.conf<br>添加下面一行：<br>net.ipv4.ip_local_port_range &#x3D; 1024 65535</p>
<p>然后执行：</p>
<p>sysctl -p</p>
<p>意思是告诉linux可以使用的端口是从1024到65535，不用编译内核就可以生效。<br>[root@PerfTestApp3 ~]# sysctl -a|grep ip_local_port_range<br>net.ipv4.ip_local_port_range &#x3D; 32768 61000</p>
<p><a target="_blank" rel="noopener" href="http://rdc.taobao.com/blog/cs/?p=1195">http://rdc.taobao.com/blog/cs/?p=1195</a><br>SO_REUSEADDR可以用在以下四种情况下。<br>(摘自《Unix网络编程》卷一，即UNPv1)<br>1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启<br>动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。<br>2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但<br>每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可<br>以测试这种情况。<br>3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个soc<br>ket绑定的ip地址不同。这和2很相似，区别请看UNPv1。<br>4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的<br>多播，不用于TCP。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-05-27-random-port-multiplexing-and-packet-loss-problems-and-solutions/" data-id="clyu6o6zl002zarq5cip1dt9s" data-title="随机端口复用导致丢包的问题及解决方法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-01-31-snprintf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-01-31-snprintf/" class="article-date">
  <time class="dt-published" datetime="2013-01-31T06:30:44.000Z" itemprop="datePublished">2013-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-01-31-snprintf/">snprintf</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h2><p>int snprintf(char *str, size_t size, const char *format, …);</p>
<p>将可变个<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/327406.htm">参数</a>(…)按照format格式化成字符串，然后将其复制到str中</p>
<p>(1) 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符(‘\0’)；</p>
<p>(2) 如果格式化后的字符串长度 &gt;&#x3D; size，则只将其中的(size-1)个字符复制到str中，并返回一个负值，其后没有字符串结束符(‘\0’)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-01-31-snprintf/" data-id="clyu6o6zk002xarq5bcfm8nuz" data-title="snprintf" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2012/2012-12-30-learn-drip" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2012/2012-12-30-learn-drip/" class="article-date">
  <time class="dt-published" datetime="2012-12-29T22:46:16.000Z" itemprop="datePublished">2012-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2012/2012-12-30-learn-drip/">学习点滴</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>工作了几年的人，一问起是否还在学习，很多都说太忙了，没有时间学习。确实，每天工作的时间都很长，而且杂事琐事也很多，有时回到家里，脑子里想得还是工作的事情。想大块的时间来读书，学习并实践新的知识还是很难的。但是it行业不进则退，上班后要如何充电呢？</p>
        
          <p class="article-more-link">
            <a href="/2012/2012-12-30-learn-drip/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2012/2012-12-30-learn-drip/" data-id="clyu6o6zi002parq5gg1v1ma8" data-title="学习点滴" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2012/2012-12-29-resolve-memory-access-conflicts" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2012/2012-12-29-resolve-memory-access-conflicts/" class="article-date">
  <time class="dt-published" datetime="2012-12-29T05:23:24.000Z" itemprop="datePublished">2012-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2012/2012-12-29-resolve-memory-access-conflicts/">解决内存读写冲突</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近遇到了几个内存读写冲突的场景：</p>
<p>1.内存hash读写冲突</p>
<p>一个进程写，多个进程读，当读进程找到要读取的指针时，写进程进行了写操作，然后回收了原先读进程要读的内存块。这时cpu又调度到读进程，读失败，返回错误给前端，重试ok。</p>
<p>由于业务场景可以容忍读到旧数据，最终采用的解决方法为延迟回收内存块，即内存回收前放到一个回收队列里，先不清理数据，过500ms后再回收数据，有重组的时间等待读冲突的读进程取数据。</p>
        
          <p class="article-more-link">
            <a href="/2012/2012-12-29-resolve-memory-access-conflicts/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2012/2012-12-29-resolve-memory-access-conflicts/" data-id="clyu6o6zh002narq588pghelo" data-title="解决内存读写冲突" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2012/2012-12-23-the-art-of-unix-programming-reading-notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2012/2012-12-23-the-art-of-unix-programming-reading-notes/" class="article-date">
  <time class="dt-published" datetime="2012-12-23T05:31:43.000Z" itemprop="datePublished">2012-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2012/2012-12-23-the-art-of-unix-programming-reading-notes/">《the art of unix programming》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>是什么吸引程序开发使用*nix平台，为什么全世界去修改这个系统还这么井然有序。这和unix的设计哲学分不开，一个好的架构，软件的执行思想，使得无论使用和开发这个系统都是那么的吸引人，简单。这本书介绍了很多unix的艺术，让人觉得好的架构和思想真是一门学问，用艺术的观点来开发系统，简单的东西实现复杂的规则，本身就是美。它山之石，不只是操作系统，在其他的系统、领域，都是通用的。</p>
<p>ken thompson:先制作原型，再精雕细琢。优化之前先确保能用。<br>“极限编程”宗师kent beck从另一种不同的文化将这点扩展为：先求运行，再求正确，最后求快。</p>
<p>系统和函数要对接收的东西要包容，对输出的东西要严格。</p>
<p>态度：看到该做的就去做——短期来看似乎是多做了，但从长期看来，这才是最佳捷径。<br>如果不能确定什么是对的，那么就只做最少量的工作，确保任务完成就行，至少直到明白什么是对的。</p>
<p>良好运用unix哲学，应该珍惜你的时间决不浪费，一旦某人已经解决了某个问题，就直接拿来利用，<br>不要让骄傲或偏见拽祝你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，<br>好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p>
<p>模块化原则的内容：<br>模块化代码的首要特质就是封装。封装良好的模块不会过多向外部披露自身的细节，不会直接调用其他模块的实现码，<br>也不会胡乱共享全局数据。模块之间通过应用程序编程接口（API）——一组严密、定义良好的程序调用和数据结构来通信。</p>
<p>88p</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2012/2012-12-23-the-art-of-unix-programming-reading-notes/" data-id="clyu6o6zg002larq5huumete2" data-title="《the art of unix programming》读书笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/11/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>