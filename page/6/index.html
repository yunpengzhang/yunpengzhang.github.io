<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owenzhang的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/page/6/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2018/素食跑步修行" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E7%B4%A0%E9%A3%9F%E8%B7%91%E6%AD%A5%E4%BF%AE%E8%A1%8C/" class="article-date">
  <time class="dt-published" datetime="2018-09-10T10:00:03.000Z" itemprop="datePublished">2018-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>►<a class="article-category-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E7%B4%A0%E9%A3%9F%E8%B7%91%E6%AD%A5%E4%BF%AE%E8%A1%8C/">素食跑步修行</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这本书的作者是“斯科特.尤雷克”，他是一名著名的超级马拉松运动员，获得过很多超级马拉松的冠军和记录。书的主要内容是斯科特的跑步生涯的介绍，从他小时候，一直到他成年参加各种超级马拉松的经历。</p>
<p>开始很想读这本书，以为会介绍一些跑步的方法和技巧；中间不怎么爱读，发现是作者的自传，和跑步技巧比较少相关；后面又很想读，因为比赛的经历还是有些挺精彩的。</p>
<p>书中的素食参考性不大，材料比较难买，而且并不一定适合国人。网上有热心人总结了菜谱，感兴趣的可以照着烹饪。<br><a target="_blank" rel="noopener" href="https://www.douban.com/note/612997316/">‘ 超马之神 ’ 的 素食食谱 – 整理自《素食 跑步 修行》</a></p>
<p>他小时候他爸爸和他说“去做就对了”对他影响很深，他遇到问题时都是思考这个问题。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获得心神安宁的钥匙</span><br><span class="line"></span><br><span class="line">我跑步，并保持跑步的习惯，正是因为我领悟到：一旦你开始做某件事，而且一直没有放弃，你就得继续做下去。这是生命的真谛，也像超马赛事一样，没有回头路，只能向前跑。</span><br><span class="line"></span><br><span class="line">方法只有一个：爬起来，继续跑。人生中遭遇任何困难，解决方法永远是努力向前走！</span><br></pre></td></tr></table></figure>

<p>在2001和2002参加香港乐施毅行者，获得冠军还破了记录。 </p>
<p>超马更多靠的是意志，有恶劣的天气，伤痛，都要坚持跑完，还有强劲的竞争者。能够冲过终点线，都是很不容易的。<br>跑步可以去各种地方跑，领略各种不同的风土人情。<br>跑步的对手，在生活中还成了朋友，一起生活和训练。</p>
<p>对于参加毅行者的同学，是有参考意义的，通过这个能够了解超级马拉松的跑步和训练过程，对超马有所了解。而且有些章节的内容还是很精彩的。</p>
<p>跑者中有些怪人，而且印第安人也有擅长跑步的塔拉乌马拉人，跑超跑的人并不是为了名和钱靠那些很难坚持跑完。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E7%B4%A0%E9%A3%9F%E8%B7%91%E6%AD%A5%E4%BF%AE%E8%A1%8C/" data-id="clyu70knr006gb0oo7nhz99h8" data-title="素食跑步修行" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/十分钟了解ZAB（Zookeeper Atomic Broadcast）协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ZAB%EF%BC%88Zookeeper%20Atomic%20Broadcast%EF%BC%89%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2018-09-07T10:00:03.000Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ZAB%EF%BC%88Zookeeper%20Atomic%20Broadcast%EF%BC%89%E5%8D%8F%E8%AE%AE/">十分钟了解ZAB（Zookeeper Atomic Broadcast）协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Zookeeper基于ZAB（Zookeeper Atomic Broadcast），实现了主备模式下的系统架构，保持集群中各个副本之间的数据一致性。</p>
<p>ZAB协议定义了选举（election）、发现（discovery）、同步（sync）、广播(Broadcast)四个阶段。</p>
<p>选举（election）是选出哪台为主机；<br>发现（discovery）、同步（sync）当主选出后，要做的恢复数据的阶段；</p>
<p>广播(Broadcast)当主机和从选出并同步好数据后，正常的主写同步从写数据的阶段。</p>
<p>下面简单地介绍下ZAB协议，目的是能够快速了解其精髓，快速掌握ZAB协议。然后通过论文了解具体协议的细节。主要介绍选举和广播两个阶段。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们了解下zk的一些基本概念。</p>
<p>zk集群有三种角色：</p>
<ul>
<li>leader 就是我们说的主；</li>
<li>follower 就是我们说的从；</li>
<li>observer 可以认为是主的clone copy，不参与投票，本文可忽略；</li>
</ul>
<p>zk集群的一个节点，有三种状态：</p>
<ul>
<li>looking 选举状态，当前群龙无首；</li>
<li>leading leader才有的状态；</li>
<li>following follower才有的状态；</li>
</ul>
<p>每次写成功的消息，都有一个全局唯一的标识，叫zxid。是64bit的正整数，高32为叫epoch表示选举纪元，低32位是自增的id，每写一次加一。<br>可以想象为中国古代的年号，例如万历十五年，万历是epoch，十五年是id。</p>
<p>zk集群一般都是奇数个机器（2n+1）,只有一个主机leader，其余都是从机follower。选主还是写数据，要有&gt;&#x3D;n+1台选举相同，才能执行选举的操作。</p>
<p>投票优先级：优先比较zxid，如果相等，再比较机器的id，都按从大到小的顺序。</p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>当集群新建，或者主机死机，或者主机与一半或以上的从机失去联系后，都会触发选择新的主机操作。有两种算法<code>fast paxos</code>和<code>basic paxos</code>。</p>
<h3 id="fast-paxos"><a href="#fast-paxos" class="headerlink" title="fast paxos"></a>fast paxos</h3><p>默认ZAB采用的算法是fast paxos算法。</p>
<p>每次选举都要把选举轮数加一，类似于zxid里的epoch字段，防止不同轮次的选举互相干扰。</p>
<p>每个进入looking状态的节点，最开始投票给自己，然后把投票消息发给其它机器。内容为**&lt;第几轮投票，被投节点的zxid，被投节点的编号&gt;**。</p>
<p>其他looking状态的节点收到后，</p>
<p>1 首先判断票是否有效。<br>是否有效的方法为看票的投票轮数和本地记载的投票轮数是否相等：</p>
<p>2.1 如果比本地投票轮数的小，丢弃。</p>
<p>2.2 如果比本地投票轮数的大</p>
<pre><code>证明自己投票过期了，清空本地投票信息，
更新投票轮数和结果为收到的内容。
通知其他所有节点新的投票方案。
</code></pre>
<p>2.3 如果和本地投票轮数相等，按照投票的优先级比较收到的选票和自己投出去的选票。</p>
<pre><code>2.3.1 如果收到的优先级大，
更新自己的投票为对方发过来投票方案，把投票发出去。

2.3.2 如果收到的优先级小，则忽略该投票。

2.3.3 如果收到的优先级相等，
则更新对应节点的投票。
</code></pre>
<p>3 每收集到一个投票后，查看已经收到的投票结果记录列表，看是否有节点能够达到一半以上的投票数。如果有达到，则终止投票，宣布选举结束，更新自身状态。然后进行发现和同步阶段。<br>否则继续收集投票。</p>
<h3 id="basic-paxos"><a href="#basic-paxos" class="headerlink" title="basic paxos"></a>basic paxos</h3><p>1 每个looking节点先发出请求，询问其他节点的投票。</p>
<p>其他节点返回自己的投票 &lt; zk的id，zxid &gt;。第一次都投自己。</p>
<p>2 收到结果后，如果收到的投票比自己投票的zxid大，更新自己的投票。</p>
<p>3 当收到所有节点返回后，统计投票，有一个节点的选举达到一半以上，则选举成功。<br>否则继续开始下一轮询问，直到选择出leader结束。</p>
<h3 id="basic-paxos和fast-paxos区别"><a href="#basic-paxos和fast-paxos区别" class="headerlink" title="basic paxos和fast paxos区别"></a>basic paxos和fast paxos区别</h3><p>这里fast是主动推送出，只要结果有更新，就马上同步给其他节点。其他节点可能还没把自己的票通知给所有节点，就发现自己投的票优先级低，要更新投票，然后更新再重新通知给所有节点。</p>
<p>basic则要每一节点都询问完，才能知道新结果，然后再去问其他节点新的选举结果。</p>
<p>fast比basic快的地方，是一个节点，不用和每个节点都交换投票信息后，才能知道自己的票是否要更新。会减少交互次数。</p>
<h2 id="广播——主从同步"><a href="#广播——主从同步" class="headerlink" title="广播——主从同步"></a>广播——主从同步</h2><p>主从同步数据比较简单，<br>当有写操作时，如果是从机接收，会转到主机。做一次转发，保证写都是在主机上进行。</p>
<p>主先提议事务，收到过半回复后，再发提交。<br>主收到写操作时，先本地生成事务为事务生成zxid，然后发给所有follower节点。<br>当follower收到事务时，先把提议事务的日志写到本地磁盘，成功后返回给leader。<br>leader收到过半反馈后对事务提交。再通知所有的follower提交事务，follower收到后也提交事务，提交后就可以对客户端进行分发了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过只有主控制写然后同步从，保证了生成全局zxid不冲突。全局唯一的zxid能够给选举和同步数据区分出优先级。<br>选举主部分了解fast paxos原理即可。<br>核心思想是<strong>递增的zxid顺序，保证了能够有优先级最高的节点当主。</strong><br>主从同步通过<strong>提议和提交两个阶段</strong>，有超过一半的节点写成功，则认为数据写成功。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://blog.xiaohansong.com/2016/08/25/zab/">Zookeeper ZAB 协议分析</a></p>
<p><a target="_blank" rel="noopener" href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf">ZooKeeper’s atomic broadcast protocol:Theory and practice</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8bf3b7ce3eaa">Zookeeper与Paxos</a><br><a target="_blank" rel="noopener" href="http://frankfan915.iteye.com/blog/2092779">link</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ccaecde36dd3">Zookeeper的FastLeaderElection算法分析</a></p>
<p><a target="_blank" rel="noopener" href="http://techlog.cn/article/list/10182987">http://techlog.cn/article/list/10182987</a></p>
<p>官方文档 – <a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p>
<p>paxos algorithm – <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">https://en.wikipedia.org/wiki/Paxos_(computer_science)</a></p>
<p>What is a simple explanation of the Paxos algorithm? – <a target="_blank" rel="noopener" href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm">https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm</a></p>
<p>Paxos – <a target="_blank" rel="noopener" href="http://www.cs.yale.edu/homes/aspnes/pinewiki/Paxos.html">http://www.cs.yale.edu/homes/aspnes/pinewiki/Paxos.html</a></p>
<p>paxos算法如何容错的–讲述五虎将的实践 – <a target="_blank" rel="noopener" href="http://blog.csdn.net/russell_tao/article/details/7238783">http://blog.csdn.net/russell_tao/article/details/7238783</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ZAB%EF%BC%88Zookeeper%20Atomic%20Broadcast%EF%BC%89%E5%8D%8F%E8%AE%AE/" data-id="clyu70kng005db0oo1hbi4p6r" data-title="十分钟了解ZAB（Zookeeper Atomic Broadcast）协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/zookeeper典型应用场景解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/zookeeper%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2018-09-04T14:19:34.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/zookeeper%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90/">zookeeper典型应用场景解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>zookeeper实现了主动通知节点变化，原子创建节点，临时节点，按序创建节点等功能。通过以上功能的组合， zookeeper能够在分布式系统中组合出很多上层功能。下面就看几个常用到的场景，及使用方式和注意事项。</p>
<h2 id="名字服务-NameService"><a href="#名字服务-NameService" class="headerlink" title="名字服务(NameService)"></a>名字服务(NameService)</h2><p>顾名思义，就是给分布式系统中的资源，使用人易于理解的名字，能够找到需要的资源。例如：一个统一接口系统，接收服务然后转给后端服务的具体server。当新增接口时，请求方只要传递新接口的名字，系统就能够根据名字找到对应的server，发现服务并转发请求。 在zookeeper中，按照命名的规则，建立对应的目录层级，例如 &#x2F;company&#x2F;team&#x2F;service 就能找到一个公司，一个team下的提供的某个服务的路径。当上线新业务时，服务在zk中找到自己名字的节点，建立一个临时节点，写入配置信息。当调用方使用时，统一接口查询对应目录下的节点，选择合适的读取配置。当业务下掉时，直接删除服务，临时节点自动删除，服务自动下线掉。</p>
<h2 id="配置管理-Configuration-Management"><a href="#配置管理-Configuration-Management" class="headerlink" title="配置管理(Configuration Management)"></a>配置管理(Configuration Management)</h2><p>分布式系统位于不同主机的服务，有时要使用统一的配置。可以在zookeeper中的znode节点存储配置数据，每个客户端都监控（watch）znode的变化，当配置变更时，会通知推送，然后各个客户端再拉取新的配置。 注意：zk的watch是一次性的，客户端读取后要重新watch，并且检查是否是最新版本。</p>
<h2 id="组员管理-Group-Membership"><a href="#组员管理-Group-Membership" class="headerlink" title="组员管理(Group Membership)"></a>组员管理(Group Membership)</h2><p>在Master、Slave模式下，Master要知道都有哪些Slave，进行同步等操作。也要及时知道哪些Slave死掉，然后去做相应处理。具体做法是Master先建立一个&#x2F;Slave节点，每个Slave上线时都在&#x2F;Slave建立一个临时节点，写入配置，server监控&#x2F;Slave节点，对增加或消失的节点进行相应处理。 以上三种用法都属于配置类服务，按照一定的规则进行配置，需要读取配置的地方监控配置的变化。</p>
<h2 id="简单互斥锁-Simple-Lock"><a href="#简单互斥锁-Simple-Lock" class="headerlink" title="简单互斥锁(Simple Lock)"></a>简单互斥锁(Simple Lock)</h2><p>每个进程都在&#x2F;lock下创建锁znode，并watch &#x2F;lock，只有一个创建成功，当成功的进程释放锁或者停止超时会通知其他进程，重新进入竞争锁的机制。</p>
<h2 id="互斥锁-Simple-Lock-without-Herd-Effect"><a href="#互斥锁-Simple-Lock-without-Herd-Effect" class="headerlink" title="互斥锁(Simple Lock without Herd Effect)"></a>互斥锁(Simple Lock without Herd Effect)</h2><p>为了不引发惊群效应，只要能给竞争进程排序就可以了，每个进程都在&#x2F;lock的节点下创建带序号的znode，并且每个znode只监听比他次小的节点，当次小的节点释放锁后，比他次大的节点会收到通知，拿到锁权限。 <img src="http://www.owenzhang.net/blog/wp-content/uploads/2018/09/zookeeper.jpg"> 注意：防止还没有执行到的进程死掉，要更新监听顺序。例如：2监听1，3监听2，如果2进程提前死掉，3要监控到这种状态，判断是否是2关闭，还是2释放锁，如果不是正常关闭，要去监听1更新监听。</p>
<h2 id="读写锁-Read-Write-Lock"><a href="#读写锁-Read-Write-Lock" class="headerlink" title="读写锁(Read&#x2F;Write Lock)"></a>读写锁(Read&#x2F;Write Lock)</h2><p>读写锁：多个读可以并发执行，但是写和读，写和写不能同时执行。 改动互斥锁方案，<strong>如果是写锁，监听他次小的节点，次小节点释放锁后，写锁检测是否还有更小的节点，如果有继续监听，如果没有获得写锁执行</strong>；如果是读锁，监听左侧最大的写锁，当写锁释放后就获得读锁。 也要注意中间节点死掉提前释放的问题，要重新监听节点。 <img src="http://www.owenzhang.net/blog/wp-content/uploads/2018/09/zookeeper1-1.jpg"></p>
<h2 id="屏障-Barrier"><a href="#屏障-Barrier" class="headerlink" title="屏障(Barrier)"></a>屏障(Barrier)</h2><p>在分布式系统中，屏障是这样一种语义: 客户端需要等待多个进程完成各自的任务，然后才能继续往前进行下一步。 例如凌晨备份，等待每个进程把数据都dump结束后，再打包压缩传走。 client先设置&#x2F;mybarrier的znode，然后启动每个进程，每个进程执行结束成功后，在&#x2F;mybarrier下创建结束的znode节点，client发现&#x2F;mybarrier下的node数都达到了，再继续下面的任务。</p>
<h2 id="双屏障-Double-Barrier"><a href="#双屏障-Double-Barrier" class="headerlink" title="双屏障(Double Barrier)"></a>双屏障(Double Barrier)</h2><p>双屏障是这样一种语义: 它可以用来同步一个任务的开始和结束，当有足够多的进程进入屏障后，才开始执行任务；当所有的进程都执行完各自的任务后，屏障才撤销。 进入屏障：创建&#x2F;ready和&#x2F;process节点，每个进程都先到ready中注册，注册数量达到要求时，通知所有进程启动开始执行。 离开屏障：在&#x2F;process下把注册ready的进程都建立节点，每个进程执行结束后删掉&#x2F;process下的对应节点。当&#x2F;process下为空时，任务全结束。 锁、屏障，本质都是排序，给要使用的节点排序，根据顺序来执行策略，保证执行不冲突。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的应用场景，并不是只有zk能实现的，而且实现的方式也是通用的，换做其他组件，只要满足了通知和原子创建、自增id，都可以实现这些场景的使用。而且实现的方法也是通用的，不仅在zk中才这样用。 本质上就是统一配置通知机制，和原子简历自增id节点排序机制，实现了配置类和锁类协调的功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《ZooKeeper原理及使用》 <a target="_blank" rel="noopener" href="http://www.wuzesheng.com/?p=2609">http://www.wuzesheng.com/?p=2609</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/zookeeper%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%A7%A3%E6%9E%90/" data-id="clyu70knb004sb0oobo9gbwb5" data-title="zookeeper典型应用场景解析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/一种快速简洁的一致性哈希算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AE%80%E6%B4%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-09-04T05:34:07.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AE%80%E6%B4%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">一种快速简洁的一致性哈希算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在分布式系统路由分配上，一致性哈希算法有很大的优势。在之前的文章中也讲过原理。算法容易理解，但是实现上要注意很多细节，虚节点加入也要消耗更多的存储来维护映射关系。但是今天介绍的<code>jump consistent hash</code>是一种比较新颖的方法，代码简短，内存消耗少。下面我们来详细看看这个算法。</p>
<p>首先我们先了解下这个算法，有个初步的概念。然后看下这个算法适用于哪些场景，有什么作用。最后，详细分析下算法原理。</p>
<h2 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="type">uint64_t</span> key, <span class="type">int32_t</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        key = key * <span class="number">2862933555777941757ULL</span> + <span class="number">1</span>;</span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="built_in">double</span>(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>) / <span class="built_in">double</span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是算法的全部代码，输入参数分别是64位的key，桶的数量（一般对应服务器的数量），输出是一个桶的编号（从0开始）。</p>
<p>满足算法的要求：</p>
<p>平衡性，把对象均匀地分布在所有桶中。</p>
<p>单调性，当桶的数量变化时，只需要把一些对象从旧桶移动到新桶，不需要做其它移动。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>用于分布式存储产品中，而不太适合用在缓存类型的产品。因为有节点不可用时，jumphash用存活节点分担不可用节点的能力不强，会导致分布不均。但是在存储类中，节点都会有主备，主节点不可用路由到备节点，key的分布不会有变化。</p>
<p>适合在<strong>分布式系统中</strong>，根据key来选择被分配到的服务场景。每次新增新的服务节点，只有1&#x2F;n的key会变动，不会因为扩容或缩容瞬间<br>造成大部分缓存失效。</p>
<p>但是也有局限，和其他的一致性hash相比。如果有中间的桶失效，是不能够像割环hash一样，均匀分配到其他节点的，只能找个新替换<br>节点来取代。但是优点是不用存储，计算量也不大。代码短，易于实现。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>利用线性同余计算的固定性，每次输入参数固定，输出就固定的特性，来替代用存储。利用运算，减少存储空间。</p>
<p>由于运算量的优化，比查找存储空间速度更快，所以从时间、空间上算法更优。</p>
<p>引申：有时用运算生成的数字串，映射要存储的空间，会使算法有意想不到的效果。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么上面的代码能够实现一致性hash的功能，我们一步一步来看。要实现的功能就是多加一个节点，节点数变为n，只有1&#x2F;n的key会变动。</p>
<p>我们先构造一个函数，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch(key, num_buckets) </span><br><span class="line"></span><br><span class="line">表示有num_buckets个桶，一个key的值会分配到的bucket编号[0, num_buckets)。</span><br></pre></td></tr></table></figure>

<p>所以对于任意key，k，ch(k,1)&#x3D;0,因为只有一个桶。为了让算法平衡，ch(k,2)讲有一半的key留在0号桶中，一半的移到1号桶中。</p>
<p>总结的规律是，ch(k,n+1)和ch(k,n)相比，n&#x2F;(n+1)的key是不动的，1&#x2F;(n+1)的key移动到第n号桶。</p>
<p>对于每次新增桶的个数时，计算每个key的新位置，确定是否要移动到新的桶中。</p>
<p>通过随机数生成器，来判定key是否要移动到新的桶中，概率是1&#x2F;(n+1)要移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    int b = 0; // This will track ch(key, j +1) .</span><br><span class="line">    for (int j = 1; j &lt; num_buckets; j ++) &#123;</span><br><span class="line">        if (random.next() &lt; 1.0/(j+1) ) b = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代码中的random.next()产生[0,1)的随机数，随机数序列只和key有关，key为随机种子。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是满足算法的平衡性和单调性的，算法复杂度是O(N)。满足了正确性，接下来优化性能。</p>
<p>从算法代码可以看出，大多数情况下<code>random.next() &lt; 1.0/(j+1)</code>是不被执行的。</p>
<p>对于一个key来说，ch(key,j+1)的值，很少会随着j增长而变化的。当ch(key,j+1)!&#x3D;ch(key,j)时，<br>ch(key,j+1)&#x3D;j。</p>
<p>&#x2F;&#x2F;我们假设ch(key,j)是一个随机变量，通过伪随机数，来确定一个数值b，当j增长到b时，ch(key,b)!&#x3D;ch(key,b-1),<br>并且ch(key,j)&#x3D;ch(key,b-1)。</p>
<p>假设一个key的值为k，b为一个跳变的桶数量。则ch(k,b)!&#x3D;ch(k,b+1),并且ch(k,b+1)&#x3D;b.</p>
<p>下面寻找下一个比b大的跳变的桶数量j。则ch(k,j+1)！&#x3D;ch(k,j),ch(k,j)&#x3D;b,ch(k,j+1)&#x3D;j。<br>有</p>
<p>ch(k,b+1)&#x3D;b</p>
<p>ch(k,j)&#x3D;b,</p>
<p>ch(k,j)&#x3D;ch(k,b+1)</p>
<p>ch(k,j+1)&#x3D;j</p>
<p>ch(k,b)!&#x3D;ch(k,b+1)</p>
<p>ch(k,j+1)！&#x3D;ch(k,j)</p>
<p>所以，我们已知k，b时，要找到j，对于(b,j]区间的变量i，如果不发生跳变，必须满足<br>ch(k,i)&#x3D;ch(k,b+1)。</p>
<p>所以有概率</p>
<p>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先举几个例子P(ch(k,10)=ch(k,11))的概率是10/11,</span><br><span class="line"></span><br><span class="line">P(ch(k,11)=ch(k,12))的概率是11/12,</span><br><span class="line"></span><br><span class="line">所以P(ch(k,10)=ch(k,12))的概率是P(ch(k,10)=ch(k,11))*P(ch(k,11)=ch(k,12))=(10/11)*(11/12)=10/12</span><br><span class="line"></span><br><span class="line">对于任意的n&gt;=m,P(ch(k,n)=ch(k,m))=m/n。</span><br></pre></td></tr></table></figure>
<p>所以对于上面的等式，<br>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))&#x3D;(b+1)&#x2F;i。</p>
<p>假设一个随机数r在(0,1)区间，由k和j确定。</p>
<p>如果r&lt;&#x3D;(b+1)&#x2F;i,那么P(j&gt;&#x3D;i)&#x3D;（b+1)&#x2F;i为不跳变。<br>那么产生随机数r后，就能确定i的最小值为(b+1)&#x2F;r。<br>因为r&lt;&#x3D;(b+1)&#x2F;i   &#x3D;&gt;    i&lt;&#x3D;(b+1)&#x2F;r.</p>
<p>又因为i是整数，所以有<br>r！&#x3D;0</p>
<p>i&#x3D;floor((b+1)&#x2F;r)</p>
<p>代码可改写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">	random.seed(key);</span><br><span class="line">	int b = -1; // bucket number before the previous jump</span><br><span class="line">	int j = 0; // bucket number before the current jump</span><br><span class="line">	while (j &lt; num_buckets) &#123;</span><br><span class="line">		b = j;</span><br><span class="line">		r = random.next();</span><br><span class="line">		j = floor((b + 1) / r);</span><br><span class="line">	&#125;</span><br><span class="line">	return = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设r的期望为0.5，时间复杂度为Olg(N)。<br>这个算法有点绕，通过随机数的产生来判定下一跳的j，优化算法，保证在整体key的跳变满足增加桶数为n+1时，只有1&#x2F;(n+1)的数据移动。</p>
<p>我们再看</p>
<p>key &#x3D; key * 2862933555777941757ULL + 1;<br>j &#x3D; (b + 1) * (double(1LL &lt;&lt; 31) &#x2F; double((key &gt;&gt; 33) + 1));</p>
<p>和<br>r &#x3D; random.next();<br>j &#x3D; floor((b + 1) &#x2F; r);</p>
<p>有什么关系。</p>
<p>利用线性同余算法产生一个64位的整数，然后通过映射到（0，1]区间的小数。</p>
<p>(key&gt;&gt;33)+1是取key值的高31位的值再加1，范围为(1,2^31+1)<br>1LL&lt;&lt;31的值为2^31。</p>
<p>所以<br>[(key&gt;&gt;33)+1]&#x2F;1LL&lt;&lt;31 的取值范围是(0,1],如果(key&gt;&gt;33)&#x3D;2^31那么会大于1，由于是c的整数运算，大于1也会取证忽略掉小数部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该算法的精髓：通过随机种子产生随机数，减少存储；利用概率和随机数，确定key在bucket_num范围内落在的桶序号。</p>
<p>既减少了运算量，也易于实现，对于存储类路由非常适合，而且key的分散性不依赖key本身，只依赖随即生成器，对key的要求不高，不用做转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E7%AE%80%E6%B4%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" data-id="clyu70knc004ub0oo2fanfeu3" data-title="一种快速简洁的一致性哈希算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/深入浅出zookeeper之一：功能及本质" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAzookeeper%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%8F%8A%E6%9C%AC%E8%B4%A8/" class="article-date">
  <time class="dt-published" datetime="2018-08-26T15:39:20.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAzookeeper%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%8F%8A%E6%9C%AC%E8%B4%A8/">深入浅出zookeeper之一：功能及本质</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>zookeeper（下文简写为zk）大家都不陌生。但是，看到很多同学对zookeeper的理解过于程式化，有些地方甚至需要背，是大可不必的。把本质理解了，概念性和功能介绍都可以推出来的，而且架构要活学活用，透过现象看本质，才能对技术和技术领悟有大的提升。下面来看下zk的功能及本质。</p>
<h2 id="zookeeper的定义及用途"><a href="#zookeeper的定义及用途" class="headerlink" title="zookeeper的定义及用途"></a>zookeeper的定义及用途</h2><p>我们先了解官方的定义。</p>
<blockquote>
<p>Apache ZooKeeper is an effort to develop and maintain an open-source server which enables highly reliable distributed coordination. Apache ZooKeeper 是一个致力于开发和维护开源服务器，该服务器实现高可用的分布式协调框架。 ZooKeeper is a high-performance coordination service for distributed applications. It exposes common services - such as naming, configuration management, synchronization, and group services - in a simple interface so you don’t have to write them from scratch. zookeeper是一个高性能的分布式应用协调服务框架。它以简单接口形式实现了一系列的通用服务,比如** 命名、配置管理、同步、分组 **等，因此你不必从一堆草稿中去实现他们.</p>
</blockquote>
<h2 id="zookeeper的本质功能"><a href="#zookeeper的本质功能" class="headerlink" title="zookeeper的本质功能"></a>zookeeper的本质功能</h2><p>通过官方的定义介绍，我们知道了zk是一个server，擅长分布式协调功能。我们来分析下功能的本质实现是怎样的。 zk的数据模型是以znode的形式存储和组织。与标准文件系统类似，是一个树形结构，根节点是’&#x2F;‘。 <img src="http://zookeeper.apache.org/doc/current/images/zknamespace.jpg" alt="zk的znode结构"> 图中每个节点都是一个znode，类似于文件系统中的一个文件，形成了一个树形结构，每个znode内部还可以存储不超过1M的数据。这些znode可以是持久的，还可以是短期的（ephemeral ）。 短期的（ephemeral ）znode当创建他的客户端session超时，会被zk主动删除。有点类似给文件加锁，进程异常退出后，锁立刻解除。 zk的数据模型类似文件系统，这点也没什么特别的。本质还是kv形式，如果kv的value还要求是kv格式，那么就和zk的数据模型一样。表示成树形的格式，更容易表示层级关系。 zk的特别之处在于： 0. <strong>zk内部的选主和写数据机制。</strong>有超过一半的zk集群节点选出来的主节点，成为集群的leader节点，负责主写和同步其他丛属follower节点。底层用的ZAB（ZooKeeper Atomic Broadcast）协议。 1. <strong>短期的（ephemeral ）znode功能。</strong>方便实现锁类操作，在分布式中处理超时状态。 2. <strong>客户端可以设置监控watch某个znode的功能</strong>，当znode发生变化（版本号变更）时，会主动通知watch的客户端有变化了。该功能让客户端不必轮询，能够有序地知道znode变更顺序。 命名、配置管理、同步、分组等功能，都是通过1、2两点结合实现的。我们自研的业务如果想实现，也都能想到，或者用类似方式实现。 zk内部的选主和写数据机制。就不那么容易想了，只能依靠论文实现。所以这点更要好好学习下，这种方法很有特点，并且不容易想出来，也不容易理解。</p>
<h3 id="与已有自研业务的区别"><a href="#与已有自研业务的区别" class="headerlink" title="与已有自研业务的区别"></a>与已有自研业务的区别</h3><p>自研业务中，实现zk功能的，比较像的是配置中心（下文简称cc）。 一般实现cc，采用一主多从，主节点负责写，从节点只读。主节点通过binlog同步从节点，保证最终一致性。 主节点有两个写数据途径： 1、通过管理台的配置中心更新配置表； 2、通过客户端api上报服务状态，更新客户端节点负载和健康状况。 3、把心跳和变更回包作为一个协议，通知客户端配置更新。 如果从节点死机，不影响集群服务，对应的客户端寻找新的从节点去读。 如果主节点死机，cc只提供读服务，要人工来恢复。 影响：故障期间不能新增或修改配置以及配置项的负载。 如果用zk来实现cc，在正常情况下运行方式和cc是一样的。但是当主死机后，会用算法重新选出主，对客户端透明。<strong>让主节点死机停写的概率降低。但是如果有一半的节点死掉，会造成整个zk集群不可用。</strong> 对比：</p>
<p>自研cc</p>
<p>zk</p>
<p>选主方式</p>
<p>人工配置，主死了集群只读，人工介入恢复</p>
<p>集群协商选主，自恢复后继续服务</p>
<p>集群完全不可用条件</p>
<p>所有节点都死掉</p>
<p>一半节点死掉（可能有分区问题造成zk内部同步有问题，但是节点是可以服务的）</p>
<p>zk的选主方式，并没有完胜一主多从的所有场景。 1. 算法比较复杂，不容易理解和实现。 2. 某些重要任务，出现主写问题，为了一致性，要人工介入恢复，自动选新主切换会造成数据丢失。 3. 对于业务特定的场景特点，做一些弥补方案，能降低单点主写的风险。例如搭建多套cc，并行写，都对外提供服务，因为配置节点健康和负载的少量不一致，对业务来说是可以接受的。还可以在业务中增加缓存，保证主死了能够有足够的时间恢复。 以上自研业务没有引入ZAB或paxos协议的原因。在出现zk之后，想用的业务可以直接在zk之上构建集群内节点选主功能。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>我们在zk上构建服务的时候，要注意zk死一半节点就全集群死掉的特点。要考虑到<strong>如果zk集群不服务，业务有备选方案，能够对外尽力服务</strong>。例如zk充当配置中心，client要设置缓存，或默认配置。 为了节约资源，zk集群必须是奇数台机器。但是zk的机器数变多，对性能会有较大影响。写数据同步和选主都会变得越来越慢。 解决方法： 1. 读多写少：增加观察者节点来扩展读性能。观察者节点不参与主从节点的协商和选举，只负责同步主节点。 2. 读少写多：根据业务特点划分set，做到平行扩展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>zookeeper通过ZAB协议实现了集群内部选主和写同步功能，提高了服务的健壮性，和写操作的有序性。是实现的难点，背后有严密的数学理论推理。 通过实现，短期的（ephemeral ）znode和主动通知节点变更消息的功能，客户端能够及时知道监听节点变化，在客户端和zk断开连接后，也能够自动释放节点。轻松地实现锁类服务和监听更新类需求。这些是实现名字服务、配置管理、同步、分组等服务的基础。 <em>后面会再写介绍ZAB协议和zk典型应用场景用法的文章</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAzookeeper%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%8F%8A%E6%9C%AC%E8%B4%A8/" data-id="clyu70knn0062b0oo3ztod9l9" data-title="深入浅出zookeeper之一：功能及本质" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/教人怎样读书的书——《如何阅读一本书》" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E6%95%99%E4%BA%BA%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B9%A6%E2%80%94%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/" class="article-date">
  <time class="dt-published" datetime="2018-08-20T10:00:03.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E6%95%99%E4%BA%BA%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B9%A6%E2%80%94%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/">教人怎样读书的书——《如何阅读一本书》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>读书能够让人增长心智，提高认知，对一个个分散的问题找到解决方法。</p>
<p>在读书本身这件事上，也是有方法可循。</p>
<p>《如何阅读一本书》就是教人怎样读书的书。对于经常读书的人，可以学习下其中的方法，走一些捷径。</p>
<p>这本书的两个作者是<code>莫提默·J. 艾德勒</code>和<code>查尔斯·范多伦</code>他们是《大英百科全书》的编辑，在1940年就写出了这本书。虽然年代久远，但是对于读书来说，里面的方法是很实用的，一点都不过时。</p>
<h1 id="阅读的四个阶段"><a href="#阅读的四个阶段" class="headerlink" title="阅读的四个阶段"></a>阅读的四个阶段</h1><p>阅读分为四个阶段：基础阅读、检视阅读、分析阅读、主题阅读。由浅入深，每个阶段都包括前一阶段的全部内容，前一阶段是后一阶段的基础。</p>
<p>四个阶段不是要分成四个步骤，当你阅读技巧熟练时，可以在一次阅读中完成多个阶段。</p>
<h2 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h2><p>就像小学生识字，或读外国文献一样，把书中的文字和句子内容认识出来，读懂语义，是最初级的阅读。一般经过学校训练的学生，都具备这种能力。当读某种国外文字时，我们有时会退化到基础阅读，要逐字逐句地翻译理解句子的意思。</p>
<h2 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h2><p>阅读一本书时，要先对书的主题有所研究，不用一开始就详细地读书的每个细节。对书的内容主题有个大概的了解，让我们在一开始就先界定这本书是否有用，哪些地方是我们要重点读的有个界定。</p>
<ol>
<li>先看书名页，注意副标题，可以对书的主题有概念。将书分类。</li>
<li>研究目录页，对书的架构有概括性了解，目录是一本书的纲要，作者花费很多心思在目录的组织上，我们能够通过目录了解一本书的架构。</li>
<li>书的索引，书衣上的出版社介绍，都是概括书主要内容的重要线索。</li>
<li>略读书的内容，遇到难懂的内容也不要停下来，这步的主要目标是对书有个整体的把握。要快速的把书读完，哪些需要慢慢读的部分，留到后续的分析阅读中去读。</li>
</ol>
<p>看书名页、目录页、索引都是比较容易忽略的，但是里面对全书的架构有概括的描述，是最值得在初读一本书时重点看的。</p>
<p>检视阅读相当于略读，大体读懂书的内容即可，不懂的可以留到后面读，先对书有整体把握，知道书在讲什么，是什么类型的书，是否是自己需要读的书籍。</p>
<h2 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h2><p>分析阅读是详细地读一本书，发掘作者的观点，和论述的方法。对一本书的整体和细节都有详细的了解。能够描述出一本书的架构，每部分都是写的怎么，每个部分论述是怎么组织的。就是精读一本书。</p>
<p>在分析阅读时，最好不借助外力，自己一个人阅读，如果经常这么做，就越发现不用外界助理了。</p>
<p>当下各种书摘书评都很多，但是那是别人经过处理的，难免会有些丢失，如果总依赖这种，会在短时间内觉得知识丰富了，但是对于图书的一些精髓，和你阅读时能够受到的触发或感受，是得不到的，长远看对心智的成长是不利的。</p>
<p>在精读时要独立思考，评判性地读一本书，书中的观点是否正确，为什么正确，为什么错误，要有理有据。这样才能吃透一本书。</p>
<h2 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h2><p>主题阅读不局限于一本书了，而是要对一个问题，找一系列的书来论证该问题。要先找到相关的书，然后对这些书做过滤和筛选，找到这些书中对问题有关系的部分。抽取出对问题有帮助的内容。来解决这个主题的问题。</p>
<p>有点像大学写论文，要把相关文献都读一遍进行总体归纳。我们平时对一个技术问题进行研究时，也要翻阅大量的书籍，或通过搜索引擎读大量的网页，最终总结出知识点。</p>
<p>四个阅读阶段，和我们做系统架构也很类似。</p>
<ul>
<li><p>基础阅读——刚接触一个业务时，要会业务模块的语言，熟悉用的组件的功能，否则没办法接手一个业务。</p>
</li>
<li><p>检视阅读——对业务部署有大体的了解，熟悉架构图，知道每个模块间的调用关系。</p>
</li>
<li><p>分析阅读——对每个模块内部，每条协议，每个方法都详细了解，对这个业务抽丝剥茧，全部熟悉。</p>
</li>
<li><p>主题阅读——找和模块相关的主题，例如缓存怎么设计，消息系统怎么设计，把业内类似的系统都了解，总结出方法论，<br>对系统设计有整体思考和对比。</p>
</li>
</ul>
<h2 id="读书的态度"><a href="#读书的态度" class="headerlink" title="读书的态度"></a>读书的态度</h2><p><strong>读书要主动阅读，带着问题和目标去读，如果不喜欢，被动阅读，不如不读。</strong></p>
<p>主动阅读要能提出四个主要问题：</p>
<ol>
<li>这本书在谈什么？</li>
<li>作者细说了什么，怎么说的？</li>
<li>这本书说的有道理吗？是全部有道理，还是部分有道理？</li>
<li>这本书和你有什么关系？</li>
</ol>
<p>很多人读书是被动的，被人逼着读，或者听说某本书好就去读，不是自己真的感兴趣。这样的读是低效的，是浪费时间。要思考上面的四个问题，特别是最后一个问题，在每次要翻开一本书时，都想想，这本书到底和你有关系吗？</p>
<p>总阅读在能力范围之内的书，是没法提升阅读能力的。必须能操纵超越能力的书，阅读超越头脑的书，能够帮助思想成长。除非能增长心智，否则学不到东西。</p>
<p>好读者也是阅读要求高的，阅读时也是很主动的。</p>
<p>书中的方法论只是理论，要通过读其他的书，来练习读书的方法，才能提高心智，成为一个好的读者。</p>
<p><strong>读书要分主次，消遣或资讯类的不用详细读</strong>，甚至可以不读，这类书知识提高了读的量，但是并没有太多实质的东西，<br>只是让你知道了某些事情。特别现在的新闻app，都是些无用的新闻，但是却很“有趣”，把时间花在这些内容上，得不偿失。</p>
<p>即使是书籍，有用的，称得上精华的，也不足万分之一，要有独立思考和筛选的能力，读好书，多读书。</p>
<h2 id="为什么读书？"><a href="#为什么读书？" class="headerlink" title="为什么读书？"></a>为什么读书？</h2><p>读更多的书，才能更了解世界，更了解人类，提高我们的心智和认知，减少我们的困惑，真正的提升自己，而获取更好的生活。</p>
<p>一本好书能够叫你了解这个世界以及你自己。你不只是更懂得如何读的更好，还懂得生命。你变得更有智慧，<br>而不只是更有知识。你会成为一位智者，对人类生命中的永恒真理有更深刻的体认。</p>
<p>从读书、读好书、会读书开始，做个心智健全，对人类、世界更了解的人！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E6%95%99%E4%BA%BA%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E7%9A%84%E4%B9%A6%E2%80%94%E2%80%94%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B/" data-id="clyu70knl005wb0oo43ouhvjt" data-title="教人怎样读书的书——《如何阅读一本书》" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/了解一致性hash算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-08-07T14:01:23.000Z" itemprop="datePublished">2018-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">了解一致性hash算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一致性hash算法，在维基百科的定义是：</p>
<blockquote>
<p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p>
</blockquote>
<p>翻译过来的意思就是当hash表更新节点的数量时，只有k&#x2F;n的关键字位置有变化，其他关键字的位置映射关系不变。与其他的hash算法比，其他的算法节点个数n变化后，更多的key关键字和节点的映射会发生变化。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一致性hash主要用在路由中，对有状态的服务，根据key进行转发到对应的服务中。保证相同的key一直落到同一个服务器，当有服务节点增减时，只有少量(k&#x2F;n)的请求位置是变化的。减少重新建立缓存或存储的成本。</p>
<h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>前提：</p>
<ul>
<li>每个请求的key范围[0,2^32)，一共有k个key;</li>
<li>一共有N个节点，结点和服务器对应。</li>
</ul>
<h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><p>取key所映射的所有值最大空间（2^32）个，组成一个环，然后随机在这个环上落N个点，相邻的两个点形成一个左闭右开（关于左闭右开参考《聊聊左闭右开区间》)区间。共有N个区间。 对于每个key，一定只落在N个区间中的一个，它属于该区间所分配的节点。 当有服务节点增减时，会有区间新增或消失，平均只有k&#x2F;N个key会受影响，变更属于的节点。 如下图，在插入nodeC之前，2、3、8key都属于nodeA，当插入nodeC后2、3归属C，属于B的节点不会改变。 <img src="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7329-20240718185222474.png" class="" title="image common hash"></p>
<h4 id="改进：增加虚节点"><a href="#改进：增加虚节点" class="headerlink" title="改进：增加虚节点"></a>改进：增加虚节点</h4><p>常规实现在实际应用中会遇到问题。当N的数量太少时，会导致N个节点所管辖的区间并不均匀。 既然是N的数量太少，那增加N的数量不就行了?正解，可以成倍地增加N的数量，一个实际的节点扩充为100倍的虚节点，每个key先查找属于哪个虚节点，再查看该虚节点属于那个实节点。 由于众多虚节点的引入，使每个实节点被分配到的key数量的差距变少。 <img src="/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7335-20240718185218204.png" class="" title="image vnode common"> 从图中可见，增加了nodeA和nodeD的虚节点后，把区间分得更细小，会使分布更均匀。还可以通过设置权值，让不同处理能力的实节点，处理不同量级的key。</p>
<h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>通过上面的讲解，可以熟悉一致性hash的算法，但是在实际使用中，还是有很多需要注意的地方。</p>
<h4 id="如何加入虚节点"><a href="#如何加入虚节点" class="headerlink" title="如何加入虚节点"></a>如何加入虚节点</h4><p>加入虚节点能够解决分布不均的问题，但是如何加入也是有技巧的。如果完全随机，就是撞大运编程。要利用搜索算法，加入节点时要检测，保证每个实节点的区间不能差异太大。必要时要回溯，剪枝，或者用启发性搜索。</p>
<h4 id="节点配置同步"><a href="#节点配置同步" class="headerlink" title="节点配置同步"></a>节点配置同步</h4><p>一个大系统，每个真实节点有1000个虚节点，一共1000个实节点，有1M条目数据。每当更新节点信息时，要保证快速更换、传递更新数据，而且要有检查功能。节点配置的同步、检测也会有很多细节问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" data-id="clyu70knd004yb0oo58qa6z5s" data-title="了解一致性hash算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/三门问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2018-08-03T10:00:03.000Z" itemprop="datePublished">2018-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/">三门问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个游戏：有3扇关闭着的门，其中2扇门后面各有一只羊，另一扇门后面有一辆车。</span><br><span class="line">参与者：一个游戏者和一个主持人。主持人事先知道各扇门后的物品，而游戏者不知道。</span><br><span class="line">游戏目的：游戏者选择到车。</span><br><span class="line">游戏过程：1、游戏者随机选定一扇门；2、在不打开此扇门的情况下，主持人打开另一扇有羊的门。3、此时面对剩下2扇门，游戏者有一次更改上次选择的机会。</span><br><span class="line">问题：游戏者是否应该改变上次的选择，以使选到车的概率较大？</span><br></pre></td></tr></table></figure>

<p>问题的学名叫《蒙提霍尔问题》，<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/657835.htm#4">阅读原文</a>有来龙去脉。</p>
<p>答案有换和不换两种，有的认为是换概率是2&#x2F;3,有的认为是不换和换都一样，概率是50%，因为后面剩两个概率是相同的。</p>
<p>正确答案是应该换，几种解释：</p>
<ol>
<li>游戏者坚持每次都换，开始选中羊的概率是2&#x2F;3, 在第一次选中羊的情况下，换了就能够得到车，所以换能得到车的概率是2&#x2F;3。</li>
<li>假设有1000个门，只有一个后面有车，如果主持人帮游戏者打开选后的998个门，要不要换？当然换，排除了错误答案的情况，换的概率会高很多。</li>
</ol>
<p>除了思考的方式，还可以写个程序，用实验的方式验证。（在一些不容易想的问题上，可以用程序模拟多次独立事件，直观查看结果，但不一定和理论完全一样）</p>
<p>代码和结果如下，如果在主持人提示后换的话，也是2&#x2F;3的概率选中车。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define DOOR_COUNT 3</span><br><span class="line">int getrand( int max )</span><br><span class="line">&#123;</span><br><span class="line">    double max_rand = RAND_MAX * 1.0;</span><br><span class="line">    return (rand() /max_rand) * max;</span><br><span class="line">&#125;</span><br><span class="line">int choose( int changed )</span><br><span class="line">&#123;</span><br><span class="line">    char door[ DOOR_COUNT ] = &#123; 0 &#125;;</span><br><span class="line">    int moto_index = getrand( DOOR_COUNT );//车子所在的门序号</span><br><span class="line">    door[ moto_index ] = 1;</span><br><span class="line">    int choose_index = getrand( DOOR_COUNT );//游戏者第一次选的门序号</span><br><span class="line">    int left_index = -1;</span><br><span class="line">    int display_index = -1;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; DOOR_COUNT; i++) &#123;</span><br><span class="line">        if( i == choose_index  )</span><br><span class="line">            continue;</span><br><span class="line">        if( i == moto_index )</span><br><span class="line">            continue;</span><br><span class="line">        display_index = i;//主持人打开的门序号</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    for( i=0; i &lt; DOOR_COUNT; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        if( i == choose_index  )</span><br><span class="line">            continue;</span><br><span class="line">        if( i == display_index )</span><br><span class="line">            continue;</span><br><span class="line">        left_index = i;//最后没打开的门序号</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;moto_index = %d first_choose_index = %d display_index = %d left_index = %d\n&quot;,</span><br><span class="line">            moto_index, choose_index, display_index, left_index);</span><br><span class="line">    if( changed == 1)</span><br><span class="line">        choose_index = left_index;</span><br><span class="line">    if( choose_index == moto_index )</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    srand( ( unsigned  )time( NULL ) );</span><br><span class="line">    int count = 10000;</span><br><span class="line">    int changed = 1;//交换</span><br><span class="line">    int motocount = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        int iRet = choose( changed );</span><br><span class="line">        motocount += iRet;</span><br><span class="line">    &#125;</span><br><span class="line">    printf( &quot;changed = %d count = %d motocount = %d, rate = %0.2f\n&quot;,</span><br><span class="line">            changed, count, motocount, motocount*1.0/count);</span><br><span class="line">    system( &quot;pause&quot; );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">moto_index = 0 first_choose_index = 1 display_index = 2 left_index = 0</span><br><span class="line">moto_index = 2 first_choose_index = 2 display_index = 0 left_index = 1</span><br><span class="line">moto_index = 1 first_choose_index = 2 display_index = 0 left_index = 1</span><br><span class="line">......</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 1 first_choose_index = 0 display_index = 2 left_index = 1</span><br><span class="line">moto_index = 2 first_choose_index = 0 display_index = 1 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 1 display_index = 2 left_index = 0</span><br><span class="line">moto_index = 1 first_choose_index = 0 display_index = 2 left_index = 1</span><br><span class="line">moto_index = 0 first_choose_index = 2 display_index = 1 left_index = 0</span><br><span class="line">moto_index = 2 first_choose_index = 1 display_index = 0 left_index = 2</span><br><span class="line">moto_index = 0 first_choose_index = 2 display_index = 1 left_index = 0</span><br><span class="line">changed = 1 count = 10000 motocount = 6692, rate = 0.67</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/" data-id="clyu70knc004vb0oo4sx55769" data-title="三门问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/问题的分析与解决案例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%A1%88%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2018-07-24T10:00:03.000Z" itemprop="datePublished">2018-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%A1%88%E4%BE%8B/">问题的分析与解决案例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-外呼号码加拨0"><a href="#1-外呼号码加拨0" class="headerlink" title="1. 外呼号码加拨0"></a>1. 外呼号码加拨0</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>客户经理要给用户打电话，在系统界面上，只能看到用户的牛牛号。系统通过牛牛号查询电话号码，再用电话号码给用户拨打电话。</p>
<p>电信系统要求，对于深圳本地手机号，直接拨打，对于外地手机号，要加拨0，然后拨打。</p>
<p>程序用的是一个离线库，判断手机号是否为深圳本地号，如果不是，加拨0拨打。</p>
<p>由于离线库更新不及时，部分深圳新号码，被判断为外地号，导致客户经理给用户打不出电话，要找开发处理，开发把新号段增加到数据库后，客户经理再给用户拨打。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何解决客户经理遇到新号码要加拨0的问题？</p>
<h3 id="分析与解决"><a href="#分析与解决" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>方法一、 购买号码归属地判断服务，在24小时内更新，准确率99%以上，但是需要程序修改，需要花钱购买。也不确定服务是否真的如广告上说的那么好用。</p>
<p>方法二、 建立处理流程，出现需要加拨0时，客户经理给具体开发申请，提供牛牛号，开发保证在1小时内完成查询号码，把新号段加入数据库操作。</p>
<p>方法三、 当出现没有加拨0弹窗时，在窗口增加一个按钮“加拨0拨打”，用户主动要求要加拨0，程序后台变为不查归属地，直接加拨0拨打，如果发现拨打成功，那么自动记录号段日志，把号段加入外地号段数据库，并统计上报。</p>
<blockquote>
<p>以上为真事，方法一、二、三都是有人想过的，最终采用了方法三。解决了本质问题“让客户经理能够快速地拨通用户的电话”。这里要解决的问题是拨通电话，归属地判断只是一种实现的途径，不要花费很大精力解决旁路逻辑，而忽视主要问题。而且解决问题要看性价比，改动架构，增加成本，都是比较中的代价。</p>
</blockquote>
<h2 id="2-wifi签到"><a href="#2-wifi签到" class="headerlink" title="2. wifi签到"></a>2. wifi签到</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>公司采用企业微信签到，但是总有人会忘记签到，导致漏签。</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>如何能让大家不忘记签到？</p>
<h3 id="分析与解决-1"><a href="#分析与解决-1" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>大家到了公司，实际就满足了签到的条件。什么方式能监控到大家到公司了呢？</p>
<p>刷门禁：可以解决，但是会造成门口拥堵。</p>
<p>wifi连接：每个人的手机不会经常更换，根据收集mac地址，能够确定一个人，当他到公司时，手机会自动连接wifi，离开公司也会有断开wifi的日志。可以不用专门签到了。</p>
<h2 id="3-客服工作台的质量问题"><a href="#3-客服工作台的质量问题" class="headerlink" title="3. 客服工作台的质量问题"></a>3. 客服工作台的质量问题</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>收到反馈，客服工作台服务不稳定，希望能提高稳定性。</p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>怎样提高客服工作台的稳定性？</p>
<h3 id="分析与解决-2"><a href="#分析与解决-2" class="headerlink" title="分析与解决"></a>分析与解决</h3><p>1、找到真正的问题</p>
<p>为什么大家会觉得不稳定，要查看原因。</p>
<p>咨询反馈人：觉得客服群里的截图太多了，总有客服截图反馈问题。查看最近三个月的聊天记录，发现反馈的都是一些提示性的弹窗，客服看不懂，因为都是开发自己能看懂的错误码和英文提示。例如：没有权限，网络抖动也弹窗出来。</p>
<p>查看数据：从程序架构角度，查看视图和事故单，发现质量是稳定的，架构并没有问题。</p>
<p>真正的问题是：对客服的引导不够友好，如何提高引导性。</p>
<p>解决：<br>对问题分类：<br>1、有些弹窗可以不弹。<br>客服感知不到的，不影响操作的，不必弹窗，只要记录日志和告警就可以了。</p>
<p>例如：网络偶尔不通，只要客服没有操作，后面会自动恢复，在客服看来是没影响 的。给他们弹窗，最后也解释已经好了，没有用途的。可以参考其他软件，网络断开时，只要你不操作，后面再连上，都和什么事都没发生一样。</p>
<p>2、弹窗分类，错误和提示分开<br>区分错误码，哪些是提示性的，提示客服，用提示性弹窗。<br>哪些是错误类的，表明系统有错误，要及时同步开发。分类处理，提示明确，节约客服时间。</p>
<p>3、bug类<br>bug是难免的，建立快速的反馈和监控机制。重要属性设置告警，客服群反馈及时处理。每月总结客服群的反馈记录，总结解决方法，让问题收敛。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%A1%88%E4%BE%8B/" data-id="clyu70kns006kb0oohjtra3xc" data-title="问题的分析与解决案例" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2018/运营事故的处理及预防" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E9%A2%84%E9%98%B2/" class="article-date">
  <time class="dt-published" datetime="2018-07-08T14:39:29.000Z" itemprop="datePublished">2018-07-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E9%A2%84%E9%98%B2/">运营事故的处理及预防</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一流的人生，就是看着别人犯错误，自己不犯错误，吸取经验教训；</span><br><span class="line">二流的人生，是自己犯错误，自己吸取教训；</span><br><span class="line">三流的人生，是自己犯错误，自己还不吸取教训。</span><br></pre></td></tr></table></figure>

<p>互联网工程师，特别是后台工程师，经常遇到线上出问题，引起事故。事故有大有小，影响不一，有些能自动恢复，有些影响巨大刻骨铭心。今天就来聊聊运营事故的处理及预防。</p>
<h2 id="如何处理运营事故"><a href="#如何处理运营事故" class="headerlink" title="如何处理运营事故"></a>如何处理运营事故</h2><p>虽然发生运营事故是大家都不想看到的，但是真发生了，还是有处理的方法。</p>
<h3 id="1、第一时间同步给leader"><a href="#1、第一时间同步给leader" class="headerlink" title="1、第一时间同步给leader"></a>1、第一时间同步给leader</h3><p>为什么要同步给leader呢？自己弄好，谁也不说行吗？肯定不行，纸包不住火。同步给leader只有好处，没有坏处。 同步后，你可以专心处理事故，leader会帮你决策处理方法，通知相关人，评估事情的严重性，寻找经验更丰富的人等。因为leader一般经验丰富，能够快速定位问题，帮你出主意，做决策。如果影响相关团队，还能帮你协调外部资源。如果自己一个人处理，处理不好会事情越来越严重，影响越来越大。处理好了，也违反了流程。<strong>按照流程办，就不会出大问题。处理流程也是在众多流血的事故中总结出来的。</strong></p>
<h3 id="2、快速恢复"><a href="#2、快速恢复" class="headerlink" title="2、快速恢复"></a>2、快速恢复</h3><p>工程师都有个习惯，遇到问题喜欢弄明白，有学习精神。但是在发生事故时，第一时间想的应该是如何快速恢复，而不是讨论技术和学习。只要能快速恢复和降低事故影响的办法，都是可行的。就像在战士受伤时，衣服也可以撕开当纱布止血用，这时衣服和流血比，还是止血重要。 例如：有的事故是发布新特性导致主流程出了问题，那么即时回滚，比查问题更重要，先回滚恢复，再查为什么。不要让用户的体验一直在流血。</p>
<h3 id="不能快速恢复怎么办"><a href="#不能快速恢复怎么办" class="headerlink" title="不能快速恢复怎么办"></a>不能快速恢复怎么办</h3><h4 id="评估影响"><a href="#评估影响" class="headerlink" title="评估影响"></a>评估影响</h4><p>看下都哪些用户受影响，影响范围，和严重程度怎么样？如果恢复要多长时间，能恢复在什么程度？有没有替代的方案来处理，即使没有那么完美。</p>
<h4 id="安民告示"><a href="#安民告示" class="headerlink" title="安民告示"></a>安民告示</h4><p>通知相关人，整理话术，对外通知出了什么问题，多久会恢复。让外部有个准备，知道发生了什么事情，不会有人乱猜，而引起更严重的误会。</p>
<h4 id="壮士断臂"><a href="#壮士断臂" class="headerlink" title="壮士断臂"></a>壮士断臂</h4><p>有时要作出决策，要考虑柔性，舍弃一些正常的功能来保证主功能。<strong>决策要砍脖子，到底是手旁边的，还是脑袋旁边的脖子？</strong></p>
<h3 id="事后复盘"><a href="#事后复盘" class="headerlink" title="事后复盘"></a>事后复盘</h3><p>事故发生后，要进行详细的复盘，<strong>分析原因整改，要记录事故详细过程，事故的原因，造成的影响，改进措施和排期</strong>。</p>
<h2 id="如何预防事故"><a href="#如何预防事故" class="headerlink" title="如何预防事故"></a>如何预防事故</h2><h3 id="事故发生的原因"><a href="#事故发生的原因" class="headerlink" title="事故发生的原因"></a>事故发生的原因</h3><p>事故发生的原因有很多，<strong>本质都是一个“变更”</strong>。</p>
<h4 id="发布导致变更"><a href="#发布导致变更" class="headerlink" title="发布导致变更"></a>发布导致变更</h4><h4 id="用户行为变更"><a href="#用户行为变更" class="headerlink" title="用户行为变更"></a>用户行为变更</h4><p>来的用户多了，热点事件导致用户对某种操作变多了。引起系统过载等问题。一般还是容量管理没有做好，不能应对大流量。 要对容量有个评估，能应对多少请求，当用户行为变更时，能够及时扩容，或柔性可用。</p>
<h4 id="依赖变更导致"><a href="#依赖变更导致" class="headerlink" title="依赖变更导致"></a>依赖变更导致</h4><p>是另外一个系统变更所为，到底是自己的防御编程没做好，还是依赖方的程序没写到位？</p>
<h4 id="bug触发"><a href="#bug触发" class="headerlink" title="bug触发"></a>bug触发</h4><p>代码中写了“定时炸弹”，例如做系统初期分配的空间写的太小了，随着规模扩大，突破的分配。 有些代码没有用，却放到那里，阴差阳错又被调用了。 既然有这么多原因，如何预防呢？</p>
<h3 id="对变更要保有敬畏之心"><a href="#对变更要保有敬畏之心" class="headerlink" title="对变更要保有敬畏之心"></a>对变更要保有敬畏之心</h3><p>每一次代码变更，发布变更。都要谨慎，认真执行review和发布流程。要有柔性预案。要有防范事故的意识。例如：申请ip都是同一机房的，如果线路断了怎么办，机房停电呢？能不能备份了数据，能不能快速搭建一套新的服务，有没有备机？ 但是事故发生的原因多种多样，有防范意识很好，但是也难应对所有情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吾生也有涯，而知也无涯 。以有涯随无涯，殆已！</span><br></pre></td></tr></table></figure>

<p>为了不“殆已”，要抓住主要环节，最终的出口——<strong>监控</strong>。不管发生什么问题，都能即使发现，尽早预警。对SLA的指标监控。这是能够做到的。很多事故不是发生了处理不了，而是没发现。<strong>发现问题要比解决问题更难。</strong> 除此之外要能控制上限，例如发奖，总有个预算，万一多发了，也不至于把钱都发出去。给用户发短信，也不会一天发超过10条，如果超了就别发了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事故的减少，本质还是人的意识提高。 按照流程规范开发和运维，就不会出大问题。 不要两次被一块石头绊倒，从事故报告中吸取经验教训，减少事故。像圣斗士一样，不会被同一招打倒两次。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2018/%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85%E7%9A%84%E5%A4%84%E7%90%86%E5%8F%8A%E9%A2%84%E9%98%B2/" data-id="clyu70knr006ib0ooc3z06704" data-title="运营事故的处理及预防" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/7/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>