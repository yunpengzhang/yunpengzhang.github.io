<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owen的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/page/8/index.html">
<meta property="og:site_name" content="owen的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owen的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2017/jump Consistent hash介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/jump%20Consistent%20hash%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2017-10-24T10:00:03.000Z" itemprop="datePublished">2017-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/jump%20Consistent%20hash%E4%BB%8B%E7%BB%8D/">jump Consistent hash介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="jump-Consistent-hash"><a href="#jump-Consistent-hash" class="headerlink" title="jump Consistent hash"></a>jump Consistent hash</h3><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>是一个hash分配算法，在增加或减少hash桶个数时，是有1&#x2F;n的节点被移动到新桶内，其他key所在的桶序号不变。</p>
<p>要求桶是按顺序编号的，相对于web缓存，更适合存储的场景。</p>
<h2 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h2><p>用于分布式存储产品中，而不用在缓存类型的产品。因为有节点不可用时，jumphash用存活节点分担不可用节点的能力不强，会导致分布不均。但是在存储类中，节点都会有主备，主节点不可用路由到备节点，key的分布不会有变化。</p>
<p>适合在<strong>分布式系统中</strong>，根据key来选择被分配到的服务场景。每次新增新的服务节点，只有1&#x2F;n的key会变动，不会因为扩容或缩容瞬间<br>造成大部分缓存失效。</p>
<p>但是也有局限，和其他的一致性hash相比。如果有中间的桶失效，是不能够像割环hash一样，均匀分配到其他节点的，只能找个新替换<br>节点来取代。但是优点是不用存储，计算量也不大。代码短，易于实现。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>利用线性同余计算的固定性，每次输入参数固定，输出就固定的特性，来替代用存储。利用运算，减少存储空间。</p>
<p>由于运算量的优化，比查找存储空间速度更快，所以从时间、空间上算法更优。</p>
<p>引申：有时用运算生成的数字串，映射要存储的空间，会使算法有意想不到的效果。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="type">uint64_t</span> key, <span class="type">int32_t</span> num_buckets)</span> </span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        key = key * <span class="number">2862933555777941757ULL</span> + <span class="number">1</span>;</span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="built_in">double</span>(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>) / <span class="built_in">double</span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的全部代码，输入是64位的key，桶的数量（一般对应服务器的数量），输出是一个桶的编号（从0开始）。</p>
<p>jump consistent hash的设计目标是：</p>
<p>平衡性，把对象均匀地分布在所有桶中。</p>
<p>单调性，当桶的数量变化时，只需要把一些对象从旧桶移动到新桶，不需要做其它移动。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么上面的代码能够实现一致性hash的功能，我们一步一步来看。要实现的功能就是多加一个节点，节点数变为n，只有1&#x2F;n的key会变动。</p>
<p>我们先构造一个函数，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch(key, num_buckets) </span><br><span class="line"></span><br><span class="line">表示有num_buckets个桶，一个key的值会分配到的bucket编号[0, num_buckets)。</span><br></pre></td></tr></table></figure>

<p>所以对于任意key，k，ch(k,1)&#x3D;0,因为只有一个桶。为了让算法平衡，ch(k,2)讲有一半的key留在0号桶中，一半的移到1号桶中。</p>
<p>总结的规律是，ch(k,n+1)和ch(k,n)相比，n&#x2F;(n+1)的key是不动的，1&#x2F;(n+1)的key移动到第n号桶。</p>
<p>对于每次新增桶的个数时，计算每个key的新位置，确定是否要移动到新的桶中。</p>
<p>通过随机数生成器，来判定key是否要移动到新的桶中，概率是1&#x2F;(n+1)要移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">    random.seed(key) ;</span><br><span class="line">    int b = 0; // This will track ch(key, j +1) .</span><br><span class="line">    for (int j = 1; j &lt; num_buckets; j ++) &#123;</span><br><span class="line">        if (random.next() &lt; 1.0/(j+1) ) b = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代码中的random.next()产生[0,1)的随机数，随机数序列只和key有关，key为随机种子。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是满足算法的平衡性和单调性的，算法复杂度是O(N)。满足了正确性，接下来优化性能。</p>
<p>从算法代码可以看出，大多数情况下<code>random.next() &lt; 1.0/(j+1)</code>是不被执行的。</p>
<p>对于一个key来说，ch(key,j+1)的值，很少会随着j增长而变化的。当ch(key,j+1)!&#x3D;ch(key,j)时，<br>ch(key,j+1)&#x3D;j。</p>
<p>&#x2F;&#x2F;我们假设ch(key,j)是一个随机变量，通过伪随机数，来确定一个数值b，当j增长到b时，ch(key,b)!&#x3D;ch(key,b-1),<br>并且ch(key,j)&#x3D;ch(key,b-1)。</p>
<p>假设一个key的值为k，b为一个跳变的桶数量。则ch(k,b)!&#x3D;ch(k,b+1),并且ch(k,b+1)&#x3D;b.</p>
<p>下面寻找下一个比b大的跳变的桶数量j。则ch(k,j+1)！&#x3D;ch(k,j),ch(k,j)&#x3D;b,ch(k,j+1)&#x3D;j。<br>有</p>
<p>ch(k,b+1)&#x3D;b</p>
<p>ch(k,j)&#x3D;b,</p>
<p>ch(k,j)&#x3D;ch(k,b+1)</p>
<p>ch(k,j+1)&#x3D;j</p>
<p>ch(k,b)!&#x3D;ch(k,b+1)</p>
<p>ch(k,j+1)！&#x3D;ch(k,j)</p>
<p>所以，我们已知k，b时，要找到j，对于(b,j]区间的变量i，如果不发生跳变，必须满足<br>ch(k,i)&#x3D;ch(k,b+1)。</p>
<p>所以有概率</p>
<p>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先举几个例子P(ch(k,10)=ch(k,11))的概率是10/11,</span><br><span class="line"></span><br><span class="line">P(ch(k,11)=ch(k,12))的概率是11/12,</span><br><span class="line"></span><br><span class="line">所以P(ch(k,10)=ch(k,12))的概率是P(ch(k,10)=ch(k,11))*P(ch(k,11)=ch(k,12))=(10/11)*(11/12)=10/12</span><br><span class="line"></span><br><span class="line">对于任意的n&gt;=m,P(ch(k,n)=ch(k,m))=m/n。</span><br></pre></td></tr></table></figure>
<p>所以对于上面的等式，<br>P(j&gt;&#x3D;i) &#x3D; P(ch(k,i)&#x3D;ch(k,b+1))&#x3D;(b+1)&#x2F;i。</p>
<p>假设一个随机数r在(0,1)区间，由k和j确定。</p>
<p>如果r&lt;&#x3D;(b+1)&#x2F;i,那么P(j&gt;&#x3D;i)&#x3D;（b+1)&#x2F;i为不跳变。<br>那么产生随机数r后，就能确定i的最小值为(b+1)&#x2F;r。<br>因为r&lt;&#x3D;(b+1)&#x2F;i   &#x3D;&gt;    i&lt;&#x3D;(b+1)&#x2F;r.</p>
<p>又因为i是整数，所以有<br>r！&#x3D;0</p>
<p>i&#x3D;floor((b+1)&#x2F;r)</p>
<p>代码可改写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ch(int key, int num_buckets) &#123;</span><br><span class="line">	random.seed(key);</span><br><span class="line">	int b = -1; // bucket number before the previous jump</span><br><span class="line">	int j = 0; // bucket number before the current jump</span><br><span class="line">	while (j &lt; num_buckets) &#123;</span><br><span class="line">		b = j;</span><br><span class="line">		r = random.next();</span><br><span class="line">		j = floor((b + 1) / r);</span><br><span class="line">	&#125;</span><br><span class="line">	return = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设r的期望为0.5，时间复杂度为Olg(N)。<br>这个算法有点绕，通过随机数的产生来判定下一跳的j，优化算法，保证在整体key的跳变满足增加桶数为n+1时，只有1&#x2F;(n+1)的数据移动。</p>
<p>我们再看</p>
<p>key &#x3D; key * 2862933555777941757ULL + 1;<br>j &#x3D; (b + 1) * (double(1LL &lt;&lt; 31) &#x2F; double((key &gt;&gt; 33) + 1));</p>
<p>和<br>r &#x3D; random.next();<br>j &#x3D; floor((b + 1) &#x2F; r);</p>
<p>有什么关系。</p>
<p>利用线性同余算法产生一个64位的整数，然后通过映射到（0，1]区间的小数。</p>
<p>(key&gt;&gt;33)+1是取key值的高31位的值再加1，范围为(1,2^31+1)<br>1LL&lt;&lt;31的值为2^31。</p>
<p>所以<br>[(key&gt;&gt;33)+1]&#x2F;1LL&lt;&lt;31 的取值范围是(0,1],如果(key&gt;&gt;33)&#x3D;2^31那么会大于1，由于是c的整数运算，大于1也会取证忽略掉小数部分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该算法的精髓：通过随机种子产生随机数，减少存储；利用概率和随机数，确定key在bucket_num范围内落在的桶序号。</p>
<p>既减少了运算量，也易于实现，对于存储类路由非常适合，而且key的分散性不依赖key本身，只依赖随即生成器，对key的要求不高，不用做转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://blog.helong.info/blog/2015/03/13/jump_consistent_hash/</span><br><span class="line">https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/jump%20Consistent%20hash%E4%BB%8B%E7%BB%8D/" data-id="clyu6o6zx0047arq5259s2v08" data-title="jump Consistent hash介绍" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/[速成]了解一致性hash算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%5B%E9%80%9F%E6%88%90%5D%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2017-07-17T10:00:03.000Z" itemprop="datePublished">2017-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%5B%E9%80%9F%E6%88%90%5D%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">快速了解一致性hash算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一致性hash算法，在维基百科的定义是：</p>
<blockquote>
<p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where  K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p>
</blockquote>
<p>翻译过来的意思就是当hash表更新节点的数量时，只有k&#x2F;n的关键字位置有变化，其他关键字的位置映射关系不变。与其他的hash算法比，其他的算法节点个数n变化后，更多的key关键字和节点的映射会发生变化。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一致性hash主要用在路由中，对有状态的服务，根据key进行转发到对应的服务中。保证相同的key一直落到同一个服务器，当有服务节点增减时，只有少量(k&#x2F;n)的请求位置是变化的。减少重新建立缓存或存储的成本。</p>
<h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>前提：</p>
<ul>
<li>每个请求的key范围[0,2^32)，一共有k个key;</li>
<li>一共有N个节点，结点和服务器对应。</li>
</ul>
<h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><p>取key所映射的所有值最大空间（2^32）个，组成一个环，然后随机在这个环上落N个点，相邻的两个点形成一个左闭右开（关于左闭右开参考《聊聊左闭右开区间》)区间。共有N个区间。</p>
<p>对于每个key，一定只落在N个区间中的一个，它属于该区间所分配的节点。</p>
<p>当有服务节点增减时，会有区间新增或消失，平均只有k&#x2F;N个key会受影响，变更属于的节点。</p>
<p>如下图，在插入nodeC之前，2、3、8key都属于nodeA，当插入nodeC后2、3归属C，属于B的节点不会改变。</p>
<p>[</p>
<h4 id="改进：增加虚节点"><a href="#改进：增加虚节点" class="headerlink" title="改进：增加虚节点"></a>改进：增加虚节点</h4><p>常规实现在实际应用中会遇到问题。当N的数量太少时，会导致N个节点所管辖的区间并不均匀。</p>
<p>既然是N的数量太少，那增加N的数量不就行了?正解，可以成倍地增加N的数量，一个实际的节点扩充为100倍的虚节点，每个key先查找属于哪个虚节点，再查看该虚节点属于那个实节点。</p>
<p>由于众多虚节点的引入，使每个实节点被分配到的key数量的差距变少。</p>
<img src="/2017/%5B%E9%80%9F%E6%88%90%5D%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/7335-20240718184029676-1299231-1299232.png" class="" title="image vnode common">

<p>从图中可见，增加了nodeA和nodeD的虚节点后，把区间分得更细小，会使分布更均匀。还可以通过设置权值，让不同处理能力的实节点，处理不同量级的key。</p>
<h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>通过上面的讲解，可以熟悉一致性hash的算法，但是在实际使用中，还是有很多需要注意的地方。</p>
<h4 id="如何加入虚节点"><a href="#如何加入虚节点" class="headerlink" title="如何加入虚节点"></a>如何加入虚节点</h4><p>加入虚节点能够解决分布不均的问题，但是如何加入也是有技巧的。如果完全随机，就是撞大运编程。要利用搜索算法，加入节点时要检测，保证每个实节点的区间不能差异太大。必要时要回溯，剪枝，或者用启发性搜索。</p>
<h4 id="节点配置同步"><a href="#节点配置同步" class="headerlink" title="节点配置同步"></a>节点配置同步</h4><p>一个大系统，每个真实节点有1000个虚节点，一共1000个实节点，有1M条目数据。每当更新节点信息时，要保证快速更换、传递更新数据，而且要有检查功能。节点配置的同步、检测也会有很多细节问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/[%E9%80%9F%E6%88%90]%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" data-id="clyu6o6zw0045arq5drd4ai2w" data-title="快速了解一致性hash算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/【思考】一致性hash切分环的问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2017-07-17T10:00:03.000Z" itemprop="datePublished">2017-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/">【思考】一致性hash切分环的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在《了解一致性hash算法》中介绍了一致性hash ring的实现算法。</p>
<p>但是切割hash环的时候，遇到一个思考题：</p>
<blockquote>
<p>在数字环上随机落N个点，把环切分成N个区间，原点要算一个切分点吗？如果算，就只产生N-1个随机数就可以了，如果不算，要产生N个随机点。</p>
</blockquote>
<img src="/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/7545-20240718184048481.jpeg" class="" title="image">


<p>为什么会产生这个疑问？如上图，把hash用三个绿色点分割了三段。如果把环从蓝色的0点打开，变成右边的直线。直线被分成了四段。随机分割直线四段，肯定用右边的方法，为啥切割hash环就用左边的方法呢？</p>
<p>最终owen认为，还是要把0点当作一个已经切分过的node来处理，因为每次产生的随机数，都是按照右边展开的直线的空间来落点，分割直线的。环只是一个让人容易理解的模型，真正实现时还是按照一维来生成随机点的。否则，跨过0点的区间段，会是其他区间的二倍。</p>
<p>在工程实践中，为什么也没发生不均匀的问题，用的好好的呢？</p>
<p>有两个原因：</p>
<p>一、引入了虚节点，分割的区间太多，即使跨0点有两个区间段，也在程序接受的误差范围内。</p>
<p>二、由于是随机落点，分割的区间段大小不一，检测程序也会控制各实节点间的误差符合项目要求。</p>
<p>顺便说一下，把0点作为一个已切分的点还有个好处：不用特别考虑跨0区间key的归属情况，程序容易写。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把零点算作一个node，产生N-1个节点切分hash环；</p>
<p>实际切分的区间是否均匀，要靠检测程序来检查，不能只依赖理论推断。</p>
<hr>
<blockquote>
<p>在数字环上随机落N个点后，发现0点所在的区间长度，要比其他段长，是其他段的两倍。<br>随机落点的算法是：在环的区间范围[0,n)的区间随机产生N个整数，然后落点。</p>
</blockquote>
<p>该问题导致随机的N个点并不均衡，实际上0所在的服务器会有更大的负载。如果虚拟节点多过多，会掩盖这个问题，也不会造成太大的麻烦。</p>
<p>如何解决？</p>
<p>在0点也插入一个节点，分为N+1个区间，每个区间就都均衡了。</p>
<p>为什么？</p>
<p>把hash ring想象成为一条线段，在线段上随机落N-1个点，那么这N-1个点给线段分割为N段左闭右开的区间，本质上和hash ring的算法是一样的。如果落得点多，每段线段长度的期望相同，都是n&#x2F;N。在hash ring算法中，0所在的点被包含在了首位两个段中，所以期望是其他段的两倍。</p>
<p>如果以其他的点为起始点，以随机数偏移落点，和上面的情况类似，只是把圆按照偏移转了个相应的角度，不影响算法的结果。起始点所在的区间也是其他区间的二倍。</p>
<p>原因是和落点的随机算法有关，因为每次落点的随机数，都是以起始点开始，到终点结束的范围内产生随机数。在这个一维空间内产生随机点的均匀程度，是相对于起止点两点的范围产生，在0点和环上对应，相当于已经落了一次点。</p>
<p>以上只是由想法退出，并没有严格的推论，如果有人知晓，烦请指正。</p>
<p>附模拟程序和实验结果，在[0,1000000)的hash环上，随机落10,000个点，每次落点的位置都是[0,1000000)区间产生的随机整数所在点的坐标，分为10,000个段，平均每段长度100，执行100次，发现最大长度分布都在200左右，最小长度都在100左右。</p>
<p><a target="_blank" rel="noopener" href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/">http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</a></p>
<p>import random<br>from bisect import bisect_left</p>
<p>ITEMS &#x3D;  1000000<br>NODES &#x3D; 100<br>node_stat &#x3D; [0 for i in range(NODES)]</p>
<p>ring &#x3D; []<br>hash2node &#x3D; {}</p>
<p>for n in range(NODES):<br>    h &#x3D; random.randint(0, 10000)<br>    ring.append(h)<br>    hash2node[h] &#x3D; n</p>
<p>ring.sort()</p>
<p>print len(ring)</p>
<p>for item in range(ITEMS):<br>    h &#x3D; random.randint(0, 10000)<br>    n &#x3D; bisect_left(ring, h) % (NODES)<br>    node_stat[hash2node[ring[n]]] +&#x3D; 1</p>
<p>print sum(node_stat), node_stat, len(node_stat)</p>
<p>_ave &#x3D; ITEMS &#x2F; NODES<br>_max &#x3D; max(node_stat)<br>_min &#x3D; min(node_stat)</p>
<p>print(“node_stat[0]: %d” % node_stat[0])<br>print(“node_stat[-1]: %d” % node_stat[-1])<br>print(“Ave: %d” % _ave)<br>print(“Max: %d\t(%0.2f%%)” % (_max, (_max - _ave) * 100.0 &#x2F; _ave))<br>print(“Min: %d\t(%0.2f%%)” % (_min, (_ave - _min) * 100.0 &#x2F; _ave))</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/%E3%80%90%E6%80%9D%E8%80%83%E3%80%91%E4%B8%80%E8%87%B4%E6%80%A7hash%E5%88%87%E5%88%86%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="clyu6o6zx0049arq54a3ra7y3" data-title="【思考】一致性hash切分环的问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/聊聊左闭右开区间" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%E8%81%8A%E8%81%8A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4/" class="article-date">
  <time class="dt-published" datetime="2017-05-21T10:00:03.000Z" itemprop="datePublished">2017-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%E8%81%8A%E8%81%8A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4/">聊聊左闭右开区间</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>《编程珠玑》里说过：大约10%的专业程序员，才能够正确地写出二分查找。尽管第一个二分查找程序于1946年就公布了，但是第一个没有bug的程序在1962年才出现。</p>
</blockquote>
<p>二分查找易错的主要原因：缩小查找范围的区间切分不对。如果使用左闭右开区间划分，就很难出错了。</p>
<p>左闭右开区间在STL数据结构的构造参数，一些api的返回值范围等场景，也都广泛应用。仔细思考，是有些规律在里面的。</p>
<p>先来看三个使用的场景。</p>
<h3 id="一、javascript随机数返回值"><a href="#一、javascript随机数返回值" class="headerlink" title="一、javascript随机数返回值"></a>一、javascript随机数返回值</h3><p>在js中，产生随机数函数 <code>Math.random()</code> 返回值是<code>[0,1)</code>间的实数。</p>
<p>通过偏移和缩放返回值，能映射到任意实数区间。再通过取下界，随机产生任意整数，从而满足生成各种随机数的场景。</p>
<p>如果返回范围是全封闭，全开，或者左开右闭可以吗？<br>答案是不可以。</p>
<p><strong>全封闭</strong>：包含了上界的1，会造成产生整数的随机数概率不均匀。</p>
<p>例如要随机产生0-9十个整数，做法是<code>Math.floor(Math.random()*10)</code>,产生的数是均匀随机，满足需求。如果包含了上界的1，那么产生10是超出范围的。只有随机出1时才产生10，概率要比其他整数小很多，随机的概率就不均匀了。</p>
<p><strong>全开区间</strong>：没有了0点，映射生成整数的时候，产生0的概率要比其他整数的概率要低，生成的随机数概率不均。</p>
<p><strong>左开右闭</strong>：左开右闭和左闭右开是对称的，也可以。只是左闭右开更习惯些。</p>
<h3 id="二、迭代器遍历"><a href="#二、迭代器遍历" class="headerlink" title="二、迭代器遍历"></a>二、迭代器遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C语言中，数组的个数是count，遍历的循环下标的区间也是左闭右开[0,count)。因为数组是从0开始计数，所以不能包含上界。</p>
<p>A、要写为左右都是闭区间，[0,count-1]也是可以的。但是有个减一比较别扭。</p>
<p>B、有些迭代器，例如链表或数的子节点指针，就要设计个哨兵节点表示结束，判断结束时直接判断迭代器是否不等于end，不用右开区间，要判断next是否是null，会多出一些额外的判断，对一些边界要用特殊逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(iterator it=a.<span class="built_in">start</span>();it!=a.<span class="built_in">end</span>();++it)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、在算法和api中的左闭右开区间"><a href="#三、在算法和api中的左闭右开区间" class="headerlink" title="三、在算法和api中的左闭右开区间"></a>三、在算法和api中的左闭右开区间</h3><p>在C语言标准库的二分查找bsearch，快速排序qsort的函数里，无论是函数内部实现，还是参数，都传的左闭右开区间；</p>
<p>在STL容器的构造函数，算法操作，也都是左闭右开区间。</p>
<p>一方面是为了容易迭代，更通用。</p>
<p>另一方面是像二分、快排，都是分治算法，一个左闭右开区间<code>[x,y)</code>，子区间可以分解为<code>[x,y0),[y0,y1),[y1,y2)...[yn,y)</code>，父子同构，天然适合分治实现。</p>
<p>在整数范围内，如果非要写为左闭右闭区间，也是可以的。<code>[x,y]</code>分解的子区间为<code>[x,y0-1],[y0,y1-1],[y1,y2-1]...[yn,y]</code>。但是无论怎么分，总有一个区间和其他不同，划分偏左或偏右一个元素，划分是不<strong>整齐</strong>的。要打各种边界处理补丁来弥补。</p>
<p>在实数范围来进行计算，就用左闭右闭区间就不能实现了。</p>
<p>例如利用二分在单调递增的函数上逼近计算，每次都是分为[x,(x+y)&#x2F;2),和[(x+y)&#x2F;2,y)两个区间，如果左右封闭，要么进行一次重复判断计算，要么表示不出来。在实数范围内，给定一个实数x0，是给不出和他距离最小的x1的确切值的，更别说用计算机表示了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>左闭右开区间划分的子区间，也符合左闭右开的性质，划分前后同构；</p>
<p>按比例划分子区间后，映射到边界节点上的概率互成比例；</p>
<p>全闭区间要处理边界情况，边界点需特殊处理，对程序设计和算法理解造成障碍。</p>
<p>综上，<strong>在应用数字范围的场景中，抽象成左闭右开区间，是一个好方法。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/%E8%81%8A%E8%81%8A%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80%E5%8C%BA%E9%97%B4/" data-id="clyu6o6zz004farq51ni2frke" data-title="聊聊左闭右开区间" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2017/如何看待优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2017-02-19T10:00:03.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BC%98%E5%8C%96/">如何看待优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>腾讯曾经有句很经典的话——先抗住再优化。</p>
<p>优化和需求相比，永远都是排在第二位的，唯快不破，首先是要业务生存下来，然后才是如何稳定运营业务。</p>
<p>见到一些技术人员，包括刚工作是的自己，恨不得把架构代码打磨得无可挑剔，用当下最流行最“高效”的技术。而且还会说“要有技术追求；不能等到撑不住的时候再优化，那就来不及了……”</p>
<p>到底应该如何优化，什么时候优化，要遵守以下几个原则。</p>
<h2 id="先弄清极限容量，自己能撑多少"><a href="#先弄清极限容量，自己能撑多少" class="headerlink" title="先弄清极限容量，自己能撑多少"></a>先弄清极限容量，自己能撑多少</h2><p>先弄清楚现在系统的容量，什么地方是瓶颈，到多少访问量、用户的时候才会有问题。如果说目前用户1万，到100万时有问题，公司要5年后到达这个量级。那么可以停下了，先做其他需求去，在这五年内有好多事可以做。</p>
<p>如果马上就要撑不住了，那么就是最重要的问题了，要着手处理。优化的原则是不影响当下的体验，有时即使发现从前的地方有问题，也要先保证功能不变，完成优化后再进行修改。</p>
<p>有些人会以语言性能不行，换框架、或语言，说新的更优，速度更快。但是你的用户量到达拼最底层速度的时候了吗，是不是中间的逻辑没写好，真正的瓶颈在哪？你弄清楚了吗？</p>
<h2 id="突破业务瓶颈后，都有哪些地方要优化修改"><a href="#突破业务瓶颈后，都有哪些地方要优化修改" class="headerlink" title="突破业务瓶颈后，都有哪些地方要优化修改"></a>突破业务瓶颈后，都有哪些地方要优化修改</h2><p>先弄清容量后，要处理预案。万一哪天到达瓶颈，是不是扩充机器，或者用什么其他资源置换的方法，能够撑过去，保证业务稳定前行。然后用计划的优化方法慢慢处理。要先有预案，但不用马上执行，真到来的时候，按部就班就能够应对了。</p>
<h2 id="评估优化的方案，真的有所提升吗"><a href="#评估优化的方案，真的有所提升吗" class="headerlink" title="评估优化的方案，真的有所提升吗"></a>评估优化的方案，真的有所提升吗</h2><p>有些人说c比php快，要早换语言，能够让性能提升。这是“政治正确”的，但是有没有想过，真的用户量大了以后，代码的设计架构都要修改了，用c就能解决一切问题？</p>
<p>总之，是否优化要心里有数。在开发设计之处，就要考虑到扩展性，把一些不容易改变的（协议、架构）先确定，有些就是要牺牲和不同时间不一样的。一万用户时的投入量和百万用户时的投入量肯定是不一样的，很多过早优化都没有考虑全面，到后面还是避免不了优化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2017/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%BC%98%E5%8C%96/" data-id="clyu6o6zy004barq51hf8394f" data-title="如何看待优化" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2016/如何处理运营事故" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85/" class="article-date">
  <time class="dt-published" datetime="2016-12-06T10:00:03.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85/">如何处理运营事故</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>事故发生时的情景。</p>
<p>处理步骤：1.告知leader 2.恢复业务保留现场信息 3.复盘修复bug，继续发布验证</p>
<p>其他：验证方法，黑盒法，只看结果，用abtest，新老或异构两套对比；白盒法，在关键节点，异常部分加上报，统计，在程序围观层面查看。排查问题可以用二分法，排除法。</p>
<p>心态：要有颗强大包容的心，每一次事故都是对自己的一次提升，吃一堑长一智。<br>变被动为主动，主动发现，预防事故，积累经验，提高意识。</p>
<hr>
<blockquote>
<p>终于发布完成了，还没等休息，收到一堆告警短信，收件箱都快炸了；</p>
<p>刚发完特性不到一天，客服群里用户反馈，数据错了，多扣钱了；</p>
<p>半夜睡觉，突然被短信吵醒，业务崩溃了……</p>
</blockquote>
<p>以上这些场景，对于做过后台大系统的人来说，都应该有遇到过。每次线上事故都会让人刻骨铭心，都会扰乱你的日常。</p>
<p>事故是不可避免的，只要有人写的程序，就会有bug，就会酿成事故。遇到事故，我们应该怎么办呢？</p>
<h3 id="告知leader和相关人"><a href="#告知leader和相关人" class="headerlink" title="告知leader和相关人"></a>告知leader和相关人</h3><p>事故会影响业务，千万别想隐瞒，自己偷偷修改。遇到问题要先抛出来，把影响情况如实地告诉leader和相关人。然后就不是你一个人在战斗，会有人帮你想办法，check你修复的方法。帮助你尽快地度过危机。如果一个人捂着，默默地修改，会头脑不清醒，可能会一根筋。曾经就有人直接到数据库修复用户数据，没备份，结果都改乱了，越忙事情越多。如果事故影响很大，要通知公关，和更高层的leader。你的leader会帮你做这些事，帮你处理。让你专心处理线上问题。事故发生时一般人都是很紧张的，有些人改问题手都是抖得，想想几百万用户都登录不上，是多么可怕。尽快告知上级，会有经验更丰富的人帮你，挺你，所以这才是第一要做的。</p>
<h3 id="尽快恢复业务"><a href="#尽快恢复业务" class="headerlink" title="尽快恢复业务"></a>尽快恢复业务</h3><p>来不及了，快上车。事故来时如排山倒海，例如用户都登录不上，页面打不开，游戏掉线。查看是哪行代码导致意义不大。一般事故都是更改发布导致，变化导致问题。所以确定是发布问题，马上回滚，让业务恢复到正常水平。中间如果有操作，详细地记录下来，方便日后复盘。有些单机的日志，也要拷贝，防止时间长了日志被滚掉。</p>
<p>因为架构，或访问量突增导致的事故，马上扩容，恢复业务。真的到山穷水尽，不能马上恢复，发条微博，安民告示，告诉你的用户，你正在努力恢复中也好，一般都是由公关来发，开发给出评估的结论。</p>
<h3 id="用测试系统复盘，修复问题，重新起航"><a href="#用测试系统复盘，修复问题，重新起航" class="headerlink" title="用测试系统复盘，修复问题，重新起航"></a>用测试系统复盘，修复问题，重新起航</h3><p>线上的问题已经修复了，但是程序的bug还没找到。这时才是慢慢地找问题，仔细修复。在测试环境构造出问题的场景，修复后再验证，是否不再发生。经过详细的测试，没有问题，再次发布起航，把新特性发出去。</p>
<h3 id="总结事故，防微杜渐"><a href="#总结事故，防微杜渐" class="headerlink" title="总结事故，防微杜渐"></a>总结事故，防微杜渐</h3><p>人不应该被同一块石头绊倒两次，每次事故也是一次财富。认真总结，积累经验，认真总结，防止下次再犯。成本最低的是吸取别人的教训，以后哪些地方要测试，哪些地方要小心。每一次总结都是一次进步。不要因为事故被打到，增强心态，提高遇事不乱的能力。变被动为主动，主动发现，预防事故，积累经验，提高意识。</p>
<p>最后，祝大家都少发生事故，业务越来越稳定！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2016/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%90%E8%90%A5%E4%BA%8B%E6%95%85/" data-id="clyu6o6zv003zarq56n2v5w5q" data-title="如何处理运营事故" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2016/创业公司如何选择编程语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2016-12-02T10:00:03.000Z" itemprop="datePublished">2016-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">创业公司如何选择编程语言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>写作目的：说明如何选择编程语言，对不同语言的认识。</p>
<p>结构：</p>
<p>说明问题：语言太多，对于初创公司，选择是一个问题。</p>
<p>结论：看菜吃饭。根据公司的目标，能够快速出产品为主。当前团队对语言的熟悉程度，已有资源对语言的支撑；还要兼顾可维护性，招人的难度，以及语言的学习难度。</p>
<p>结构：</p>
<ol>
<li>大家的知识背景，用最熟悉的语言和工具，能够快速出产品。</li>
<li>根据语言特性，不同语言应对不同的使用场景。例如：php适合网页开发；C++适合计算密集型、游戏引擎等的开发；python有很多数据分析的库；nodejs也很适合前端转后端。</li>
<li>市场上招人的难度和成本，php很多,C++的很少。</li>
<li>已有的成熟组件的语言代码。例如有个现成的其他语言，是不是可以改改。例如csdn还是asp，LOL也有用java写的部分，有大多数游戏用的都是erlang语言，因为留出代码是这个。</li>
<li>语言只是工具，不要被语言所累，能实现目标最好，没有高低之分。语言的功能之间是等价的，没有什么做不了、能做的，都可以做，只是难度问题。用php支持http协议很简单，如果用c自己写，就难度很大了，也很难和其他工具结合。</li>
</ol>
<hr>
<p>公司初创时，产品定下来了，就差程序员开发了。这时候又出现了新问题，用哪种语言来开发，也需要一些时间来讨论。</p>
<p>有些人建议用新的语言，缺陷最少的；有些建议用大家最熟的，到底用新的还是老的呢？</p>
<p>要明白团队的目标是什么，从团队的目标出发。</p>
<p><strong>如果有现成的代码或方案改装，那么就用现成的。</strong>   能够快速出产品，缩短开发周期，减少bug率。例如已经有开源的产品，只是在上面精简修改些特性就能运行了，那么直接用。如果团队对里面的语言不熟，只能通过学习解决。要是真的hold不住，那么可以用灵活一点的方法，核心功能用外部代码，扩展功能可以分到其他周边模块，用团队擅长的语言处理。像一些游戏引擎，都是window下的代码，和团队linux下开发经验不匹配。可以把引擎游戏部分用外部引擎实现，尽量少改动。周边系统通过网络通信和引擎衔接，用团队最擅长的语言来实现。有听说为什么广州的erlang开发游戏的很多，是因为最早有一套游戏代码留出，就是erlang的。大家为快速搭建和使用，肯定直接用erlang啊。</p>
<p><strong>语言有不同的特性，在选择的时候也要慎重。</strong> 每种语言都有自己擅长的场景，有众多的库和工具链作为依存。php对web类开发很擅长，有众多的工具和库，甚至现成的解决方案，如果用c来写web处理，就比较捉襟见肘了。对于计算密集型的业务，动态语言天生有速度弱势，应该避免。还有unity，对C#支持要比js更好些，即使团队都会js，也还是尽量用C#吧，否则产品质量堪忧。</p>
<p><strong>人的成本也很重要，要思考招人的难度。</strong> 否则团队扩大到一定规模，必定受人才数量限制。在不同地域，不同语言掌握的人的数量也不一样。如果是小众语言，找人的难度会大很多，例如ruby或者go，还没有那么多的人会。要培养出一个厉害的程序员，也很难。所以团队打算扩大规模的，不得不考虑技术人员的数量和质量问题。</p>
<p><strong>语言只是工具</strong> ，有些程序员有语言清洁，或者洁癖。排斥自己不喜欢的语言。其实这东西就是个工具，类似用刀叉吃饭还是筷子吃饭。看你熟悉哪个，哪个效率高，用适合的东西办适合的事。我们的目的不是语言测评和比赛，而是用工具做出产品，造福人类:)</p>
<p>归根结底，看菜吃饭，根据公司的目标，能够快速稳定出产品为主。当前团队对语言的熟悉程度，已有资源对语言的支撑；还要兼顾可维护性，招人的难度，以及语言的学习难度，来选择开发语言，已解决最重要的问题为重！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2016/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" data-id="clyu6o6zu003xarq5a8rz106r" data-title="创业公司如何选择编程语言" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2016/python参数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/python%E5%8F%82%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2016-07-15T10:00:03.000Z" itemprop="datePublished">2016-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/python%E5%8F%82%E6%95%B0/">python参数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a = []</span>):</span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"> </span><br><span class="line">b = []</span><br><span class="line"> </span><br><span class="line">b = func()</span><br><span class="line"><span class="built_in">print</span> b</span><br><span class="line">b = []</span><br><span class="line">b = func()       </span><br><span class="line"><span class="built_in">print</span> b</span><br></pre></td></tr></table></figure>

<p>实际的打印结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 1]</span><br></pre></td></tr></table></figure>

<p>如果在C++ 里，两次打印的结果不应该有变化，而在python里，函数参数和变量赋值的规则和C++ 是不同的。</p>
<p>在C++中，每次调用函数时，参数是每次函数调用时在栈上重新生成赋值的，是把值放到变量所表示的地址里。</p>
<p>那么，在python中呢？python也是每次把值的地址赋值给变量，例如参数了的a&#x3D;[],里面的[]是一个对象，每次都是把这个对象的地址赋值给a，然后a实际操作的是[]，可以把[]想想为C++中的一个指针变量，每次都是把他赋值给a。同理，python中的每个变量都是表示一个唯一的对象，每次赋值都是把自身的地址传给另外一个变量。</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">a=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>1和2是两个对象，每次赋值是把a所指向的指针变了，1和2两个变量和存放的地址并没有改变。</p>
<p>再看一个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>]=a</span><br></pre></td></tr></table></figure>
<p>结果不是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[1,[1,2,3],3]</span><br></pre></td></tr></table></figure>
<p>而是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[1,[...],3]</span><br></pre></td></tr></table></figure>
<p>无限循环了，为什么呢？因为让a[2]的这个元素指向了a自身，形成了一个有环的链表。</p>
<p>如果要达到正常赋值怎么办呢？使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[2]=a[:]</span><br></pre></td></tr></table></figure>
<p><code>a[:]</code>重新生成了一个对象的拷贝，而不是原来的那个对象了。</p>
<p>为了好理解，可以参考链接</p>
<p><a target="_blank" rel="noopener" href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables">http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables</a></p>
<p>把C++的变量赋值想象为是把值放到变量的盒子里，而python的赋值是把变量不变，在上面挂一个标签，这样是否好理解呢？</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/">http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/</a></p>
<p><a target="_blank" rel="noopener" href="http://python-china.org/t/738">http://python-china.org/t/738</a></p>
<p><a target="_blank" rel="noopener" href="http://my.oschina.net/leejun2005/blog/145911#OSC_h3_1">http://my.oschina.net/leejun2005/blog/145911#OSC_h3_1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2016/python%E5%8F%82%E6%95%B0/" data-id="clyu6o6zt003varq5c0x34aar" data-title="python参数" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2014-01-31-i_think_not_all_think" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2014-01-31-i_think_not_all_think/" class="article-date">
  <time class="dt-published" datetime="2014-01-30T16:00:00.000Z" itemprop="datePublished">2014-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2014-01-31-i_think_not_all_think/">想要的总能找到</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在网上买东西，发现不管什么物品，在网站上都有好评和差评，而且有时评论的几乎都是一个特性。例如：同一款路由器，好评里说穿墙能力强，差评里说穿墙能力弱。<br>都振振有词，可能是不同的建筑，使用环境，或不同批次的货品的差异。但是发现个现象，最终还是心里想买哪款，最后就买哪款。寻找的过程只不过是增强下决心。因为<br>网络已经太大了，只要你心里有个想法，都能在网上找到相同的声音，而人也不自觉地过滤掉不同的声音，用相同的意见来巩固自己的观点。</p>
<p>买东西，主要看下产品属性，价格是否合适。查下是否有明显的缺点，剩下就follow your heart就可以了。</p>
<p>卖东西的，也有办法，只要能把产品的口碑做起来，加上宣传和竞品的差异，优势，还是会坚定买家的决心的。能把有力自己的都弄到百度的前几页，基本上就ok了。</p>
<p>还有机械键盘，网上有人说超级好用适合程序员写程序，有人说还是喜欢薄膜键盘，用xxx款觉得最好。最后，想买机械的人还是想买，不想买的最后也根据和自己想法相同<br>的观点来找了个不买的理由。这个很简单，自己体验下，从心里觉得到底是否好使。就像说牛肉是否好吃，有些人觉得好吃，但是有人天生爱吃素，都说得有道理。</p>
<p>好多东西还是要自己体验下比较好，听别人的都不准确。他觉得爽的不一定适合你。另外只有体验后，才能更有对比。苹果好还是安卓好，两种都用过，并且都用的程度<br>都很沉，才能写出区别。而且就这样，他用的场景和你用的也不一定相同。</p>
<p>春节期间，微信钱包推出，吸引了几百万张绑卡。有些人会觉得好厉害，我周围的人都在用。但是有的人觉得也没什么，我周围的人没人用。谁说的是真的呢，都是真的。<br>发红包抢红包的都是熟人之间，当然现实生活中也群分了。所以，如果要推出一款产品，不要你以为，你周围……要从客观的角度来看，很可能你被你周围的人给挡住了看不<br>清全世界。体会不到大环境的幸福和悲惨。</p>
<p>网络越来越发达了，每个个体的声音都能在网上公布并迅速检索到。你想要的想法，观点，在网上都能找到，你一定能找到你适合的群体。你的任何想法，能力，最终都会<br>变成一股力量，找到欣赏和能发挥的地方。如果把人的思维也当作一种商品的话，那么都能给他卖出去，总有个地方需要，虽然可能在大多数地方一文不值。</p>
<p>以后这种发现群体和提供自发组织平台的服务很重要，而从前那种bbs，圈定了喜好范围的产品，将会有一部分被分流走。新一代互联网，人和人之间自助寻找连接，形成<br>天然的去中心化的群体，从前定制发布和规范的产品的力量将被削弱，最后被取代。新的时代来了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2014-01-31-i_think_not_all_think/" data-id="clyu6o6zs003tarq57c2n88r9" data-title="想要的总能找到" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2013/2013-12-12-impression_of_a_sharing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2013/2013-12-12-impression_of_a_sharing/" class="article-date">
  <time class="dt-published" datetime="2013-12-11T16:00:00.000Z" itemprop="datePublished">2013-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2013/2013-12-12-impression_of_a_sharing/">一场分享中的感悟</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天听了一次分享，是某游戏公司的老板分享的。通篇内容幽默诙谐，主要是事迹介绍，扯淡居多。但是从中还是学到很多东西。</p>
<p>##浪潮之巅<br>在端游还不错时选择做页游，在页游不错时选择做手游，最后成功！其中做了一些断臂的事情，有时人越想得到的多，越会失去的多。<br>因为你的精力不集中，注定会错失机会。</p>
<p>要找到当今的风向和浪潮。不是你擅长什么去做什么，而是时代需要什么去做什么，要做对的事，而不是会的时。都已经过时的东西就不要再耗精力<br>往里面去了，就像浪潮之巅里写的一样，要认准大势，逆流而上的最终结果都很悲惨。</p>
<p>有时以为自己很牛逼，什么都能干成，但是光有信心还是不够的，更多的还是要认清形式，顺势而上。也不是什么火就去做什么。一旦行业已经被巨头<br>所察觉，形成了几分天下之势，想再得到资源就难了。还是要先评估下，走弥补空白的路线，而不是和强大的对手去硬搏。</p>
<p>只有新奇的东西，有创新的东西，vc才会投钱，否则出于自己兴趣，还是用自己的钱来创业吧。<br>##情商!情商！情商！！！</p>
<p>发现改大牛虽然将话风格普通，也没什么妙语连珠，但是让人很爱听。一方面是内容有聊，还有就是情商很高。懂得调动场下情绪，及时互动，就像聊天一样。<br>不禁感慨很多人还是需要练习啊，虽然有的人一辈子也好不了了。但是能忍受住情商低的人的种种低水平行为，也是一种修行和提高。总不能狗朝你叫两声，你就<br>朝他叫两声吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2013/2013-12-12-impression_of_a_sharing/" data-id="clyu6o6zs003rarq50ckj59t2" data-title="一场分享中的感悟" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>