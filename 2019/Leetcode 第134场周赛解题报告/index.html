<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Leetcode 第134场周赛解题报告 | owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。 第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。 通过第四题发散想一下，还是能够发现很多有意思的结论，在题解中会详细分析。 思考到最后，甚至想到了极限，量变引起质变。烧脑，头疼，感觉数学知识好匮乏，我要去学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode 第134场周赛解题报告">
<meta property="og:url" content="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:description" content="因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。 第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。 通过第四题发散想一下，还是能够发现很多有意思的结论，在题解中会详细分析。 思考到最后，甚至想到了极限，量变引起质变。烧脑，头疼，感觉数学知识好匮乏，我要去学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.owenzhang.net/blog/wp-content/uploads/2019/04/a6bacec19fccfc0d0c64facc89919cd4.png">
<meta property="article:published_time" content="2019-04-21T10:00:03.000Z">
<meta property="article:modified_time" content="2024-07-20T13:56:42.419Z">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.owenzhang.net/blog/wp-content/uploads/2019/04/a6bacec19fccfc0d0c64facc89919cd4.png">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2019/Leetcode 第134场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Leetcode 第134场周赛解题报告
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>因为上周日上班，这场比赛没有参加。赛后做了下比赛的题目，前三道题比较常规，第四道题有点特殊，要利用题目给的提示。</p>
<p>第三题在后来思考时，感觉有点「眼熟」，原来是最长公共子序列的变种。学习知识要触类旁通，多思考。很多问题的本质底层都是一个模型。</p>
<p>通过第四题发散想一下，还是能够发现很多有意思的结论，在题解中会详细分析。</p>
<p>思考到最后，甚至想到了极限，量变引起质变。烧脑，头疼，感觉数学知识好匮乏，我要去学习了。</p>
<p>下面是详细的题解和思考。</p>
<hr>
<p>今天比赛的地址 Weekly Contest 134</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134">https://leetcode-cn.com/contest/weekly-contest-134</a></p>
<h2 id="1-动石子直到连续"><a href="#1-动石子直到连续" class="headerlink" title="1. 动石子直到连续"></a>1. 动石子直到连续</h2><p>题目：移动石子直到连续(Moving Stones Until Consecutive)</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/">https://leetcode-cn.com/contest/weekly-contest-134/problems/moving-stones-until-consecutive/</a></p>
<p>题意：</p>
<blockquote>
<p>三枚石子放置在数轴上，所在位置必须是整数。位置分别为 a，b，c。<br>每一回合，假设三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z &gt; 且 k !&#x3D; y。<br>当这些石子的位置连续时，游戏结束。</p>
<p>要使游戏结束，可以执行的最小和最大移动次数分别是多少？</p>
</blockquote>
<p>思路：<br>每次只能移动最左侧，或者最右侧的石子往中间移动。所以z-x的值是逐渐收敛的。</p>
<p>最大次数就是一步一步往中间挪，所需的步数是z-x-2。因为z和x之间能移动的空间是z-x-1，还要去掉一个y占的位置，所以最终移动的最多步数是<code>z-x-2</code>。</p>
<p>最小步数呢？</p>
<p>最小值为0：如果x,y,z三个值本身就挨着，那么不用移动就游戏结束了。</p>
<p>最小值为1：如果x和y之间只有一个位置，那么z移动到这个空位，只移动1次也就结束了。</p>
<p>最小值为2：除了上面两种情况，每次都把x移动到y-1或把z移动到y+1，那么只要两步就结束了。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; numMovesStones(int a, int b, int c) &#123;</span><br><span class="line">        if(a&gt;b)</span><br><span class="line">            swap(a,b);</span><br><span class="line">        if(a&gt;c)</span><br><span class="line">            swap(a,c);</span><br><span class="line">        if(b&gt;c)</span><br><span class="line">            swap(b,c);</span><br><span class="line">        int mx = c-b-1+b-a-1;</span><br><span class="line">        int mi = 0;</span><br><span class="line">        if(abs(c-b)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(abs(b-a)==1)</span><br><span class="line">            mi+=0;</span><br><span class="line">        else</span><br><span class="line">            mi+=1;</span><br><span class="line">        if(b-a==2||c-b==2)</span><br><span class="line">            mi=1;</span><br><span class="line">        return vector&lt;int&gt;&#123;mi,mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-边框着色"><a href="#2-边框着色" class="headerlink" title="2. 边框着色"></a>2. 边框着色</h2><p>题目：边框着色（Coloring A Border）</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/">https://leetcode-cn.com/contest/weekly-contest-134/problems/coloring-a-border/</a></p>
<p>题意：给一个二维网格，网格被分成几种区域，每个区域都被涂上了不同的颜色。然后给定一个点（x,y）和一种颜色值c。要求把这个点所在的区域边缘涂上颜色c,最后返回新的网格图。</p>
<p>思路：</p>
<p>先根据点找到整个区域的点的集合，然后判断哪些点是边缘，如果是边缘，给边缘涂色。</p>
<p>找到区域点集合可以用深度优先搜索或广度优先搜索。判定边缘，就看和二位网格的边界是否相连，还有是否上下左右有其他颜色。</p>
<p>为了方便判断，减少干扰。可以再建两个网格，一个网格标识哪些点被搜索过，一个网格标识最终涂色的网格。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int m,n;</span><br><span class="line">    bool isEdge(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; grid, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)</span><br><span class="line">                return true;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]!=ocolor)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; visited,vector&lt;vector&lt;int&gt;&gt;&amp; res, int i, int j, int pcolor, int ocolor)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isEdge(i,j,grid,ocolor))</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j]=pcolor;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j]=1;</span><br><span class="line">        int dx[4]=&#123;0,0,-1,1&#125;;</span><br><span class="line">        int dy[4]=&#123;-1,1,0,0&#125;;</span><br><span class="line">        for(int k=0; k&lt;4; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = dx[k]+i;</span><br><span class="line">            int y = dy[k]+j;</span><br><span class="line">            if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                if(grid[x][y]==ocolor&amp;&amp;!visited[x][y])</span><br><span class="line">                    dfs(grid,visited,res,x,y,pcolor,ocolor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123;</span><br><span class="line">        m=grid.size();</span><br><span class="line">        n=grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(m,vector&lt;int&gt;(n,0));</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(grid);</span><br><span class="line">        dfs(grid,visited,res,r0,c0,color,grid[r0][c0]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-不相交的线"><a href="#3-不相交的线" class="headerlink" title="3. 不相交的线"></a>3. 不相交的线</h2><p>题目：不相交的线（Uncrossed Lines）</p>
<p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/">https://leetcode-cn.com/contest/weekly-contest-134/problems/uncrossed-lines/</a></p>
<p>题意：</p>
<blockquote>
<p>在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
</blockquote>
<p>思路：</p>
<p>我们设函数f(x,y)标识A的前x个数字和B的前y个数字，能绘制出的最大连接数。假设A、B都是从下标1开始。</p>
<p>则f(0,y)&#x3D;0,f(x,0)&#x3D;0;</p>
<p>情况1：</p>
<p>如果<code>A[x]!=B[y]</code>，那么<code>f(x,y)=max(f(x-1,y),f(x,y-1))</code>;</p>
<p>情况2：</p>
<p>如果<code>A[x]==B[y]</code>，那么<code>f(x,y)=f(x-1,y-1)+1</code>;</p>
<p>可以看出，是一个标准的递推公式，利用两层循环就能得出答案，最后求<code>f(A.size(),B.size())</code>就是答案。</p>
<p>公式的推导如下：</p>
<p>如果两个长度为0的整数串连线，最大值肯定为0。</p>
<p>如果出现情况1，在合法的解答中，不可能出现A[x],B[y]都参与连线的情况。如果他们两个点都被别的点连线了，那么一定会出现直线相交。因为与B[y]连线的点一定小于A[x]，与A[x]连线的点的位置也一定小于B[y]。</p>
<p>如果出现情况2, 那么一定A[x]和B[y]连是最优解，其他没有比这个情况更大的解。否则A[x]和B[y]一定只有一个点参与连线（看情况1中的说明，否则会有相交）。</p>
<p>例如只有B[y]参与了连接，连了A[z]，那么A[z]一定小于A[x]，所以f(z,y)&#x3D;f(x,y)，和A[x]连B[y]的情况值一样。所以把这两个点去除得到f(x-1,y-1)再加上这两个点连上的情况，就是f(x,y)的值了。</p>
<p>看这个公式也有点眼熟原来是最长公共子序列（Longest Common Subsequences)。就是求两个字符串公共子序列的长度。例如<strong>A</strong>B<strong>C</strong>E<strong>D</strong>和<strong>A</strong>XY<strong>CD</strong>的最长公共子序列就是ACD，和上面的递推是一样的。因为子序列能够保证他们的连线不相交。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">        int m=A.size();</span><br><span class="line">        int n=B.size();</span><br><span class="line">        int v[501][501]=&#123;0&#125;;</span><br><span class="line">        for(int i=1;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(A[i-1]==B[j-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    v[i][j]=v[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v[i][j]=max(v[i-1][j],v[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-逃离大迷宫"><a href="#4-逃离大迷宫" class="headerlink" title="4. 逃离大迷宫"></a>4. 逃离大迷宫</h2><p>题号：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/">https://leetcode-cn.com/contest/weekly-contest-134/problems/escape-a-large-maze/</a></p>
<p>题目：逃离大迷宫（Escape a Large Maze）</p>
<p>题意：<br>在一个10^6 乘 10^6的二维网格上，标识两个点S和T，还有最多200个障碍点。问S和T是否连通。<br>连通的定义为，从S出发，只通过上下左右移动，且障碍点是不能移动到的，最终能够移动到T。</p>
<p>思路：<br>如果网格很小比较简单，就和第二题一样，通过深搜或广搜，看是否能到达终点T即可。但是网格空间太大了。直接搜肯定超时。</p>
<p>可以从最多200个点来思考。到不了的情况就是S或T被这200个点给围住了。只要能判断是否被围住就可以了。</p>
<p>原题200个点是在最下面数据范围里写的，很隐藏，很难注意到。</p>
<p><strong>怎么判断S或T被障碍点围住呢？</strong> </p>
<p>找到200个点能够围住的最大范围包括的点数Total，从S广搜，如果已经搜到Total个空白点，还有路可走，那么这200个点肯定包围不了S点。</p>
<p>同理再判断下是否有包围住T点，两个都没被包围，则一定能走到。</p>
<p>当然，也可能两个点都被包围了，那么在搜的时候判断能直达，直接返回true就可以了。</p>
<p>200个点能够包围的最大空白部分是多少？答案是19900&#x3D;(200-1)*200&#x2F;2。</p>
<p>为什么是这个值呢？<br>如果要200个障碍点得到充分利用，包围最多的范围，那么一定要借助网格自身的边界。</p>
<p>如果是直线，相同周长，面积最大的是圆，所以围成个1&#x2F;4圆可能是答案。但是网格上的点是离散的，围成个三角形，200个点做斜边，是围成区域最大的。为什么不是圆呢，因为两个正方形，只有斜着连接，在二维表围的面积才最大。如图</p>
<p><img src="https://www.owenzhang.net/blog/wp-content/uploads/2019/04/a6bacec19fccfc0d0c64facc89919cd4.png"></p>
<p>如上图，最开始是黄色的布局障碍。此时有1、3、5三个点是在统一垂直方向，这时让1移动到2会更好，多围一个点，把3移动到4也会多一个点。同理5-&gt;6,4-&gt;7,2-&gt;8最终形成一个斜线，达到蓝色部分。就能围住的点最多了。那点有多少个呢？设斜边的长度为n个方块。则围住的总面积块数等于1+2+3+…+n-n&#x3D;n*(n-1)&#x2F;2。</p>
<p>有两个问题：</p>
<p><strong>1. 为什么连续区间周长最大的是圆，而在二位方块中最大的是三角形？</strong></p>
<p>因为对于每个小方块，能够贡献的长度只有自己的边长和内部的斜对角线长度，没有圆的弧线。这样斜对角线就是获取最长长度的最优解。</p>
<p><strong>2. 一个3×3方块围成的图形，面积是9，周长是12。但是周长上的边的方块一共有多少个？</strong></p>
<p>这个问题的第一反应是3×3&#x3D;9，但实际围成外围的方块数是2×4&#x3D;8。就像题目中说的200个点，如果围个正方形，那么肯定不是边长为50的，而是51。因为四个角的方块是两个边公用的，如果在连续空间中，只是一个点，但是在离散中，这个点就是个面积了。</p>
<p>上面说的这些有什么用呢？</p>
<p>生活中，家里铺地砖，不理解会算错。</p>
<p>工作中，做计算机图形展示程序，或者做显示器上的运算，都是离散像素点，理解好会有有助于实现。</p>
<p>又衍生了几个问题需要研究：</p>
<p>现实世界中有绝对的圆吗?世界是离散的还是连续的?微分到一定的量就出现了无理数π。这个值是怎么得出来的，他和自然有什么关系，在宇宙中是什么存在？有没有的时空，或者什么情况下又出现新的无理数替代掉π？？？</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map&lt;int,unordered_map&lt;int, int&gt;&gt; position;</span><br><span class="line">    const int kBlock = 1;</span><br><span class="line">    const int kSource = 2;</span><br><span class="line">    const int kTarget = 3;</span><br><span class="line">    const int kMaxPosNum = (1+200)*200/2-200;</span><br><span class="line">    int R=1e6;</span><br><span class="line">    int C=1e6;</span><br><span class="line">    bool bfs(int sx, int sy, int sourceFlag, int targetFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;sx,sy&#125;);</span><br><span class="line">        int total = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int i = p.first;</span><br><span class="line">            int j = p.second;</span><br><span class="line">            if(position[i][j]==targetFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            total++;</span><br><span class="line">            if(total&gt;kMaxPosNum)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            int dx[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">            int dy[]=&#123;0,0,-1,1&#125;;</span><br><span class="line">            for(int k=0;k&lt;4;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = dx[k]+i;</span><br><span class="line">                int y = dy[k]+j;</span><br><span class="line">                if(x&gt;=0&amp;&amp;x&lt;R&amp;&amp;y&gt;=0&amp;&amp;y&lt;C&amp;&amp;position[x][y]!=sourceFlag&amp;&amp;position[x][y]!=kBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    position[x][y] = sourceFlag;</span><br><span class="line">                    q.push(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) &#123;</span><br><span class="line">        for(int i=0;i&lt;blocked.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            position[blocked[i][0]][blocked[i][1]]=kBlock;</span><br><span class="line">        &#125;</span><br><span class="line">        position[source[0]][source[1]]=kSource;</span><br><span class="line">        position[target[0]][target[1]]=kTarget;</span><br><span class="line">        return bfs(source[0], source[1], kSource, kTarget)</span><br><span class="line">            &amp;&amp; bfs(target[0], target[1], kTarget, kSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC134%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knv006sb0oobettbt7d" data-title="Leetcode 第134场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Leetcode 第133场周赛解题报告
        
      </div>
    </a>
  
  
    <a href="/2019/Leetcode%20%E7%AC%AC135%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Leetcode 第135场周赛解题报告</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>