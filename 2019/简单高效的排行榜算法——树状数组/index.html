<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>简单高效的排行榜算法——树状数组 | owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="0 问题场景在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：新的分数排行是多少名，相比之前是前进了，还是后退了，具体前进后退的数值是多少。例如充值排行榜，游戏分排行榜，活跃度排行榜等。由于互联网用户基数大，有些平台参与排行的用户可以达到上千万。但是排行榜最重要的就是时效性，能够让用户越早看到排行更新越好。 对于庞大的榜单，每次其中一个元素">
<meta property="og:type" content="article">
<meta property="og:title" content="简单高效的排行榜算法——树状数组">
<meta property="og:url" content="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:description" content="0 问题场景在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：新的分数排行是多少名，相比之前是前进了，还是后退了，具体前进后退的数值是多少。例如充值排行榜，游戏分排行榜，活跃度排行榜等。由于互联网用户基数大，有些平台参与排行的用户可以达到上千万。但是排行榜最重要的就是时效性，能够让用户越早看到排行更新越好。 对于庞大的榜单，每次其中一个元素">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640.png">
<meta property="og:image" content="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640-20240720163708514.png">
<meta property="article:published_time" content="2019-10-09T10:00:03.000Z">
<meta property="article:modified_time" content="2024-07-20T13:56:42.423Z">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640.png">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2019/简单高效的排行榜算法——树状数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T10:00:03.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      简单高效的排行榜算法——树状数组
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="0-问题场景"><a href="#0-问题场景" class="headerlink" title="0 问题场景"></a>0 问题场景</h2><p>在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：新的分数排行是多少名，相比之前是前进了，还是后退了，具体前进后退的数值是多少。例如充值排行榜，游戏分排行榜，活跃度排行榜等。由于互联网用户基数大，有些平台参与排行的用户可以达到上千万。但是排行榜最重要的就是时效性，能够让用户越早看到排行更新越好。</p>
<p>对于庞大的榜单，每次其中一个元素更新，都要重新排序，即使用快速排序，对CPU运算的消耗都是巨大的，很容易造成卡顿。很多互联网业务都采用离线定时更新榜单的方案。例如每天凌晨4点的数据切片，离线排序更新，更新后展示最新的榜单。这种方案在程序性能和用户体验间做了折衷，既保证了每天更新，又不至于实时更新导致运算量太大，算不出来。</p>
<p>有没有更高的解决方案，可以实时查看用户排行变化呢？一个有序的排行榜，只是一个用户的数据发生变化，就要所有数据重新排序，能只做到部分排序吗？</p>
<p>对于这两个问题，可以利用一种高级的数据结构「树状数组」，再结合对排行榜的算法来实现。</p>
<h2 id="1-排行榜实现及优化方案"><a href="#1-排行榜实现及优化方案" class="headerlink" title="1 排行榜实现及优化方案"></a>1 排行榜实现及优化方案</h2><p>我们先梳理下排行榜的通用实现方案，再查看下针对具体的步骤进行优化。<br>一个通用排行榜的实现方案步骤如下：</p>
<ol start="0">
<li>已经有一个排好序的排行榜；</li>
<li>当用户分数有更新时，保存用户老的排行榜名次和老的分数；</li>
<li>更新用户新的分数，并更新排行榜，获取新排行名次；</li>
<li>展示新老名次的差异，结束。</li>
</ol>
<p>难点就在第二点，如何更新排行榜。最简单粗暴的想法是，更新排行榜中对应的分数，然后调用快速排序对数组再重新排序一次。快速排序时间复杂度是nlog(n)的，如果有1000万人参与，每次就要进行上亿次的比较。如果每秒有一千个玩家修改分数，要执行千亿次运算。对于排行榜系统的性能消耗是巨大的，做不到实时展示排行数据更新。</p>
<p>原先已经排好序的数组，只有一个元素的值发生了变化，其他元素的相对顺序是不用更改的。从这个角度来优化程序，能够做到快速实现排序优化。使用树状数组，能够做到修改和查询都是log(n),那么对于1000万人参与的榜单，比较次数最多只需要23次，一千个玩家每秒修改，只需要23000次比较。单进程都可以承受住。而且树状数组底层是构建在数组之上的，数据结构简单，容易持久化，能够方便地保存在共享内存中。当常驻进程重启时能够快速恢复。</p>
<p>说了树状数组这么多好处，这么适合排行榜业务的实现，下面我们来介绍下树状数组的原理，以及在排行榜业务中使用的方法。</p>
<h2 id="2-树状数组实现排行榜"><a href="#2-树状数组实现排行榜" class="headerlink" title="2 树状数组实现排行榜"></a>2 树状数组实现排行榜</h2><p>我们利用树状数组来实现排行榜功能，能够在Olog(N)的复杂度实现查询和修改功能。下面先介绍树状数组的原理，再介绍如何利用树状数组来实现排行榜。由于涉及到学习算法，还有应用。本节的两个内容需要对照查看才能理解，建议对下面两小节的内容，先概览熟悉基本概念，再逐渐研究细节。并没有严格的先后顺序之分。</p>
<h3 id="2-1-树状数组原理"><a href="#2-1-树状数组原理" class="headerlink" title="2.1 树状数组原理"></a>2.1 树状数组原理</h3><p>树状数组（Binary Indexed Tree），又以其发明者命名为Fenwick树。可以在O(logn)时间内得到数组任意前缀和，并能够在O(log(n))时间内支持动态单点的值的修改。空间复杂度是O(n)。</p>
<p>所有的正整数，都可以表示为2的幂和。 $N&#x3D;\sum_{i&#x3D;1}^m2^{ki} $ ,ki为二进制表示时，为1位的位置。</p>
<p>例如$34&#x3D;2^1+2^6;12 &#x3D; 2^2+2^3$;</p>
<img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640.png" class="" title="图片">

<p>我们设一个整数数组元素个数为N，数组名为A，包含元素为$A_{j}(1&lt;&#x3D;j&lt;&#x3D;N)$</p>
<p>对于一个整数i，lowbit(i)表示i的二进制最后一个位置1，所代表的值。（例如lowbit（12）&#x3D; 4，lowbit（34）&#x3D;2）</p>
<p>构造树状数组 $BIT_{i} &#x3D; \sum_{j&#x3D;i-lowbit(i)+1}^{i}A_{j}$</p>
<p><code>BIT[i]=A[i-lowbit(i)+1] + A[i-lowbit(i)+2] + ... + A[i]</code></p>
<p>所表示的数学意义为，下标为i的树状数组元素，为原数组A[i]往前lowbit(i)个元素的和（包括A[i])。</p>
<p>对于树状数组元素BIT[i]，可以画一棵树表示，树中的父节点表示的区间和，覆盖子节点表示的区间和。</p>
<p>下图为i&#x3D;8时画出的树。</p>
<img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640-20240720163708514.png" class="" title="图片">

<p>树状数组是在数组上建立的一种树形关系结构。</p>
<p>以上图为例，A数组是原始存储数据的数组，有8个元素。C数组是按照每个下标覆盖2次幂范围得到的新的子序列和的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BIT1 = A1 （1的二进制表示为1，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT2 = A1 + A2（2的二进制表示为10，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT3 = A3（3的二进制表示为11，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT4 = A1 + A2 + A3 + A4（4的二进制表示为100，有2个0，覆盖4个元素）</span><br><span class="line"></span><br><span class="line">BIT5 = A5（5的二进制表示为101，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT6 = A5 + A6（6的二进制表示为110，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT7 = A7（7的二进制表示为111，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8（8的二进制表示为1000，有3个0，覆盖8个元素）</span><br></pre></td></tr></table></figure>

<p>有了树状数组BIT[i]，我们就可以实现<strong>求原数组A[i]的前缀和</strong>，还有<strong>A[i]中单个元素修改时快速更新BIT[i]数组的功能</strong>。</p>
<p>一、求原数组A的前缀和</p>
<p>假设求原数组A的前i个元素的和Sum[i]，对于整数区间[1,i],可以表示为两个区间[1, i-lowbit(i)],[1-lowbit(i), i]。</p>
<p>如果设j&#x3D;i-lowbit(i)，那么j&lt;&#x3D;i并且Sum[0] &#x3D; 0，则Sum[i] &#x3D; Sum[j] + BIT[i]；之后再逐步求解Sum[j]，直到递推到Sum[0] &#x3D; 0，便计算出前缀和Sum[i]。</p>
<p>二、原数组某个元素A[i]修改，同步修改树状数组BIT</p>
<p>当某个元素A[i]修改时，所有包含A[i]的树状数组元素BIT[j]都要进行相应的修改。</p>
<p>对于A[i]，BIT[i]肯定包含A[i]的和。再根据上面的树形结构，</p>
<p>$BIT_{i_{k+1}} &#x3D; BIT_{i_{k}} + lowbit(i_{k}) 其中 (i_{0}&#x3D;i, i_{k+1}&lt;&#x3D;N)$   </p>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>根据上一小节的分析，可以用代码实现树状数组。<br>对于求lowbit(n),可以用n&amp;(n^(n-1))得到，由于在C++中用补码表示负数，可以写为n&amp;(-n)。用函数封装为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求数组A的前i项和为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//求前i项和 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        s+=BIT[i]; </span><br><span class="line">        i-=lowbit(i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改原数组A[i]元素，增加val值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n) </span><br><span class="line">    &#123; </span><br><span class="line">        BIT[i]+=val; </span><br><span class="line">        i+=lowbit(i);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-树状数组优化排行榜"><a href="#2-3-树状数组优化排行榜" class="headerlink" title="2.3 树状数组优化排行榜"></a>2.3 树状数组优化排行榜</h3><p>如何使用树状数组来实现排行榜的需求呢？要经过一些转化。</p>
<p>我们把要排行的分数划定一个区间范围。假设分数都是整数，最大值MAX_SCORE为1,000,000分。</p>
<p>则原始数组A[i]表示具有分数为i的值的用户数量，然后求出BIT[i]数组。假设一个人的分数为j，则排名为BIT[MAX_SCORE]-BIT[j-1]。</p>
<p>利用上小节的代码很容易就实现了。</p>
<p>排行榜封装的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> BIT[MAX_SCORE + <span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始时所有分数的人数都是0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uid, newScore, oldScore;</span><br><span class="line">    GetUserInfoReq(&amp;uid, &amp;newScore, &amp;oldScore);<span class="comment">//假设收到请求，获得uid用户的最新分数为newscore,上次更新分数为oldscore;</span></span><br><span class="line">    <span class="type">int</span> oldRank = sum(MAX_SCORE)-sum(oldScore)+<span class="number">1</span>;<span class="comment">//查询旧排名</span></span><br><span class="line">    <span class="comment">//更新为新排名</span></span><br><span class="line">	add(oldScore, <span class="number">-1</span>);<span class="comment">//先给旧分数的人数减一</span></span><br><span class="line">	add(newScore,  <span class="number">1</span>);<span class="comment">//再给新分数的人数加一</span></span><br><span class="line">	<span class="type">int</span> newRank = sum(MAX_SCORE)-sum(newScore)+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//返回用户新排名newRank，和老排名oldRank供前端展示</span></span><br><span class="line">    SetUserInfoRsp(uid, newScore, newRank, oldScore, oldRank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以把用户的分数数据存储在用户资料中，排行榜模块只存储树状数组用来排名。最开始初始化时，可以遍历所有用户资料，获取每个用户的score，然后调用add(score, 1)完成全部初始化。之后用上面的代码，在每次分数有更新的时候调用获取排名变化。</p>
<p>核心代码只有30几行，而且由于是存储在数组中，一块连续的内存，可以把树状数组放到共享内存中。即使进程重启，也能够马上恢复服务。</p>
<p>使用树状数组有前提条件：</p>
<p>1、就是不能存储分数为0的玩家的排名；</p>
<p>2、分数要都是整数；</p>
<p>3、要有上限，最大不能超过MAX_SCORE范围。</p>
<p>虽然有诸多限制，但都能通过业务逻辑处理。如果分数有小数，可以乘以相应的倍数，转换成整数。例如充值1.01元，可以把单位转换成分来存储101分。上限可以根据业务逻辑调整，即使正整数的最大表示2^32，log(n)也只需要32次处理，远远小于O(n)的处理。</p>
<p>如果要突破限制，需要在业务层面和实现逻辑上再做些转换，一般都可以很好解决。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>对于排行榜需求，通过树状数组，能够实现实时更新和展示实时变化。排行榜实时更新的瓶颈是单值修改，整体排序。树状数组能够做到单值修改，部分更新，优化掉了排行榜瓶颈。</p>
<p>在实际开发中，遇到问题，要先梳理问题的步骤，找到瓶颈。针对瓶颈进行学习研究，对于高级数据结构要有所了解，在实际开发中，合理运用，能够达到简化开发，提升项目稳定和效率好处。同时在使用的过程中注意边界条件，让一些产品设计在边界条件内，能够达到产品特性用户满意和程序实现复杂度降低的双赢局面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" data-id="clyu70ko70084b0oo359tf39y" data-title="简单高效的排行榜算法——树状数组" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          格雷码
        
      </div>
    </a>
  
  
    <a href="/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">随机数在互联网业务中的应用</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>