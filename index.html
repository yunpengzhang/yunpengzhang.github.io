<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>owenzhang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="owenzhang的博客">
<meta property="og:url" content="https://yunpengzhang.github.io/index.html">
<meta property="og:site_name" content="owenzhang的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="owenzhang">
<meta property="article:tag" content="后端,架构,读书,运动,写作">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="owenzhang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">owenzhang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个程序员的成长之路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yunpengzhang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2024/向着目标冲击——读《曼巴精神：科比自传》 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/" class="article-date">
  <time class="dt-published" datetime="2024-07-10T10:00:03.000Z" itemprop="datePublished">2024-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>初读《曼巴精神：科比自传》还是在科比刚去世时，转眼已经几年过去了，科比还没有被球迷们遗忘。写一篇读后感纪念下科比。</p>
<p>如果你想对科比有全面的了解，那么这本书值得一一读。</p>
<p>本书是科比唯一授权的自传。类似于娱乐明星的自传，文字内容很少，夹杂着很多照片，如果想快速度一个下午就差不多读完了。</p>
<h1 id="科比的成就"><a href="#科比的成就" class="headerlink" title="科比的成就"></a>科比的成就</h1><p>喜欢篮球的人对科比应该不会陌生，论在世界的知名度，应该是篮球界的一哥。</p>
<p>起码在中国，拿出科比的照片，80，90后应该都会认识。</p>
<p>虽然乔丹和詹姆斯也很厉害，但是科比在实名度方面应该更胜一筹。</p>
<p>因为科比处在的时代是NBA最繁盛的时期，那时中美关系还很好，乔丹也退役了。</p>
<p>国人对篮球的关注度最为高涨，因为王治郅，姚明，巴特，孙悦，易建联多位球员登陆NBA打球。</p>
<p>那时CCTV5还会转播常规赛，自然对于NBA的当家球星科比来说，在中国的知名度水涨船高。</p>
<p>当时中学生穿的篮球衣大多数是湖人队，科比也成了那一代的篮球回忆。。</p>
<p>在北京奥运会上，别的体育明星镜头都是一闪而过，唯有科比特写停留几秒，这才是世界超巨所有的待遇。</p>
<p>在科比职业生涯中，获得过5次总冠军，一次3连贯（湖人王朝）。</p>
<p>获得过北京奥运会冠军。</p>
<h1 id="科比的努力"><a href="#科比的努力" class="headerlink" title="科比的努力"></a>科比的努力</h1><p>通过读这本书，终于明白了为什么科比可以获得这么多成就。</p>
<p>获取这么多成就不只是天赋，更多是后天的努力。确定目标后不顾一切地冲向目标，不到最后一秒不算完。</p>
<h2 id="目标管理"><a href="#目标管理" class="headerlink" title="目标管理"></a>目标管理</h2><p>在加入NBA初期，科比就以成为伟大球员为目标，励志得总冠军，进名人堂。</p>
<p>为了得到总冠军，科比加强训练。</p>
<p>科比的训练哲学：如果有效，就坚持到底，哪怕他不流行（实用主义）</p>
<p>为了平衡工作和家庭，会选择午夜训练，确保家人和训练都不影响。因此会有一个勤奋的梗 —— 你见过凌晨4点的洛杉矶吗？</p>
<p>伟大并非常人所及，为了伟大要做出牺牲，要为之痴迷。他的训练达到了痴迷的程度，热身时会从篮下开始，把每个位置都投一遍。保持身体在最佳状态，可以跑一整天。</p>
<p>为了得到总冠军，会详尽办法向前人请教，乔丹，湖人名宿都会去问，因为他认为哪怕平时尴尬，总强过退役时没有一个总冠军出丑大。</p>
<p>为了实现冠军，会把和冠军相关的所有因素都准备完善，达到极致。</p>
<h2 id="迎难而上"><a href="#迎难而上" class="headerlink" title="迎难而上"></a>迎难而上</h2><p>为了取得职业成就，科比付出了很多肉体的伤病，但是伤病没有打倒他，反而让他更强。</p>
<p>每场比赛、训练后，要用冰敷来消除炎症，双脚在冰桶泡20分钟。有时还会进行冰与火之歌，4分钟冷水，4分钟热水交替循环。甚至在职业生涯后期，打完球赛，两条腿会有像小瓜一样大小的积液。</p>
<p>科比的肩膀有时会发生错位，在比赛前要给扶正。</p>
<p>如果说伤病对于每个运动员都必不可少，那么科比在伤病时对待比赛的态度更难等可贵。</p>
<p>在比赛时手指当时断了，马上到更衣室拍X光，队医确定打球不会恶化后，科比带着断了的手指商场比赛。最终在退役后手指也不能弯曲。</p>
<p>在科比即将退役前，跟腱断裂，他也感觉到了肯定很严重，甚至会导致退役。但是罚完球才下场。凭借着顽强的毅力，科比带着伤痛前行。最后跟腱手术，留下了一道很深的疤痕带着厚厚的缝合线。</p>
<p>每天投1000球为了让手指适应新的投篮手型。</p>
<p>在俱乐部，国家队都要当球队老大。面对新的当家球员，总是迎难而上，主动防守詹姆斯，擒贼擒王。</p>
<p>书里没有写为什么科比叫黑曼巴，但是看过科比的比赛，他在比赛中防守时，会像蛇一样缠斗住对手，不给对方任何机会。有一个经典的镜头，对方用球砸向他的眼睛，视图让他恐惧，但是他丝毫未动。</p>
<h2 id="冠军背后"><a href="#冠军背后" class="headerlink" title="冠军背后"></a>冠军背后</h2><p>在书中介绍了很多不为人知的事情。科比也是普通人，为了赢得总冠军，做了不少规则以外的事情。</p>
<p>研究裁判规则，平时和裁判搞好关系。在比赛中会利用裁判的盲区，做一些犯规动作。防守其他人时，也会针对其他人的弱点去犯规。例如对麦迪，知道他腰有伤，会故意冲撞他的痛处。</p>
<p>然而在竞技比赛中，这种情况也很常见。因为乔丹和罗德曼防守科比时，也会卡住他的手，控制科比的移动。</p>
<p>毕竟是商业联盟，一切都是为了赢。</p>
<p>科比也坦言到，在职业生涯末期，没有争夺总冠军的情况下，才会像篮球新秀传递一些篮球技法。</p>
<p>通过自传也发现，科比和奥尼尔的关系应该不好。在书中多次提到加索尔，但是提到奥尼尔的只有几处。在最后有专门描写和其他球员关系的章节中，也没有奥尼尔。</p>
<p>估计对于谁是湖人一哥两个人争夺的比较激烈。在三连冠期间，奥尼尔都是FMVP，科比的性格肯定接受不了。因为可能会认为科比是和奥尼尔混到的冠军。最终奥尼尔走了，在后面的两冠终于拿到了FMVP。</p>
<p>但是奥尼尔得了六次总冠军，而且奥尼尔的努力程度不及科比。奥尼尔有着更高的天赋，和更好的运气。奥尼尔还投资了早期谷歌。寿命也比科比长。</p>
<p>如果科比不努力，取得的成就更少。除了要和别人比，也要和自己比，对于天赋和运气要看开些。</p>
<p>为了实现总冠军，科比真是把能做的都做了。职业生涯五次冠军，也是非常好的战绩。而且在退役之战得了60分，退役巡演完美完成。</p>
<p>在退役后科比也没有就此享受，而是开启了公司，甚至说过几年后他最大的成就不是篮球而是其他领域。</p>
<p>可惜出现了意外事故，一代传奇就此结束。</p>
<p>致敬偶像最好的方式是让自己配得上他，虽然科比已经离世，但是曼巴精神长存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/" data-id="clyu70kob008ab0oo3gsrhzac" data-title="向着目标冲击——读《曼巴精神：科比自传》" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2020/认识思考的本质——《思考，快与慢》" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/" class="article-date">
  <time class="dt-published" datetime="2020-01-09T16:00:00.000Z" itemprop="datePublished">2020-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>《思考，快与慢》这本书已经读过好几遍，最近为了分享给部门的同学们，又重新读了一遍。又有很多新发现。从前有些地方有遗漏，有些地方理解的也不准确。这次再总结下，否则过一段时间在记忆自我中，可能这本书的内容剩下的就不多了。</p>
<h2 id="为什么读这本书"><a href="#为什么读这本书" class="headerlink" title="为什么读这本书"></a>为什么读这本书</h2><p>最早知道这本书，是CTO推荐的，而且在各种场合推荐过很多次，是提升管理能力必读的一本书。此书的分类也是经管类，通过学习这本书，来更科学地做决策。我们平时使用的科学决策法，其中的一些原理本书也有介绍。通过对人思考的了解，在做决策时，规避自身思考的误区。</p>
<p>这本书的作者很有名，叫丹尼尔卡尼曼，心理学家，以色列人，在美国做研究。因为前景理论，修正了经济学中经济人的假设，在2002年获得诺贝尔经济学奖。经济人就是说人都是理性的，在进行一些决策时总会用最优法。但从心理学发现，人做决策时并不是理性的，即使是经济学家，也并不理性。</p>
<p>这本书也是2011年纽约时报的十大好书，在国内的一些读书榜单中，也经常出现。</p>
<p>全书分为五个部分，向我们介绍了人是如何思考，以及一些非理性思考的规律，还有对应的实验，是一本很严谨的书。</p>
<h2 id="第一部分：系统1和系统2"><a href="#第一部分：系统1和系统2" class="headerlink" title="第一部分：系统1和系统2"></a>第一部分：系统1和系统2</h2><p>了解系统1和系统2是阅读本书的基础。他们是2种思维能力的描述。在人脑中并不存在系统1和系统2两个部分。</p>
<p>系统1是快速的，无意识的，是人直接对事物思考的反馈。例如看到一张愤怒的脸，马上就能识别表情是愤怒。这就是系统1的作用。使用系统1不怎么费脑力，但是我们不能主动关闭他，而且系统1不善于逻辑和统计学问题。</p>
<p>系统2则在系统1遇到麻烦时来解决问题。例如计算17×24。系统1并不能马上给出，这时系统2来进行处理。在使用系统2的时候，人会比较专注，而且也很耗费体力，会感到劳累。这也是为什么人不是时时刻刻都用系统2的原因。</p>
<p>由于系统1很快，有时会忽略一些因素，这也是我们有时做决策会出现错误的原因。例如看下面的图片，在左面系统1就会认为这个是数字3，在右面，系统1就认为这是字母B。之所以一样的符号，在不同环境，会认为不同的内容，是因为系统1会直接忽略不明确的元素，根据环境来直接作出判断。但一切发生的行云流水，我们都没有感知。生活中还有众多的事情，我们都是这样忽略过去，直接作出判断。<img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240718191507391" class="" title="图片"></p>
<p>一个经过思维专业训练的人，在做决策时也是要抑制住系统1的判断。例如下面这张图。训练过的人知道两个线段是一样长。但是在感官上，还是看上面的要短些。因为我们的系统1不能主动关闭，在决策时要有意识主动抑制系统1的错误想法。<img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240718191521009" class="" title="图片"></p>
<h2 id="第二部分-启发法与偏见"><a href="#第二部分-启发法与偏见" class="headerlink" title="第二部分 启发法与偏见"></a>第二部分 启发法与偏见</h2><p>在日常生活中，我们会主动在头脑中构建一些信息，利用已有的小部分内容，思考出认为合理的方案。从而产生出错误的决策和偏见。</p>
<h3 id="小数定律"><a href="#小数定律" class="headerlink" title="小数定律"></a>小数定律</h3><p>一件事情人们经历过小样本，就会忽略大样本。一般会忽略掉概率的存在，有时还会人为启发，脑补全部内容，认为自己思考的很有道理。</p>
<p>在生活中很常见。例如问一些同学，中国的本科率有多少？有的认为达到60%以上，因为他周围的人都是这样。这就是小数定律的例子。根据自己见到的，而忽略掉了整体的数据。以前有说五环内的产品经理，也是如此。在做产品和决策的时候，要客观收集数据，重视事物的概率。</p>
<p>有些人买彩票，也会有一套什么样的选号能中奖的理论，这都是人为启发的结果，把偶发事件用因果解释。</p>
<p>有些事情是没有因果关系的，只是偶发事件，做因果解释必然会是错误的。</p>
<h3 id="锚定效应"><a href="#锚定效应" class="headerlink" title="锚定效应"></a>锚定效应</h3><p>给定一个参照物，后面做的一些判定就会以这个参照物来做。</p>
<p>例如讨价还价的时候，先定了一个价格，后面大家都会围绕着这个价格去讨论，最终的成交价就在最初价格附近。</p>
<p>还有的公司为了提升品牌价值，在宣传的时候，会与知名大公司对标。都是为了让大众产生锚定，把两个公司划分在一个档次中。</p>
<p>锚定效应在商业谈判，还有商品定价方面，应用的很广。</p>
<h3 id="可得性启发法"><a href="#可得性启发法" class="headerlink" title="可得性启发法"></a>可得性启发法</h3><p>有些事情大家从记忆搜寻，会把容易想到的认为发生概率大。例如飞机失事事件，在新闻中看到的频率很高，就认为飞机很不安全。但实际上飞机的事故率要远远低于其他交通工具。和小数定律类似，我们在做决策的时候，还是要注重客观数据，而不要仅依靠主观记忆。</p>
<p>还有个有意思的现象，人可以解答所有问题。因为人在解答一些困难问题时，会通过联想关联，把问题自动替换，然后解答。这也是系统1执行的，有时都没在意就把问题替换了。例如问最近幸福吗？可能就会把最近谈朋友的事情替换掉这个问题，思考的都是谈朋友的感受。</p>
<h3 id="光环效应"><a href="#光环效应" class="headerlink" title="光环效应"></a>光环效应</h3><p>例如一个演员长的帅，我们也会认为他什么都好。例如有些漂亮演员的字写的不好，观众看到都不相信。在日常面试时，要注意光环效应，防止因为应试者一项的好坏，而影响到其他方面。</p>
<h3 id="焦虑情绪与风险政策"><a href="#焦虑情绪与风险政策" class="headerlink" title="焦虑情绪与风险政策"></a>焦虑情绪与风险政策</h3><p>大部分人没有对心理学进行过学习，所以一些小概率事件如果被过度夸张报道，会导致普通人恐慌。书中说政府在制定风险政策时要考虑这些问题。</p>
<p>对于组织来说，有两方面工作要做：</p>
<p>1、加强组织成员的学习，对于一个小组织，还是可以做到大家知识统一，认知一致的；</p>
<p>2、制定组织政策时，要考虑到普通人的感受，有时越强调无风险，一些人越不安。</p>
<h2 id="第三部分-过度自信与决策错误"><a href="#第三部分-过度自信与决策错误" class="headerlink" title="第三部分 过度自信与决策错误"></a>第三部分 过度自信与决策错误</h2><p>一些成功学的故事，故事脉络清晰，内容简单，进展顺利。这种故事，人们更容易接受。例如描述谷歌发展，是如何打败竞争对手，在过程中公司高层是如何决策，最终选对方向，让公司最终成功。但实际上商业发展原因很多，其中很重要一点就是运气。可是人经常忽略掉运气。</p>
<p>人比较容易相信直觉。有些事情说不出原因，但是能够判定。并不是什么事情都能够有直觉。能够具有直觉的场景要满足一定的条件：要环境有规律；经过大量的练习。例如象棋大师经过长时间训练能够培养直觉，看到棋盘中的状态，就能作为一种输入，来产生提示，作出最好判定的输出。一般要经过一万小时的练习才行。但是像股票走势，这种环境是没规律的，影响因素太多，所以谈预测也是不准。为什么有很多人会觉得股票能预测，甚至认为预测的准呢？有时是因为后见之明。在一件事情发生后，人会忘记之前的老想法，认为最开始就是那么想的。</p>
<p>对于直觉的训练，和机器学习有些类似，其中应该有一些道理是相通的。</p>
<p>在做决策的时候要养成采纳外部意见的习惯。靠统计数据预测，而不是直觉。因为依靠眼前信息很有限，有很多漏洞。而且人会乐观。当出现问题的时候也会陷入沉默成本。一般可以参照其他类似项目是如何的结果，来进行参考。书中有一个例子，他们编写教材。开始认为2年，最后用了7年。而且之前他们也知道其他人用了很久，但是忽略掉。全世界铁路对乘客数量的预测，在60年里都是不准确的。都没有从以前的数据中挖掘。对于程序员，经常出现的就是排期乐观，最终延期。采纳外部意见可以在排期的时候试试，对比下其他已经完成的项目的工时，来合理评估。</p>
<h2 id="第四部分-选择与风险"><a href="#第四部分-选择与风险" class="headerlink" title="第四部分 选择与风险"></a>第四部分 选择与风险</h2><p>这部分是作者获得诺贝尔奖的核心——前景理论。</p>
<p>本质就是人喜欢得到，厌恶风险。对于获得100美金和损失100美金，心理价值是不同的。人在面对盈利，更倾向于稳定，面对损失，更倾向于面对风险。下图的这个S曲线就是描述的这种现象。</p>
<img src="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/640-20240720163518423" class="" title="img">

<p>对于我们日常的决策，一种有效的方法是思考做这件事的本质是什么，到底是为了达到什么目标。而不要被框架所束缚。例如买卖股票的时候，不要考虑过去的成本，只卖盈利的，认为没盈利的后来还会涨。而是要看股票未来的涨势来确定买卖。还有一些沉默成本的事情，要做到及时止损，做到整体收益最大。</p>
<h2 id="第五部分-两个自我"><a href="#第五部分-两个自我" class="headerlink" title="第五部分 两个自我"></a>第五部分 两个自我</h2><p>经验自我和记忆自我。经验自我就是当前的自我，就是你当时的感受，记忆自我就是在记忆中的自我。</p>
<p>峰终定律（peak-end rule）：整体的回顾性评级可通过将最糟糕时期和最后时刻的疼痛程度的平均加权而评估出来。</p>
<p>过程忽视（duration neglect）：过程的持续对所有疼痛的评估没有任何影响。</p>
<p>一件痛苦的事情，在高峰的痛苦程度，还有离最后结束的时间对人的感受有影响。但是过程中的累计对所有疼痛却没有影响。</p>
<p>人会比较在意最终结果，例如影视剧的结局，一般都是好结局。对于幸福评估，也是要让记忆自我体验更好一些会更幸福。</p>
<p>到底是在意当时当刻的感受，还是在意未来回忆的感受，在两个自我中可以做出选择。例如旅行时，到底是要要享受旅行时的乐趣，还是更多时间拍照来留下场景照片。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这本书是一本理论的书，书中的内容比较散，加上翻译的原因。读这本书会要用频繁到系统2，会感觉有些累。但是对于人思考的方式，还有一些做决策的局限都有解释，学习了一些理论，在生活中也很有帮助。例如我们要采纳外部意见，对于一些媒体报道要仔细思考，小数定律等都让我们不要急于作出决策，要用好逻辑和统计学工具来决策。一些平时的工作内容，还是能够用书中的理论来进行优化。</p>
<p>而且这种书，不同于教授具体方法的书，过一段时间重新读，还会有新的理解和收获，对一些内容的感受也更深。</p>
<p>确实是一本有效提升决策能力的书。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/" data-id="clyu70ko80088b0oogvx58jgn" data-title="认识思考的本质——《思考，快与慢》" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/多阶Hash算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2019-11-27T09:08:42.000Z" itemprop="datePublished">2019-11-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在分布式系统中，会经常用到K-V存储，一般实现的方式有红黑树或者哈希表，在Redis中还用到了跳表。都是通过一个确定的Key值，来查找Key附带的Value属性。本文会介绍一种高效的算法——多阶Hash。</p>
<h1 id="1原理"><a href="#1原理" class="headerlink" title="1原理"></a>1原理</h1><p>多阶Hash的实现原理很简单，每个Hash桶数组算作一阶，如果有20阶的多阶Hash，那么就是一个二维数组，第一维是Hash桶的编号，第二维是每个Hash桶的每个槽的位置。实际开发中，可以申请一块连续的内存，由一维数组构造出二维数组。内存构造如下图所示，逻辑上是一个阶梯状，实际申请内存，是一块连续的内存结构，用每次层的阶数来标识出不同阶的分界。如下图所示：</p>
<img src="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/640-1301099.-1301102.-1301103.-1301105." class="" title="img">

<p>通常每阶的槽的个数都是质数个，每阶的槽的个数依次递减。由于互质的特性，通常情况下会上面的阶数先被填满，然后再逐步填下面的阶数。在实际使用中，内存使用率可以达到90%以上。</p>
<p>查找和插入的时间复杂度都是<code>$O(h)$</code>，h是阶数。</p>
<p><strong>查找操作</strong>：对于一个待查找的Key，查找是否在某一阶有被存储，就用Key模除该阶的槽数M，得到Key在该阶存储的下标，然后判断该下标中存储的元素的key是否和待查找的Key相同。如果该阶没有匹配，再依次查找下一阶，如果找到则返回查找成功。如果遍历所有阶都没找到，则返回未找到。</p>
<p><strong>插入操作</strong>：先进行查找操作，如果找到已经有存储过该Key，则修改对应位置的元素。如果没有找到该Key，则找到从第1阶到最后一阶中，第一个能存储Key但未分配的位置，把该Key值插入进去。</p>
<p>与教科书中的开链Hash对比，优缺点如下：</p>
<h1 id="2优点"><a href="#2优点" class="headerlink" title="2优点"></a>2优点</h1><h2 id="1、查找时间稳定"><a href="#1、查找时间稳定" class="headerlink" title="1、查找时间稳定"></a>1、查找时间稳定</h2><p>查找时间和阶数成正比，虽然不一定最高效，但是是可控的，最坏要多少次查找是能够控制的。如果是接链表解决冲突，冲突太多就退化成链表操作，耗时不可控。</p>
<h2 id="2、实现简单"><a href="#2、实现简单" class="headerlink" title="2、实现简单"></a>2、实现简单</h2><p>实现完全是数组操作，而且存储内容都是定长。与树形数据结构相比，实现简单很多。</p>
<h2 id="3、方便序列化"><a href="#3、方便序列化" class="headerlink" title="3、方便序列化"></a>3、方便序列化</h2><p>由于底层是连续内存，能够通过内存迭代遍历全部元素，dump到外部文件。再通过dump文件重新插入实现恢复数据。</p>
<h2 id="4、鲁棒性强"><a href="#4、鲁棒性强" class="headerlink" title="4、鲁棒性强"></a>4、鲁棒性强</h2><p>互联网业务大都是常驻进程，如果进程重启会导致栈或堆中的内存销毁。可以通过共享内存来达到重启后恢复内存数据。由于多阶Hash底层是数组结构，只需要知道起始位置和元素下标，就能够对内存元素进行操作。进程重启后重新挂载内存即可恢复操作，不需要重建索引。</p>
<h1 id="3缺点"><a href="#3缺点" class="headerlink" title="3缺点"></a>3缺点</h1><h2 id="1、容量有限"><a href="#1、容量有限" class="headerlink" title="1、容量有限"></a>1、容量有限</h2><p>由于阶数有限，如果最后一阶填满后，会导致Key值没有地方存储。不如链表的扩展性好。</p>
<p>在实际项目，要做好容量管理和监控。当发现使用率超过70%的时候，就要准备扩容，防止写满。</p>
<h2 id="2、存储定长"><a href="#2、存储定长" class="headerlink" title="2、存储定长"></a>2、存储定长</h2><p>存储的部分是二维数组的Hash桶的块，是一块定长的内存。如果存储的数据是变长的，就需要把内存块定义为最大Value的长度，会造成内存浪费。常见优化方法是在Hash块中存储一个索引，索引指向另外一块内存链表，变长数据被分别存储在多个内存链表中。一般设置每块内存链表的长度也需要计算。</p>
<p>多阶Hash适用于读多写少的互联网业务场景，通常是一个进程负责写操作，多个进程负责读操作。多个进程来提高整体的读的并发量，来弥补每次查找都需要<code>$O(h)$</code>的复杂度。</p>
<p>多阶Hash是一种在生产实践中总结的算法，从学术上看它并不完美。因为会出现元素存不下的情况，而且时间复杂度的常数系数比较大。但是在互联网读多写少的业务场景中，读速度可控，容量管理能监控，这些问题都能够被解决。同时还带来容易实现，鲁棒性强，内存使用率高的优点。</p>
<p>在实践中得到的这个算法，虽然不是十分优美，但是真的十分实用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/" data-id="clyu70ko3007kb0ooc2eb0smx" data-title="多阶Hash算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/格雷码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2019-11-26T10:00:03.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>格雷码（循环二进制单位距离码）是任意两个相邻数的代码只有一位二进制数不同的编码，它与奇偶校验码同属可靠性编码。</p>
<p>格雷码（Gray code）是由贝尔实验室的Frank Gray在1940年提出，用于在PCM（脉冲编码调变）方法传送讯号时防止出错。</p>
<p>例如2位的格雷码，排列为00，01，11，10。这个排列中的四个数字，每相邻两个二进制序列都仅有一位不同。可以扩展到n位格雷码，而且格雷码的排列不仅有一种。例如上面2位的格雷码，还可以是00，10，11，01。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现格雷码有两种方法，递归和数学方法。</p>
<p>递归的方法是：</p>
<p>1位格雷码只有0，1;</p>
<p>n位格雷码的序列为k1,k2…kn;</p>
<p>n+1位格雷码的序列为0k1,0k2…0kn,1kn…1k2,1k1。就是先把前n位的格雷码高位补零，然后把前n位格雷码倒序，再高位补1衔接。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">grayCode</span>(n<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = tmp[i]*<span class="number">2</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tmp.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = tmp[i]*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>数学方法：</p>
<p>一个二进制数n对应的格雷码G(n),是n与n-1异或的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> n ^ (n &gt;&gt; <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rev_g</span><span class="params">(<span class="type">int</span> g)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; g; g &gt;&gt;= <span class="number">1</span>) n ^= g;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>格雷码由于相邻两个数字只差一位，可以用来降低转态转换出错的概率。</p>
<p>如果一次状态变换改变3个比特，那么3个比特变化不是原子的，在他们变换的中间态，例如只有2个比特变了的时，此时读取数据会读到错误的状态。但是使用格雷码，每次只变更1个比特。是最小差异。能够避免读错。这是格雷码最初的应用。</p>
<p>除了容错外，格雷码还能用来实现汉诺塔移动策略。</p>
<p>具体的方法是：</p>
<p>假设汉诺塔n个盘子，从小到大编号为1~n。</p>
<p>三个柱子A、B、C，盘子从A移动到C。</p>
<p>如果汉诺塔有n个盘子，则n位格雷码，自左至右编号为第n位，第n-1位…第2位，第1位。</p>
<p>每次格雷码变更的位序号数k，则是第k的盘子移动。除了第一个盘子，其他编号的盘子移动的位置是固定的。</p>
<p>如果盘子数是偶数，则最小的盘子先移动到B，如果盘子数是奇数，则最小的盘子移动到C。后面按照格雷码变更的位置移动。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/" data-id="clyu70ko6007yb0oo9nxtfqz2" data-title="格雷码" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/简单高效的排行榜算法——树状数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T10:00:03.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="0-问题场景"><a href="#0-问题场景" class="headerlink" title="0 问题场景"></a>0 问题场景</h2><p>在互联网业务中，为了刺激玩家活跃度，通常都会制作榜单，让用户能够看到自己在榜单中的名次。用户要看到的内容是：新的分数排行是多少名，相比之前是前进了，还是后退了，具体前进后退的数值是多少。例如充值排行榜，游戏分排行榜，活跃度排行榜等。由于互联网用户基数大，有些平台参与排行的用户可以达到上千万。但是排行榜最重要的就是时效性，能够让用户越早看到排行更新越好。</p>
<p>对于庞大的榜单，每次其中一个元素更新，都要重新排序，即使用快速排序，对CPU运算的消耗都是巨大的，很容易造成卡顿。很多互联网业务都采用离线定时更新榜单的方案。例如每天凌晨4点的数据切片，离线排序更新，更新后展示最新的榜单。这种方案在程序性能和用户体验间做了折衷，既保证了每天更新，又不至于实时更新导致运算量太大，算不出来。</p>
<p>有没有更高的解决方案，可以实时查看用户排行变化呢？一个有序的排行榜，只是一个用户的数据发生变化，就要所有数据重新排序，能只做到部分排序吗？</p>
<p>对于这两个问题，可以利用一种高级的数据结构「树状数组」，再结合对排行榜的算法来实现。</p>
<h2 id="1-排行榜实现及优化方案"><a href="#1-排行榜实现及优化方案" class="headerlink" title="1 排行榜实现及优化方案"></a>1 排行榜实现及优化方案</h2><p>我们先梳理下排行榜的通用实现方案，再查看下针对具体的步骤进行优化。<br>一个通用排行榜的实现方案步骤如下：</p>
<ol start="0">
<li>已经有一个排好序的排行榜；</li>
<li>当用户分数有更新时，保存用户老的排行榜名次和老的分数；</li>
<li>更新用户新的分数，并更新排行榜，获取新排行名次；</li>
<li>展示新老名次的差异，结束。</li>
</ol>
<p>难点就在第二点，如何更新排行榜。最简单粗暴的想法是，更新排行榜中对应的分数，然后调用快速排序对数组再重新排序一次。快速排序时间复杂度是nlog(n)的，如果有1000万人参与，每次就要进行上亿次的比较。如果每秒有一千个玩家修改分数，要执行千亿次运算。对于排行榜系统的性能消耗是巨大的，做不到实时展示排行数据更新。</p>
<p>原先已经排好序的数组，只有一个元素的值发生了变化，其他元素的相对顺序是不用更改的。从这个角度来优化程序，能够做到快速实现排序优化。使用树状数组，能够做到修改和查询都是log(n),那么对于1000万人参与的榜单，比较次数最多只需要23次，一千个玩家每秒修改，只需要23000次比较。单进程都可以承受住。而且树状数组底层是构建在数组之上的，数据结构简单，容易持久化，能够方便地保存在共享内存中。当常驻进程重启时能够快速恢复。</p>
<p>说了树状数组这么多好处，这么适合排行榜业务的实现，下面我们来介绍下树状数组的原理，以及在排行榜业务中使用的方法。</p>
<h2 id="2-树状数组实现排行榜"><a href="#2-树状数组实现排行榜" class="headerlink" title="2 树状数组实现排行榜"></a>2 树状数组实现排行榜</h2><p>我们利用树状数组来实现排行榜功能，能够在Olog(N)的复杂度实现查询和修改功能。下面先介绍树状数组的原理，再介绍如何利用树状数组来实现排行榜。由于涉及到学习算法，还有应用。本节的两个内容需要对照查看才能理解，建议对下面两小节的内容，先概览熟悉基本概念，再逐渐研究细节。并没有严格的先后顺序之分。</p>
<h3 id="2-1-树状数组原理"><a href="#2-1-树状数组原理" class="headerlink" title="2.1 树状数组原理"></a>2.1 树状数组原理</h3><p>树状数组（Binary Indexed Tree），又以其发明者命名为Fenwick树。可以在O(logn)时间内得到数组任意前缀和，并能够在O(log(n))时间内支持动态单点的值的修改。空间复杂度是O(n)。</p>
<p>所有的正整数，都可以表示为2的幂和。 $N&#x3D;\sum_{i&#x3D;1}^m2^{ki} $ ,ki为二进制表示时，为1位的位置。</p>
<p>例如$34&#x3D;2^1+2^6;12 &#x3D; 2^2+2^3$;</p>
<img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640.png" class="" title="图片">

<p>我们设一个整数数组元素个数为N，数组名为A，包含元素为$A_{j}(1&lt;&#x3D;j&lt;&#x3D;N)$</p>
<p>对于一个整数i，lowbit(i)表示i的二进制最后一个位置1，所代表的值。（例如lowbit（12）&#x3D; 4，lowbit（34）&#x3D;2）</p>
<p>构造树状数组 $BIT_{i} &#x3D; \sum_{j&#x3D;i-lowbit(i)+1}^{i}A_{j}$</p>
<p><code>BIT[i]=A[i-lowbit(i)+1] + A[i-lowbit(i)+2] + ... + A[i]</code></p>
<p>所表示的数学意义为，下标为i的树状数组元素，为原数组A[i]往前lowbit(i)个元素的和（包括A[i])。</p>
<p>对于树状数组元素BIT[i]，可以画一棵树表示，树中的父节点表示的区间和，覆盖子节点表示的区间和。</p>
<p>下图为i&#x3D;8时画出的树。</p>
<img src="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/640-20240720163708514.png" class="" title="图片">

<p>树状数组是在数组上建立的一种树形关系结构。</p>
<p>以上图为例，A数组是原始存储数据的数组，有8个元素。C数组是按照每个下标覆盖2次幂范围得到的新的子序列和的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BIT1 = A1 （1的二进制表示为1，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT2 = A1 + A2（2的二进制表示为10，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT3 = A3（3的二进制表示为11，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT4 = A1 + A2 + A3 + A4（4的二进制表示为100，有2个0，覆盖4个元素）</span><br><span class="line"></span><br><span class="line">BIT5 = A5（5的二进制表示为101，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT6 = A5 + A6（6的二进制表示为110，有1个0，覆盖2个元素）</span><br><span class="line"></span><br><span class="line">BIT7 = A7（7的二进制表示为111，有0个0，覆盖1个元素）</span><br><span class="line"></span><br><span class="line">BIT8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8（8的二进制表示为1000，有3个0，覆盖8个元素）</span><br></pre></td></tr></table></figure>

<p>有了树状数组BIT[i]，我们就可以实现<strong>求原数组A[i]的前缀和</strong>，还有<strong>A[i]中单个元素修改时快速更新BIT[i]数组的功能</strong>。</p>
<p>一、求原数组A的前缀和</p>
<p>假设求原数组A的前i个元素的和Sum[i]，对于整数区间[1,i],可以表示为两个区间[1, i-lowbit(i)],[1-lowbit(i), i]。</p>
<p>如果设j&#x3D;i-lowbit(i)，那么j&lt;&#x3D;i并且Sum[0] &#x3D; 0，则Sum[i] &#x3D; Sum[j] + BIT[i]；之后再逐步求解Sum[j]，直到递推到Sum[0] &#x3D; 0，便计算出前缀和Sum[i]。</p>
<p>二、原数组某个元素A[i]修改，同步修改树状数组BIT</p>
<p>当某个元素A[i]修改时，所有包含A[i]的树状数组元素BIT[j]都要进行相应的修改。</p>
<p>对于A[i]，BIT[i]肯定包含A[i]的和。再根据上面的树形结构，</p>
<p>$BIT_{i_{k+1}} &#x3D; BIT_{i_{k}} + lowbit(i_{k}) 其中 (i_{0}&#x3D;i, i_{k+1}&lt;&#x3D;N)$   </p>
<h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><p>根据上一小节的分析，可以用代码实现树状数组。<br>对于求lowbit(n),可以用n&amp;(n^(n-1))得到，由于在C++中用补码表示负数，可以写为n&amp;(-n)。用函数封装为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求数组A的前i项和为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//求前i项和 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        s+=BIT[i]; </span><br><span class="line">        i-=lowbit(i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改原数组A[i]元素，增加val值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n) </span><br><span class="line">    &#123; </span><br><span class="line">        BIT[i]+=val; </span><br><span class="line">        i+=lowbit(i);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-树状数组优化排行榜"><a href="#2-3-树状数组优化排行榜" class="headerlink" title="2.3 树状数组优化排行榜"></a>2.3 树状数组优化排行榜</h3><p>如何使用树状数组来实现排行榜的需求呢？要经过一些转化。</p>
<p>我们把要排行的分数划定一个区间范围。假设分数都是整数，最大值MAX_SCORE为1,000,000分。</p>
<p>则原始数组A[i]表示具有分数为i的值的用户数量，然后求出BIT[i]数组。假设一个人的分数为j，则排名为BIT[MAX_SCORE]-BIT[j-1]。</p>
<p>利用上小节的代码很容易就实现了。</p>
<p>排行榜封装的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SCORE = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> BIT[MAX_SCORE + <span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//初始时所有分数的人数都是0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uid, newScore, oldScore;</span><br><span class="line">    GetUserInfoReq(&amp;uid, &amp;newScore, &amp;oldScore);<span class="comment">//假设收到请求，获得uid用户的最新分数为newscore,上次更新分数为oldscore;</span></span><br><span class="line">    <span class="type">int</span> oldRank = sum(MAX_SCORE)-sum(oldScore)+<span class="number">1</span>;<span class="comment">//查询旧排名</span></span><br><span class="line">    <span class="comment">//更新为新排名</span></span><br><span class="line">	add(oldScore, <span class="number">-1</span>);<span class="comment">//先给旧分数的人数减一</span></span><br><span class="line">	add(newScore,  <span class="number">1</span>);<span class="comment">//再给新分数的人数加一</span></span><br><span class="line">	<span class="type">int</span> newRank = sum(MAX_SCORE)-sum(newScore)+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//返回用户新排名newRank，和老排名oldRank供前端展示</span></span><br><span class="line">    SetUserInfoRsp(uid, newScore, newRank, oldScore, oldRank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以把用户的分数数据存储在用户资料中，排行榜模块只存储树状数组用来排名。最开始初始化时，可以遍历所有用户资料，获取每个用户的score，然后调用add(score, 1)完成全部初始化。之后用上面的代码，在每次分数有更新的时候调用获取排名变化。</p>
<p>核心代码只有30几行，而且由于是存储在数组中，一块连续的内存，可以把树状数组放到共享内存中。即使进程重启，也能够马上恢复服务。</p>
<p>使用树状数组有前提条件：</p>
<p>1、就是不能存储分数为0的玩家的排名；</p>
<p>2、分数要都是整数；</p>
<p>3、要有上限，最大不能超过MAX_SCORE范围。</p>
<p>虽然有诸多限制，但都能通过业务逻辑处理。如果分数有小数，可以乘以相应的倍数，转换成整数。例如充值1.01元，可以把单位转换成分来存储101分。上限可以根据业务逻辑调整，即使正整数的最大表示2^32，log(n)也只需要32次处理，远远小于O(n)的处理。</p>
<p>如果要突破限制，需要在业务层面和实现逻辑上再做些转换，一般都可以很好解决。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>对于排行榜需求，通过树状数组，能够实现实时更新和展示实时变化。排行榜实时更新的瓶颈是单值修改，整体排序。树状数组能够做到单值修改，部分更新，优化掉了排行榜瓶颈。</p>
<p>在实际开发中，遇到问题，要先梳理问题的步骤，找到瓶颈。针对瓶颈进行学习研究，对于高级数据结构要有所了解，在实际开发中，合理运用，能够达到简化开发，提升项目稳定和效率好处。同时在使用的过程中注意边界条件，让一些产品设计在边界条件内，能够达到产品特性用户满意和程序实现复杂度降低的双赢局面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" data-id="clyu70ko70084b0oo359tf39y" data-title="简单高效的排行榜算法——树状数组" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/随机数在互联网业务中的应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2019-09-27T10:00:03.000Z" itemprop="datePublished">2019-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">随机数在互联网业务中的应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="随机数在互联网业务中的应用"><a href="#随机数在互联网业务中的应用" class="headerlink" title="随机数在互联网业务中的应用"></a>随机数在互联网业务中的应用</h1><p>在互联网业务中，随机数被用到的场景很广泛。通常大家也认为使用随机数很简单，直接调用现成的函数库即可实现功能。但是想用好随机数还是有些难度的。需要熟悉其中的原理。本文会介绍一些在互联网业务中使用随机的方法。</p>
<p>在信息学中，随机的定义如下：</p>
<blockquote>
<p>随机性：不存在统计学偏差，是完全杂乱的数列</p>
<p>不可预测性：不能从过去的数列推测出下一个出现的数</p>
<p>不可重现性：除非将数列本身保存下来，否则不能重现相同的数列</p>
</blockquote>
<p>随机数可能在统计上呈现某种规律。</p>
<p>在工程上，用到随机也主要是用到两个特性：</p>
<ol>
<li>不可预测性</li>
<li>均匀获取数字。（在大量随机统计时，每个数出现次数的期望相同）</li>
</ol>
<p>在安全相关的场景，用到的是不可预测性。例如生成密钥，生成验证码等场景，让黑客不能从中找到生成的规律。</p>
<p>在抽奖实现、负载均衡等场景，主要用到随机数在统计时，每个随机数字出现的次数的期望都很接近，让结果是公平的。</p>
<h2 id="0-随机数的生成方法"><a href="#0-随机数的生成方法" class="headerlink" title="0 随机数的生成方法"></a>0 随机数的生成方法</h2><p>在计算机中，主要生成随机数有两种方法，线性同余算法，硬件设备随机数生成器。</p>
<h3 id="一、线性同余算法"><a href="#一、线性同余算法" class="headerlink" title="一、线性同余算法"></a>一、线性同余算法</h3><p>在C函数库中的<code>rand()</code>函数，用的就是线性同余算法，类似的实现代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RAND_MAX assumed to be 32767 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myrand</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span>((<span class="type">unsigned</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mysrand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注：以上只是为了简单描述Glibc库实现的方法，实际代码不是这样写的。</code></p>
<p>利用<code>srand</code>函数设置初始随机种子，在每次需要随机数的时候调用<code>rand</code>生成随机数。</p>
<p>线性同余算法的特点是：只要种子相同，即使在两台不同的机器上，都能够产生相同的随机序列。利用这个特性，我们可以在应用层做很多事。</p>
<p>例如：</p>
<p>时间换空间：只要保存一个种子，就能够通过计算得到一个序列。可以利用这个序列来实现功能。</p>
<p>还原操作：在客户端根据随机序列构建地图，然后在服务器校验，只需要同步种子，就能实现相同场景。</p>
<p>线性同余算法计算速度快，实现简单，但是是<strong>伪随机</strong>，知道种子后能够预测随机序列，而且随机序列经过一段时间后会循环重复。</p>
<p>所以在安全使用的场景中，不会使用线性同余算法。</p>
<h3 id="二、Linux系统的-dev-random"><a href="#二、Linux系统的-dev-random" class="headerlink" title="二、Linux系统的&#x2F;dev&#x2F;random"></a>二、Linux系统的&#x2F;dev&#x2F;random</h3><p>&#x2F;dev&#x2F;random在类UNIX系统中是一个特殊的设备文件，可以用作随机数发生器或伪随机数发生器。Linux内核允许程序访问来自设备驱动程序或其它来源的背景噪声。</p>
<p>发生器有一个容纳噪声数据的熵池，在读取时，&#x2F;dev&#x2F;random设备会返回小于熵池噪声总数的随机字节。&#x2F;dev&#x2F;random可生成高随机性的公钥或一次性密码本。</p>
<p>若熵池空了，对&#x2F;dev&#x2F;random的读操作将会被阻塞，直到收集到了足够的环境噪声为止。这样的设计使得&#x2F;dev&#x2F;random是真正的随机数发生器，提供了最大可能的随机数据熵，建议在需要生成高强度的密钥时使用。</p>
<p>为了解决阻塞的问题，还提供了一个设备&#x2F;dev&#x2F;urandom，即非阻塞版本。它会重复使用熵池中的数据以产生伪随机数据，输出的熵可能小于&#x2F;dev&#x2F;random的。它可以作为生成较低强度密码的伪随机数生成器。</p>
<p><strong>安全使用随机数是比较专业的场景，一般都是使用特定的库或算法，直接调用即可，不要自己造算法。</strong></p>
<h2 id="1-误用随机的场景"><a href="#1-误用随机的场景" class="headerlink" title="1. 误用随机的场景"></a>1. 误用随机的场景</h2><p>在日常的开发场景中，遇到过几种误用随机的场景，相信很多人还会掉到这些坑里。这里提出来供大家参考。</p>
<h3 id="1-1-多次设置随机种子"><a href="#1-1-多次设置随机种子" class="headerlink" title="1.1 多次设置随机种子"></a>1.1 多次设置随机种子</h3><p>线性同余算法，为了让每次程序启动时生成的随机数都是不同的，可以利用<code>srand()</code>函数设置不同的随机种子。一般是设置种子为当前时间，或者进程的进程号等。然后再调用<code>rand()</code>来生成随机数。**<code>srand()</code>只需要开始调用一次，<code>rand()</code>是每次需要随机数的时候调用一次。**</p>
<p>但是有的错误用法，会在常驻进程中使用随机数的时候，把<code>srand</code>和<code>rand</code>配套调用。起不到随机的效果，每一秒钟的随机数都是一样的，而且只取到的线性同余生成的第一个随机数，整体的均匀性也达不到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="literal">NULL</span>));<span class="comment">//正确使用的方式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//srand(time(NULL));//错误使用的方式,同一秒生成的r值都相同。</span></span><br><span class="line">    <span class="type">int</span> r = rand();</span><br><span class="line">    <span class="comment">//使用随机数的逻辑</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用上面错误的方式，在一个常驻进程中，会让每秒钟生成的随机数都相同。假如这个随机数是用来给后端选择路由的，会造成同一秒钟的流量都访问到同一个节点，起不到负载均衡的作用。在大型互联网服务中，一秒钟的流量也是巨大的，可能会影响单一节点的服务质量。</p>
<h3 id="1-2-生成范围随机数直接取模"><a href="#1-2-生成范围随机数直接取模" class="headerlink" title="1.2 生成范围随机数直接取模"></a>1.2 生成范围随机数直接取模</h3><p>假设一个随机函数rand21()，每次生成的随机数范围是[0, 21)，那么现在要生成[0, 10)的随机数，如何生成。</p>
<p>常见的错误实现方式是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rand10 = rand21() % 10;</span><br></pre></td></tr></table></figure>

<p>虽然这种方式得到的数字结果是在[0, 10)之间的。但这种实现方式是错的，因为生成的[0,10)区间的数字不均匀。生成0这两个数字的概率要超过其他9个数字的概率。</p>
<p>rand21产生的[0, 10), [10, 20)取模对应[0,10)是等概率的，会多出来[20, 21)这个区间。直接取模会让结果不均匀。</p>
<p>正确的做法应该是截断这段数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int r = 0;</span><br><span class="line">int rand10 = 0;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    r = rand21();</span><br><span class="line">    if(r&gt;=20)</span><br><span class="line">        continue;</span><br><span class="line">    else</span><br><span class="line">        rand10 = r % 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码理论上会产生死循环，可能一直生成20这个随机数。在实际工程中可以做个上报，发现超过一定的数值次数，就主动跳出循环，返回失败或设置个默认值。但实际这种概率非常小。</p>
<p><strong>从一种随机数范围的发生器，映射到另一个随机数范围的发生器过程中，不要简单的取模，可能会造成结果不是随机的。</strong></p>
<blockquote>
<p>注：除了截断操作，还有拼接的方法，拼出要随机新范围的倍数，再取模。本质和截断一样。</p>
</blockquote>
<h3 id="1-3-一定要用随机吗"><a href="#1-3-一定要用随机吗" class="headerlink" title="1.3 一定要用随机吗"></a>1.3 一定要用随机吗</h3><p>有时，我们用随机的场景，不是真的为了随机，而是为了让结果更分散。这种场景用随机是一种实现方式。需要了解业务的目的，挑选出适合的实现方式，让方案更简单。</p>
<p>例如路由选择，只要保证节点分布是均匀的，是否可预测并不是必要条件。只要整体的统计分布是均匀即可。存储一个计数器，简单的轮询也是实现均匀分发。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机实现路由</span></span><br><span class="line"><span class="comment">//getRouteNodeId返回后端要路由到的Node节点的id，id的范围是[0, nodeCount)</span></span><br><span class="line"><span class="comment">//nodeCount后端节点的总数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRouteNodeId</span><span class="params">(<span class="type">int</span> nodeCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand()%nodeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询实现</span></span><br><span class="line"><span class="comment">//getRouteNodeId返回后端要路由到的Node节点的id，id的范围是[0, nodeCount)</span></span><br><span class="line"><span class="comment">//nodeCount后端节点的总数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRouteNodeId</span><span class="params">(<span class="type">int</span> nodeCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> nextNodeId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (nextNodeId++)%nodeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有些场景，用随机反而麻烦。</p>
<p>例如每100万号码存储在一个服务中，对前1000万个号码进行发送push消息操作。如果直接按顺序遍历这1000万个号码，会对这10个存储服务分别造成查询压力。导致修改操作冷热不均。一种方式是每次从号码区间中随机选择一个号码处理，但是要记录号码是否被选择过的状态，需要额外的存储空间。</p>
<p>还一种简单的方法是先按照号段轮询，再按照号码轮询，可以达到不需要存储的实现方式。</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> group = <span class="number">0</span>; group &lt; <span class="number">10</span>; ++group)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> uid = group * <span class="number">10000</span> + i;</span><br><span class="line">		<span class="comment">//下发消息逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是用到的是映射，让结果均匀，虽然随机也能达到这个目的。</p>
<h2 id="2-项目中用到的随机场景"><a href="#2-项目中用到的随机场景" class="headerlink" title="2. 项目中用到的随机场景"></a>2. 项目中用到的随机场景</h2><p>在项目中，用好随机可以帮我们提高用户体验，还可以帮我们用时间换空间。</p>
<h3 id="2-1-让用户体验更好的随机"><a href="#2-1-让用户体验更好的随机" class="headerlink" title="2.1 让用户体验更好的随机"></a>2.1 让用户体验更好的随机</h3><p>有时虽然程序员懂随机，但是和用户理解的随机不一样，这时程序员要适应用户的感观。</p>
<h4 id="2-1-1-歌曲随机播放"><a href="#2-1-1-歌曲随机播放" class="headerlink" title="2.1.1 歌曲随机播放"></a>2.1.1 歌曲随机播放</h4><p>在播放器中，随机播放是一种播放模式。如果简单的调用随机函数，会出现用户接受不了的情况。可能下一首播放的歌曲和当前歌曲是一样的，可能某个子序列会反复播放。</p>
<p>例如有ABCD四首歌。可能会出现AABB、ABABABAB这样的顺序播放。虽然在数学上是达到了随机，但是用户体验不佳。</p>
<p>播放器的「随机播放」实际上是一种打乱播放的意思，可以用的shuffle洗牌算法（可以使用<code>Fisher–Yates shuffle</code>算法）。把原本有序的序列，变成无需无规则的序列，就像洗扑克牌一样。</p>
<p>以下为<code>Fisher–Yates shuffle</code>算法的伪代码，也用到了随机函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices <span class="number">0.</span>.n-<span class="number">1</span>):</span><br><span class="line">for i from n−<span class="number">1</span> downto <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">     j ← random <span class="keyword">integer</span> such that <span class="number">0</span> ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]-- To shuffle an array a of n elements (indices <span class="number">0.</span>.n-<span class="number">1</span>):</span><br><span class="line">for i from n−<span class="number">1</span> downto <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">     j ← random <span class="keyword">integer</span> such that <span class="number">0</span> ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure>



<p>有时还需要考虑专辑、歌手、曲风等因素，可以多一些区分的维度，在每个维度再加上一些随机。可能有些歌曲用户比较爱听，随机到的权重也要高一点。</p>
<p>总之，歌曲的随机播放要根据用户对播放器的预期，来干涉生成序列，不能简单粗暴地直接使用随机来生成。</p>
<h4 id="2-1-2-游戏抽奖"><a href="#2-1-2-游戏抽奖" class="headerlink" title="2.1.2 游戏抽奖"></a>2.1.2 游戏抽奖</h4><p><strong>十连抽</strong></p>
<p>在游戏中，为了激励玩家批量购买，会有「10连抽必中稀有物品」的玩法。用户如果一次性消耗10次中奖机会，就会至少中一次稀有物品。</p>
<p>由于已经承诺给用户必中，所以要干预连续10次抽中的情况，如果出现10次都没中大奖，就会给用户替换一个稀有物品。</p>
<p>对于10连抽的场景，要人工干预最后的奖励序列。不能一味的随机。</p>
<p><strong>普通抽奖</strong></p>
<p>在一些国家或地区，会要求软件开发者给出中奖概率。当玩家知道中奖概率后，针对玩家的抽奖就不能完全用随机函数，小于概率值就中，不小于就不中的方法。因为这种方法会让玩家体验不好，以为官方在作弊。</p>
<p>例如：一个装备，抽奖中奖的概率是10%。以普通玩家的想法，抽10次就会中一次，如果抽20次才中一次，玩家也勉强接受。但是如果抽100次，一次都不中，大多数玩家都接受不了的，一方面会质疑游戏的公平性，也会因为体验不好而离开。另外一边与运气不好的玩家相反，还有些运气好的玩家，可能抽10次，就中了5次，消耗了过多的奖品。</p>
<p>在一些大DAU的游戏中，运气好的玩家和运气不好的玩家，出现的概率还挺高的。</p>
<p>运气不好的玩家。每次抽中奖概率10%，抽100次都不中的概率是$(1-10%)^{100}&#x3D;2.656*10^{-5}$大概万分之二。如果一天有1万个玩家抽了100次奖，平均有2个人是100次都不中。</p>
<p>运气好的玩家。10%中奖，抽10次中5次的概率是$C(10, 5) * 10%^5*90%^5 &#x3D; ‭0.0014880348‬$，大概是万分之15左右，是运气不好的玩家概率的7、8倍。</p>
<p>为了让玩家感观上是随机并且公平，也采用洗牌算法，对每个玩家生成一个奖品等级的中奖序列。把序列打乱，按次序给玩家，每次根据奖品等级生成该等级的奖品发给玩家。</p>
<h4 id="2-1-3-游戏武器暴击"><a href="#2-1-3-游戏武器暴击" class="headerlink" title="2.1.3 游戏武器暴击"></a>2.1.3 游戏武器暴击</h4><p>在游戏中的武器装备也涉及到概率，例如一把屠龙刀，暴击概率提升到30%。玩家的感觉也是在10刀里，大概率会有3刀是暴击的，在100刀里要有30几刀的暴击。</p>
<p>暴击和抽奖遇到的问题类似，都是玩家对概率的理解和程序员理解不一致。因为按照独立事件的概率，可以连续100次都不暴击，也可以连续3-4刀每次都暴击。连续不暴击会伤害持有武器玩家的体验，连续暴击会伤害和持有武器对战玩家的体验。</p>
<p>暴击在游戏中的不确定性会增加游戏的乐趣性。和抽奖不同，偶尔多一两次，对于游戏来说玩家也是可以接受的，不会像抽奖如果密集中奖会影响体验。在暴击的随机，可以参考暴雪的随机公式（PRD）。</p>
<p>$$P(N) &#x3D; C × N$$</p>
<p>P(N) 表示在第N次攻击之后某个动作发生得概率，N表示第N次修正概率后得攻击次数（最小值为1），C表示暴击发生的初始概率以及每次攻击之后概率的增量，是个简单地线性关系。当N足够多的时候，P（N）总会趋向于1。</p>
<p>在编写程序时，先设置好C，通过C来增加下一次效果触发的几率。C会作为初始概率，比效果说明中的概率要低。当效果没有触发时，会不停地积累N，让P(N)逐渐增加接近100%。一旦效果触发了效果，计数器N就会重置。</p>
<p>例如一把武器有25%暴击，把初始概率C设置为8.5%。那么第一次攻击，他实际上只有大约8.5%几率触发暴击，随后每一次失败的触发会增加大约8.5%触发几率，于是到了第二次攻击，几率就变成大约17%，第三次大约25.5%，以此类推，在一次暴击触发后，下一次攻击的触发几率又会重置到大约8.5%，那么经过一段时间之后，暴击几率的平均值就会接近25%。</p>
<p>采用PRD随机公式保证在有限次数能够实现暴击，并且整体期望和独立事件的期望接近。</p>
<h3 id="2-2-时间换空间"><a href="#2-2-时间换空间" class="headerlink" title="2.2 时间换空间"></a>2.2 时间换空间</h3><h4 id="2-2-1-游戏作弊校验"><a href="#2-2-1-游戏作弊校验" class="headerlink" title="2.2.1 游戏作弊校验"></a>2.2.1 游戏作弊校验</h4><p>在一些消除类的单机游戏中，玩家游戏在客户端本机进行，结束后上传分数给服务器。服务器会根据玩家的分数进行排行，并给予一些奖励。为了让玩家能够有良好的体验，在游戏过程中，所有操作都在本地进行。为了防止作弊，在玩家上传分数后进行检测。</p>
<p>如何做到校验玩家游戏是否作弊呢？方法也比较简单，把游戏数据上传，在服务器重放玩家操作，根据行为判断是否作弊。但是这里有一个难点，游戏开始下发地图的时候，如果把游戏中所有的随机事件，例如机关的摆放，NPC的随机施法都生成好下发到客户端，会消耗很多流量，影响启动速度。</p>
<p>线性同余算法，不同机器相同种子，可以产生相同序列的特性，很好地支持了这个场景。在游戏开始时，通过加密通道，把随机种子下发给客户端，客户端按照随机种子生成地图和操作。结束游戏，客户端上传用户操作，服务器收到操作序列后，重新生成地图和地图上的机关操作，然后快速执行玩家操作。最终校验两种结果是否一致。通过种子的传递，只要算法一致，就能够重放，大大降低了带宽和同步数据的复杂度。</p>
<h4 id="2-2-2-节约存储成本"><a href="#2-2-2-节约存储成本" class="headerlink" title="2.2.2 节约存储成本"></a>2.2.2 节约存储成本</h4><p>在互联网早期的一些安全充值的场景中，为了验证充值卡的归属。用户充值时，需要输入充值卡背面的密保卡片中的一些数字，校验卡片归属。因为充值卡后面的密保矩阵是被覆盖的，如果刮开会影响销售，只有购买的人才能看到。一般是一个10*10的数字矩阵。</p>
<p>最直接设计方法是，可以给每个充值卡生成一个随机的100个数字序列，然后每次针对用户的输入进行匹配。如果矩阵每个数字用两个字节存储，1张卡要耗费200个字节。如果发行了1亿张卡，就要20G的存储空间。</p>
<p>但是如果每张卡只存一个种子值，当用户来校验时，根据种子生成100个数字来校验，效果是一样的。假设一个种子4个字节，1亿张卡只需要400M存储就可以了。可以都load到缓存中加快速度。</p>
<p>利用随机空间换时间，本质是存储元数据，利用算法的生成规律，保证能反复重放序列。可以达到减少同步信息，降低存储量的效果。虽然现在带宽和存储的成本越来越低，但是掌握了这种方法，在一些特殊场景中能够提供奇妙的解决方案。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>随机在互联网应用的十分广泛，我们根据场景采用不同的使用方式。</p>
<p>在安全相关的专业算法领域，用已有的算法和工具，不要去造轮子。在Linux系统中使用&#x2F;dev&#x2F;random读取随机数。</p>
<p>在应用层，使用伪随机函数例如线性同余算法，快速生成随机数，满足大多数生成随机数的需求。</p>
<p>在游戏、歌曲等更高层应用的领域，用户对随机的理解和数学上的随机不太一致。要区分用户是要整体分布更均匀，还是让结果充满随机性增加乐趣。根据场景适时调整，修改随机数的分布，而不是默认采用独立事件生成随机数，往往能够达到更好的效果。</p>
<p>算法是固定的，在实现业务的时候，要从实际角度出发，选择最适合的实现方式，来满足业务需求。做到活学活用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" data-id="clyu70ko70086b0oobn4m058o" data-title="随机数在互联网业务中的应用" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/程序员，选择和努力哪个重要？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E9%80%89%E6%8B%A9%E5%92%8C%E5%8A%AA%E5%8A%9B%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2019-05-25T10:00:03.000Z" itemprop="datePublished">2019-05-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E9%80%89%E6%8B%A9%E5%92%8C%E5%8A%AA%E5%8A%9B%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F/">程序员，选择和努力哪个重要？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>从年初到现在面试了近百人。面试中发现，有的同学还应该再努力些再换工作；而有的同学已经很努力了，做的很好，但没有选择好，去了不适合自己的公司。</p>
<p>能力好，又选择了好公司好岗位的，还真是不多。</p>
<p>如何才能选到好公司好岗位呢？到底选择和努力哪个更重要呢？</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>这里说的选择，是说程序员如何选择一个好工作。</p>
<p>要做到的是选择好行业、公司、和岗位，三者层层递进。</p>
<h3 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h3><p>选行业就是要选择大环境。就像90年代的通信行业，2000年之后的互联网行业，金融行业。这些行业的发展速度快，短期内能够聚集大量的资金。所在行业的公司市值要比其他行业的高。当然这些行业的从业者待遇也会更好。</p>
<p>行业决定了整体发展的大势，要顺势而为。如果行业的发展已经到了天花板，或稳定期，那么同样的努力，效果也不如发展期的行业。</p>
<p>有些行业即使现在待遇高，但是未来如何，是否适合程序员发展，也要综合考量。</p>
<p>例如有些房地产公司也有专门的研发岗位，是否在这个行业一直做软件开发有发展，要综合考量下。</p>
<h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>即使是相同的行业，其中不同的公司之间，差别也比较大。选公司也要选有前景，靠谱的公司。</p>
<p>大多数人容易犯的一个错误，只看薪资。可能只差几千块，就选择了工资高的公司。</p>
<p>不是不看薪资，而是不能只看薪资，要从多维度查看。</p>
<p>公司是否在扩张期，是否是一个有前景的公司。未来是否会成为行业龙头。</p>
<p>公司的企业文化和自己是否吻合。</p>
<p>公司环境怎么样，公司工作几年后，是否可以实现自己的目标。</p>
<p>看人，公司的人是否靠谱。和一群靠谱的人工作，结果肯定不会差。</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>两个公司差不多，待遇差不多，去哪家公司呢？</p>
<p>不要只看做的产品，或者部门的重要性。要看你去的位置。是否有牛人能够带你等。去了会在什么位置，是否有足够的空间供你发挥。</p>
<p>就像宰相蔡京家里的厨娘，什么菜都不用做，只需要剥葱。</p>
<p>职业生涯是不断发展的，要从长远看，不要只看眼前，要设想从未来往回看。再过些年，你的技能实力会提高吗，会变得更值钱吗？</p>
<p>上面说的都是选择参考的一些纬度，但本质还是要自身有明确的目标，知道你想要什么？否则你不知道什么是好，什么是不好。好这个概念是人主观的想象的，客观不存在的，别人认为好的不一定适合你。是否好，只有你自己知道。</p>
<p>需要独立思考，有明确目标。但对于大多数人，都是未曾有过的能力。</p>
<p>要做好选择固然重要，但是不能一直在选择。选的时候要仔细斟酌，但是选好后要沉下心来，专心做事，修炼自己。就像找老婆一样，谈女朋友时要慎重，可以多选选，结婚后就老老实实过日子吧。</p>
<h2 id="努力"><a href="#努力" class="headerlink" title="努力"></a>努力</h2><p>如何让自己更值钱？努力学习！</p>
<p>对于程序员来说，专业技能的提高是必须要做到的。同样的技术，要知道原理，学习的更深刻。而且行业迭代快，要不停地学习，接收新知识。</p>
<p>要掌握好安身立命的技能，当机会来的时候才能抓住。而不会因为自身的能力拖后腿而后悔。</p>
<p>普通人之间智商差不多，更多比的是努力，谁花的时间多，谁更勤奋，谁就会更强。</p>
<p>除了专业技能努力提高外，还需要提高「软技能」。专业技能是解决具体的问题。但是随着层次越高，问题越模糊，解决的方法也越来越多。就要对问题分析与解决、决策能力、心理学等有所训练。</p>
<p>不管学什么，都要投入时间，精力，经过不断地修炼，才能卓有成效。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>选择和努力要有个平衡。</p>
<p>重选择轻努力：频繁跳槽，到哪都「怀才不遇」；</p>
<p>重努力轻选择：交给「运气」，没有把控。</p>
<p>努力是基础，是自我能够控制的。特别在东亚这几个国家，从来不缺努力的人。</p>
<p>努力的过程会比较苦，要有坚强的毅力，有时要克服「人性」。长远看对自身是有好处的，需要延迟满足的准备。</p>
<p>选择充满了不确定性。即使科学决策，也不一定是最优决策。因为选择的时候还受到掌握信息量是否足够，还有选择后，事物的发展还受到其他因素的影响，都是不可控的。但是能力强的人机会更广，更好。选择后结果的稳定性会也更好。例如：读书成绩好的人不一定最有钱，不一定都有钱，但是读书好的人的平均收入肯定比读书差的平均收入高，受到运气的影响波动低。</p>
<p>努力是前提，只靠运气，概率太低。选择要掌握足够的信息，并且要科学决策，还要加一点点运气。作为人来说，做好自己能控制的，控制不了的，怨天尤人也没用。能力越强，运气也随之变好。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E9%80%89%E6%8B%A9%E5%92%8C%E5%8A%AA%E5%8A%9B%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F/" data-id="clyu70ko60082b0oo8pw5dqbb" data-title="程序员，选择和努力哪个重要？" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/如何当好面试者" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E8%80%85/" class="article-date">
  <time class="dt-published" datetime="2019-05-04T12:57:18.000Z" itemprop="datePublished">2019-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E8%80%85/">如何当好面试者</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="如何当好面试者"><a href="#如何当好面试者" class="headerlink" title="如何当好面试者"></a>如何当好面试者</h1><p>经过对一些面试者的观察，如果有些方面做的更好一点，会大大增加面试的效率，提升通过面试的概率。希望即将参加面试的同学，能够从以下这些点得到帮助。</p>
<h2 id="明确的目标"><a href="#明确的目标" class="headerlink" title="明确的目标"></a>明确的目标</h2><p>在参加面试之前，要先思考好面试的目的。为什么去面试？即将参加的这场面试，如果通过之后，是否满足你的要求。 如果确定要去参加，要对面试的公司，面试的岗位做些功课。知己知彼百战不殆。了解多一分，过的可能性就大一分。</p>
<h2 id="准备简历"><a href="#准备简历" class="headerlink" title="准备简历"></a>准备简历</h2><p>简历要包括以下这些内容，而且顺序也依次排列：</p>
<ol>
<li>姓名，联系方式，面试职位</li>
<li>学习经历和学习过程中获奖情况</li>
<li>工作经历和突出业绩</li>
<li>技术擅长点</li>
<li>其他</li>
</ol>
<p>宗旨是，让面试官或简历筛选者，能够在几秒钟，就能发掘你，看到你的重点信息。简历最好控制在一页纸，突出重点内容。 内容短，不代表内容少。要精心准备，对自己的长处短板有充分的了解，对过往的工作有总结。把重要的内容，简洁地写上去。 无关主题就不要贴了，如果面试程序员，是否会做饭关系不大，还浪费两行字的空间。</p>
<h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>看书：一般面试都会有笔试，考一些专业知识。如果准备面试，要做些复习，对一些基础知识和概念要充分了解。 即使是从前做的项目，也要准备下，对细节，数据做些总结。在被问到时能够对答如流。如果吞吞吐吐，会让面试官怀疑真实性。 做好面试公司的功课，对公司的业务，规模有所了解。在互联网上，都是公开信息。</p>
<h2 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h2><p>面试过程中，要做好及时反馈，让面试过程顺利进行。 如果面试官出题，要先复述下对题目的理解，防止读错题意。在做题的过程中，先说思路，再写代码，或进入下一步解题。如果思路有错误，面试官会给予提示，节约面试时间，能够让面试官做到尽量全面考察。 如果题目没思路，尽早说想不起来，或者过一会再解答。不要一直卡在那里，白白浪费掉面试时间。也可以和面试官说自己擅长哪些方面，在简历里要交代清楚。有些面试者什么都写精通，但问又答不好。要让面试官不停地探测擅长哪些知识，如果探测不对，最后面试者很难通过。 面试者要能引导面试官，让面试官知道自己擅长哪些。在介绍项目的时候，也突出重点，做过的项目哪里做的最好，克服了哪些困难。 总之，要在短短的一个小时里，展示你的才能，让面试官知道你是要找的人才。 即使面试没通过，也要总结，为后面的面试打基础积累经验，也可以过半年之后，再重新回来面试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>功夫在平时，面试的结果和平时的努力分不开。在平时要多刨根问底，探究问题的根本原因。多总结，定期总结工作要点内容。对基础知识要不断学习和强化，就像手艺人一样，这是安身立命的技能，不能丢。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E8%80%85/" data-id="clyu70ko4007ob0oo9u25ezdq" data-title="如何当好面试者" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/如何当好面试官" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E5%AE%98/" class="article-date">
  <time class="dt-published" datetime="2019-05-04T12:56:52.000Z" itemprop="datePublished">2019-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E5%AE%98/">如何当好面试官</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今年面试的人比较多，加起来快一百人了。由于面试任务比较多，也有越来越多的小伙伴加入了面试官的行列。 总结一些面试相关的方法论，希望新晋面试官有些帮助，最终能高效面试。</p>
<h2 id="必备思维"><a href="#必备思维" class="headerlink" title="必备思维"></a>必备思维</h2><p>面试官的目标是为组织找到合适的人，一切行为都是围绕这个主体来运作的。我们现在的面试还是类似于考试，这是一种能够在短时间内高效选择到合格面试者的方法。 <strong>存在误杀</strong>：和高考一样，面试不合格的人，也可能做好招聘岗位的工作。存在可能性，但是我们要通过面试题的设计，让这种概率尽可能小。 面试是为了选人才，不是为了难住面试者。所有的问题都结合面试岗位的要求，如果判断能胜任即可，我们的目的不是考试难倒候选人。 为什么不是一台电脑或一张卷子直接评定面试者，还要一个面试官来面？因为现阶段的技术，评价一个人是否符合岗位要求，还有些主观考察，是电脑做不到的。要求面试官不是机械的问问题，要能主动发掘面试者的特点和能力。 在整个面试过程中，<strong>面试标准评价要客观，面试信息挖掘和引导要主观</strong>。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>面试官准备面试，针对整个流程，都要有对应的模板。笔试模板，面试模板，评价模板。通过模板，能够节省时间，把面试的经验和教训积累起来。对不同的面试人，采用同一套模板体系，能够客观公证地评价面试者的成绩。让自己的状态对面试结果影响最小。</p>
<h3 id="笔试模板"><a href="#笔试模板" class="headerlink" title="笔试模板"></a>笔试模板</h3><p><strong>有多套笔试题</strong>，每套笔试题都有对应合格的分数。面试者分数应该是符合正态分布，能够区分出不同水平的人。 <strong>题目具有层次</strong>，一道题能够针对不同水平的人，增加更深入的问题。通过层层深入，评估出面试者的能力层级。 <strong>对漏题有对策</strong>，针对漏题有几种方式。 最简单的就是换题，增加新题目，看面试者是否能答出。 更好的是题目设计为开放性问题，没有标准答案，但是能够根据面试者的分析和解答过程，评价出面试者的能力。而且还可以延展问题，根据问题的回答，往不同方向延展，检测面试者是否真的又掌握这种知识。例如设计一个系统，设计一个类，并说明原因。这类素质不是靠背就能答出来的。需要经验的累积，这些不是短时间能突击出来的。 笔试题模板要有多种选项，每道题都有延展问题和细节扩充，能够应对不同水平的面试者。 问题要能层层递进，并且有区分度。</p>
<h3 id="面试模板"><a href="#面试模板" class="headerlink" title="面试模板"></a>面试模板</h3><p>笔试能够快速过滤掉能力不行的面试者。如果笔试通过，再通过面试来观察面试者是否符合进一步要求。这也是面试官的主要职责。 在面试前，针对要考察的素质（包括技术和非技术的）列好问题模板，在交流中要考察哪些点。提前查看简历，针对简历和问题进行合并，确定重点问的问题。 针对面试模板，最终输出一个表格，表格里有每项的权重，满分，时间是多少。面试时，填写面试者实际的分数，面试结束后综合打分。</p>
<h2 id="面试节奏"><a href="#面试节奏" class="headerlink" title="面试节奏"></a>面试节奏</h2><p>面试官要把握面世节奏，高效面试。 一票否决：事先明确哪些面试者是和公司要求有冲突的，不能加入的。例如：人品有问题，某些习惯难以适应招聘岗位。 面试过程中可以给予提示，但是提示也是分层的，根据提示的信息，最终给的分数也不同。如果发现面试者没思路，尽早换题，或询问面试者擅长的地方，有效考察能力。 推动面试的进行，模板中的问题要都问到，不要在一项素质已经评定好，特别是认定通过后，还耗费时间。防止面试时间过长，或者面试结束后，还评定不出面试者的能力。 面试过程中要针对简历和不明确的地方充分核实。例如毕业年份和上班年份有偏差，工作年限中有空白期等。 运用STAR面试法（S情况、T任务、A行动、R结果）针对面试者的项目，了解这四方面。要明确，完整，从多角度考察。通知在交流过程中也能对面试的沟通，表达等其他素质进行评定。</p>
<h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><p>面试结束后就真的结束了吗？不是的。 面试结束后和面试者保持沟通，保证顺利进行下一轮面试，防止两轮面试间隔太久，让面试者焦急等待。 详细录入面试题目和评价，供下一面面试官参考。录入内容包括：出了哪些题目，擅长、不擅长哪些，题目答的情况…… 同时总结模板中的优缺点，统计面试历史，根据实际情况对模板进行修订。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果要稳定、高效地面试，以上几点是必须要做到的。 制定合适的模板，定期总结修正。保证面试评定客观公正，在面试过程中合理引导，推动面试顺利进行。让面试结果受面试官的影响降到最小，不至于因为面试官自身的情况而影响到面试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/%E5%A6%82%E4%BD%95%E5%BD%93%E5%A5%BD%E9%9D%A2%E8%AF%95%E5%AE%98/" data-id="clyu70ko3007mb0oo1xafa1zi" data-title="如何当好面试官" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2019/Leetcode 第133场周赛解题报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-04-21T10:00:03.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/">Leetcode 第133场周赛解题报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天参加了leetcode的周赛，算法比赛，要求速度比较快。有思路就立马启动，不会纠结是否有更好的方法或代码可读性。只要在算法复杂度数量级内，基本上是怎么实现快速就怎么来了。</p>
<p>比赛时先看的第二题，一看题就有了思路，直接用的广度优先搜索，写完提交正确。再一看有人都做了3道题了，应该是职业选手了，要多像他们看齐。</p>
<p>之后看第一题，发现直接用贪心就能做，写了个双重循环，一次过掉。</p>
<p>第三题求最优连续子数组和，想到是动态规划。然后在处理代码细节上花了很长时间，中间提交还错了一次，在十一点半左右提交通过。</p>
<p>再看第四题，能想到是trie树和ac自动机，但是我手上没有现成代码，到比赛完也没有完成。</p>
<p>本次比赛题目偏简单，及时第四题如果经常做竞赛也很容易写。以后要多做些训练，把常用的代码整理下，否则比赛会比较耗时间。另外要多训练算法思维，一是在比赛时能够思路快。二是算法在工作中也比较重要，虽然很多时候都有封装好的现成函数，但是知道其中的原理，能够更高效地解决问题，对于新问题的思考也更全面更准确。</p>
<p>下面是今天比赛的详细解题。</p>
<hr>
<p>今天比赛的地址 Weekly Contest 133 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/weekly-contest-133">https://leetcode-cn.com/contest/weekly-contest-133</a> </p>
<h2 id="1-两地调度-Two-City-Scheduling"><a href="#1-两地调度-Two-City-Scheduling" class="headerlink" title="1. 两地调度(Two City Scheduling)"></a>1. 两地调度(Two City Scheduling)</h2><p>题号：1029</p>
<p>题目：两地调度(Two City Scheduling)</p>
<p>题意：2*N个人去A、B两地，每个地方都只有N个人去，每个人去A、B两地的费用分别给出，求总计最小费用。</p>
<p>思路：</p>
<p>方法一：</p>
<p>有最优策略，先把2N个人随意分成A、B两个集合，每个集合N个人。A集合去A地，B集合去B地。然后对于A集合中每个人ai，到B集合中遍历每个人bj，看是否能互换位置，让整体费用更低。如果有则换位置，没有检查下一个。全部换完则是最优解。</p>
<p>换的条件是ai去A的费用+bj去B的费用，要大于ai去B的费用+bj去A的费用。这样bj与ai互换整体费用会最低。</p>
<p>时间复杂度O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">        vector&lt;int&gt; va;</span><br><span class="line">        vector&lt;int&gt; vb;</span><br><span class="line">        for(int i=0;i&lt;costs.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i%2==0)</span><br><span class="line">                va.push_back(i);</span><br><span class="line">            else</span><br><span class="line">                vb.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;va.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0; j&lt;vb.size();++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int aindex=va[i];</span><br><span class="line">                int bindex=vb[j];</span><br><span class="line">                int acost = costs[aindex][0]+costs[bindex][1];</span><br><span class="line">                int bcost = costs[aindex][1]+costs[bindex][0];</span><br><span class="line">                if(acost&gt;bcost)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(va[i],vb[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(auto i : va)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=costs[i][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto i : vb)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=costs[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<p>把2N个人的费用排序，到B地比到A地超出差价大的人排在前面，最后让前N个人去，排在前面的人去A地更划算。整体费用最低。</p>
<p>时间复杂度O（nlogn）</p>
<p>方法三</p>
<p>动态规划，此题有最优子结构。用f[n][m]表示n个人，派m个人去A地，所花费的最小钱数。这时再来一个人，这个人有两种选择，一种是去A地，一种是去B地。<br>则更新</p>
<ol>
<li>如果去A地：f[n+1][m+1] &#x3D; min(f[n+1][m+1], f[n][m]+costA);</li>
<li>如果去B地：f[n+1][m]   &#x3D; min(f[n+1][m],   f[n][m]+costB);</li>
</ol>
<p>costA、costB表示这个人去A、B的花费。</p>
<h2 id="2-距离顺序排列矩阵单元格"><a href="#2-距离顺序排列矩阵单元格" class="headerlink" title="2. 距离顺序排列矩阵单元格"></a>2. 距离顺序排列矩阵单元格</h2><p>题号：1030</p>
<p>题目：距离顺序排列矩阵单元格(Matrix Cells in Distance Order)</p>
<p>题意：给出矩阵的行列值，和一个坐标点r，输出所有矩阵坐标，按照每个点到r曼哈顿距离排序输出。</p>
<p>两个坐标点(r1,c1)(r2,c2)的曼哈顿距离是|r1 - r2| + |c1 - c2|。</p>
<p>思路：<br>方法一：直接求出每个点到给出坐标的距离，再排序，然后输出即可。</p>
<p>方法二：用广度优先搜索，每次搜索到的点依次输出即可。比方法一代码麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; visited(R, vector&lt;int&gt;(C, 0));</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push(&#123;r0,c0&#125;);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int,int&gt; p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            int i = p.first;</span><br><span class="line">            int j = p.second;</span><br><span class="line">            if(visited[i][j]==1)</span><br><span class="line">                continue;</span><br><span class="line">            visited[i][j] = 1;</span><br><span class="line">            res.push_back(&#123;i,j&#125;);</span><br><span class="line">            int dx[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">            int dy[]=&#123;0,0,-1,1&#125;;</span><br><span class="line">            for(int k=0;k&lt;4;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int x = dx[k]+i;</span><br><span class="line">                int y = dy[k]+j;</span><br><span class="line">                if(x&gt;=0&amp;&amp;x&lt;R&amp;&amp;y&gt;=0&amp;&amp;y&lt;C)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(visited[x][y]==0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.push(&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-两个非重叠子数组的最大和"><a href="#3-两个非重叠子数组的最大和" class="headerlink" title="3. 两个非重叠子数组的最大和"></a>3. 两个非重叠子数组的最大和</h2><p>题号：1031</p>
<p>题目：两个非重叠子数组的最大和(Maximum Sum of Two Non-Overlapping Subarrays)</p>
<p>题意：</p>
<p>给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）</p>
<p>从形式上看，返回最大的 V，而 V &#x3D; (A[i] + A[i+1] + … + A[i+L-1]) + (A[j] + A[j+1] + … + A[j+M-1]) 并满足下列条件之一：</p>
<p>0 &lt;&#x3D; i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length, 或 0 &lt;&#x3D; j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length.</p>
<p>思路：</p>
<p>按照题目的思路，把A数组从元素i开始，分割成两部分，A[0…i],A[i+1…n]。求出A[0…i]中连续子数组中长度为L、M的和的最大值maxl1，maxm1，再求出A[i+1…n]中连续子数组中长度为L和M的和最大值maxl2,maxm2，在第i个元素分割时找到的最大值是maxi&#x3D;max((maxl1+maxm2),(maxm1+maxl2))。</p>
<p>那如何计算长度为L或M的连续子数组的和呢?假设要求的sum区间是L[k+1,k+2,…,k+L],则这个区间的值，可以用L[0,…k+L]的和减去L[0,…,k+1]的区间和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> len, vector&lt;<span class="type">int</span>&gt;&amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxsum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">            sum+=A[i];</span><br><span class="line">        v[len<span class="number">-1</span>]=sum;</span><br><span class="line">        maxsum = sum;</span><br><span class="line">        <span class="keyword">for</span>(i=len;i&lt;A.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum-A[i-len]+A[i];</span><br><span class="line">            maxsum=<span class="built_in">max</span>(sum,maxsum);</span><br><span class="line">            v[i]=maxsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> L, <span class="type">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; B = A;</span><br><span class="line">        <span class="built_in">reverse</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L1</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L2</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M1</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">M2</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">getMaxSum</span>(A, L, L1);</span><br><span class="line">        <span class="built_in">getMaxSum</span>(B, M, M1);</span><br><span class="line">        <span class="type">int</span> sum1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = L<span class="number">-1</span>;i&lt;n-M;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="type">int</span> y = n<span class="number">-1</span>-(i<span class="number">+1</span>);</span><br><span class="line">            sum1=<span class="built_in">max</span>(sum1,L1[i]+M1[n<span class="number">-1</span>-(i<span class="number">+1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getMaxSum</span>(A, M, L2);</span><br><span class="line">        <span class="built_in">getMaxSum</span>(B, L, M2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = M<span class="number">-1</span>;i&lt;n-L;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1=<span class="built_in">max</span>(sum1,L2[i]+M2[n<span class="number">-1</span>-(i<span class="number">+1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(sum1,sum2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4. 字符流"></a>4. 字符流</h2><p>题号：1032</p>
<p>题目：字符流(Stream of Characters)</p>
<p>题意：给定一个单词表words，然后每次输入一个字母，假设地k次输入字母为a[k]。则a[i],a[i+1]…a[k]组成的单词(i&gt;&#x3D;1且i&lt;&#x3D;k),在单词表words中出现，输出true，否则输出false。</p>
<p>思路：<br>题目比较好理解，主要是根据words建立字典，由于都是小写字母，而且涉及到前缀的查询，用trie树是最好的数据结构。</p>
<p>对于每次输入字母a[k]，首先查询a[k]是否匹配某个单词。然后把之前输入的前缀能查到的单词，和a[k]结合，再查询是否能匹配某个单词。如果完全匹配，则返回结果为true。在返回前，要把所有能匹配单词表中单词，或词表前缀的单词留下来，留着下一轮输入字母时匹配备用。</p>
<p>但是这里是有方法优化的，如果每次都重头匹配单词，会超时。优化的方法有三种，</p>
<p>一、把上次匹配到前缀的trie树节点指针存储起来，下次只匹配一次字母即可。</p>
<p>二、使用ac自动机进行多模式匹配。</p>
<p>三、trie树中存储倒序的字符串，然后把每次输入的字母都按顺序保存起来。按照倒序匹配，如果匹配到一个完整的单词，返回true；如果匹配到不存在的单词，则返回false；如果匹配的是某个前缀，继续往下匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode&#123;    </span><br><span class="line">public:</span><br><span class="line">    bool hasVal=false;</span><br><span class="line">    vector&lt;TrieNode*&gt; children;</span><br><span class="line">    TrieNode() : children(26,NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class TrieTree&#123;</span><br><span class="line">public:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">    TrieTree()</span><br><span class="line">    &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    int insert(string&amp; word)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        for(int i = 0; i &lt; word.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int n=word[i]-&#x27;a&#x27;;</span><br><span class="line">            if(p-&gt;children[n]==NULL)&#123;</span><br><span class="line">                p-&gt;children[n]=new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;children[n];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;hasVal=true;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    bool query_has_r_suffix(string&amp; word)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        for(int i=word.length()-1;i&gt;=0;--i)&#123;</span><br><span class="line">            char ch = word[i];</span><br><span class="line">            int n=ch-&#x27;a&#x27;;</span><br><span class="line">            if(p-&gt;children[n]==NULL)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;children[n];</span><br><span class="line">            if(p-&gt;hasVal) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class StreamChecker &#123;</span><br><span class="line">    TrieTree * tree =new TrieTree();</span><br><span class="line">    string suf_str;</span><br><span class="line">public:</span><br><span class="line">    StreamChecker(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">         for(string w:words)&#123;</span><br><span class="line">             reverse(w.begin(),w.end());</span><br><span class="line">             tree-&gt;insert(w);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool query(char letter) &#123;</span><br><span class="line">        suf_str.push_back(letter);</span><br><span class="line">        return tree-&gt;query_has_r_suffix(suf_str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your StreamChecker object will be instantiated and called as such:</span><br><span class="line"> * StreamChecker* obj = new StreamChecker(words);</span><br><span class="line"> * bool param_1 = obj-&gt;query(letter);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yunpengzhang.github.io/2019/Leetcode%20%E7%AC%AC133%E5%9C%BA%E5%91%A8%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/" data-id="clyu70knu006qb0oocwgnc3dp" data-title="Leetcode 第133场周赛解题报告" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E5%B7%A7/">技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E6%AD%A5/">跑步</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">七月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">十一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">十月 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/%E5%90%91%E7%9D%80%E7%9B%AE%E6%A0%87%E5%86%B2%E5%87%BB%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%EF%BC%9A%E7%A7%91%E6%AF%94%E8%87%AA%E4%BC%A0%E3%80%8B%20/">向着目标冲击——读《曼巴精神：科比自传》</a>
          </li>
        
          <li>
            <a href="/2020/%E8%AE%A4%E8%AF%86%E6%80%9D%E8%80%83%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E3%80%8A%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2%E3%80%8B/">认识思考的本质——《思考，快与慢》</a>
          </li>
        
          <li>
            <a href="/2019/%E5%A4%9A%E9%98%B6Hash%E7%AE%97%E6%B3%95/">多阶Hash算法</a>
          </li>
        
          <li>
            <a href="/2019/%E6%A0%BC%E9%9B%B7%E7%A0%81/">格雷码</a>
          </li>
        
          <li>
            <a href="/2019/%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">简单高效的排行榜算法——树状数组</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 owenzhang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>